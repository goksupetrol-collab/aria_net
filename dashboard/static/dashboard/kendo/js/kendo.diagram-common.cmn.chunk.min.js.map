{"version":3,"sources":["raw-js/kendo.diagram-common.cmn.chunk.js"],"names":["global","factory","exports","module","require","define","amd","globalThis","self","kendo","_globals","DiagramCommonCmnChunk","DrawingCmnChunk","CommonCmnChunk","this","kendo_drawing_cmn_chunk_js","kendo_common_cmn_chunk_js","WIDTH","HEIGHT","X","Y","TRANSPARENT","START$1","END$1","CENTER","NEW_LINE_CHAR","EMPTY","WRAP","MarkerType","DEG_TO_RAD","Math","PI","EPSILON","CHANGE$1","Cursors","arrow","grip","cross","add","move","select","south","east","west","north","rowresize","colresize","HIT_TEST_DISTANCE","AUTO","TOP","RIGHT","LEFT","BOTTOM","DRAG_START","DRAG","DRAG_END","ITEMROTATE","ITEMBOUNDSCHANGE","MOUSE_ENTER","MOUSE_LEAVE","ZOOM_START","ZOOM_END","TOOLTIP_SHOW","TOOLTIP_HIDE","PAN","ROTATED","SOURCE","TARGET","HANDLE_NAMES","ConnectionEditing","INLINE","INLINE_PADDING","left","right","top","bottom","CASCADING","MAXINT","SELECT$1","NONE","MAX_VALUE","Number","MIN_VALUE","TRANSFORMED","isNearZero","value","abs","isDefined","obj","defined","isFunction$1","isUndefined","isObject","Object","has","key","hasOwnProperty","call","isString$1","prototype","toString","isNumber","isNaN","parseFloat","isFinite","isEmpty","Array","isArray","length","simpleExtend","destination","source","name","initArray","size","array","i","randomInteger","lower","upper","random","floor","parseInt","DFT","el","func","childNodes","item","findRadian","start","end","sngXComp","x","sngYComp","y","atan","sign","num","findAngle","center","forEach","arr","iterator","thisRef","getAny","predicate","remove","what","ax","indexOf","splice","contains","includes","inArray","grep$1","filter","fold","list","acc","context","initial","undefined","Error","find","bind","first","constraint","insert","element","position","all","result","clear","bisort","a","b","sortfunc","points","push","sort","m","n","addRange","range","noop$1","STRING","FUNCTION","preventDefault$2","_defaultPrevented","isDefaultPrevented","Observable","constructor","options","events","_events","destroy","unbind","event","handlers","one","eventNames","handlersIsFunction","original","handler","idx","eventName","args","apply","String","from","curName","unshift","trigger","eventArgs","e","sender","preventDefault","slice","_setEvents","Utils$1","freeze","__proto__","deserializePoints","s","v","split","getMatrixAngle","d","atan2","getMatrixScaling","sqrt","c","grep","isBoolean","isFunction","isString","isType","type","noop","serializePoints","res","p","join","Easing","easeInOut","pos","cos","Ticker","adapters","target","tick","interval","duration","lastTime","timerDelegate","intervalId","caller","onTimerEvent","addAdapter","onComplete","removeHandler","h","onStep","seekTo","to","seekFromTo","max","min","Date","getTime","window","setInterval","stop","clearInterval","play","origin","initState","reverse","propagate","update","now","timePassed","movement","randomId","chars","charAt","round","HashTable","_buckets","_stringsMap","Map","_stringsCounter","_createGetBucket","get","_bucketExists","set","containsKey","hashId","_hash","hashes","_hashes","len","hash","bucket","clone","ht","_hashString","_objectHashId","id","_hashId","Dictionary","dictionary","super","_hashTable","k","entry","forEachValue","forEachKey","keys","Geometry","_distanceToLineSquared","d2","pt1","pt2","vx","vy","dot","distanceToLine","distanceToPolyline","minimum","p1","p2","Polar","r","angle","Point","P","plus","minus","offset","times","normalize","lengthSquared","middleOf","q","toPolar","useDegrees","factor","halfpi","isOnLine","temp","r1","Rect","inflate","r2","o1","u1","union","height","width","parse","str","xy","point","dx","dy","x1","y1","x2","y2","topLeft","topRight","bottomLeft","bottomRight","equals","rect","rotatedBounds","rotatedPoints","tl","tr","br","bl","rotate","delimiter","scale","scaleX","scaleY","staicPoint","adornerCenter","thisCenter","delta","scaled","zoom","overlaps","rectBottomRight","toRect","empty","fromPoints","RectAlign","container","align","content","alignment","alignValues","toLowerCase","_singleAlign","_align","_left","_center","_right","stretch","_stretch","_top","middle","_middle","_bottom","alignCalc","Queue","_tail","_head","enqueue","next","dequeue","current","OBJECT","deepExtendOne","property","propValue","propType","propInit","destProp","deepExtend","sources","LayoutDefaultOptions","subtype","roots","animate","limitToView","friction","nodeDistance","iterations","horizontalSeparation","verticalSeparation","underneathVerticalTopOffset","underneathHorizontalOffset","underneathVerticalSeparation","grid","offsetX","offsetY","componentSpacingX","componentSpacingY","layerSeparation","layeredIterations","startRadialAngle","endRadialAngle","radialSeparation","radialFirstLevelSeparation","keepComponentsInOneRadialLayout","ignoreContainers","layoutContainerChildren","ignoreInvisible","animateTransitions","LayoutBase","defaultOptions","gridLayoutComponents","components","calcBounds","bounds","maxWidth","startX","resultLinkSet","resultNodeSet","component","pop","moveToOffset","nodes","links","boundingRect","currentHeight","currentWidth","j","deltaX","deltaY","node","nodeBounds","link","newPoints","pt","currentHorizontalOffset","transferOptions","LayoutState","diagram","graphOrNodes","nodeMap","linkMap","capture","diagramOrGraphOrNodes","shape","conn","associatedShape","visual","associatedConnection","shapes","connections","Node","outgoing","incoming","weight","data","isVirtual","shortForm","isIsolated","isLinkedTo","getComplement","getChildren","children","getParents","parents","copy","balance","owner","adjacentTo","removeLink","hasLinkTo","degree","incidentWith","getLinksWith","getNeighbors","neighbors","Link","connection","sourceFound","targetFound","getCommonNode","isBridging","v1","v2","getNodes","changeSource","changeTarget","changesNodes","w","oldSource","oldTarget","directTo","createReverseEdge","reversed","Graph","idOrDiagram","_nodeMap","_root","_hasCachedRelationships","componentIndex","cacheRelationships","forceRebuild","assignLevels","startNode","visited","level","child","root","found","getConnectedComponents","setItemIndices","componentId","_collectConnectedNodes","addNodeAndOutgoings","setIds","nodeIndex","nextId","index","getSpanningTree","tree","map","rootClone","remaining","_addNode","levelCount","ni","cn","newLink","addLink","treeLevels","takeRandomNode","excludedNodes","incidenceLessThan","pool","isHealthy","hasNode","sourceOrLink","addExistingLink","foundSource","getNode","addNode","foundTarget","removeAllLinks","hasLink","t","linkOrId","nodeOrId","_removeNode","removeNode","areConnected","n1","n2","layoutRect","newNode","newLinks","saveMapping","save","nOriginal","nCopy","linkOriginal","linkCopy","linearize","addIds","Utils","depthFirstTraversal","action","foundNode","_dftIterator","breadthFirstTraversal","queue","_stronglyConnectedComponents","excludeSingleItems","indices","lowLinks","connected","stack","findCycles","isAcyclic","isSubGraph","other","otherArray","thisArray","makeAcyclic","oneNode","rev","N","intensityCatalog","flowIntensity","catalogEqualIntensity","intensity","sourceStack","targetStack","targets","li","targetLink","si","sourceLink","ri","ril","u","concat","vertexOrder","kk","reversedEdges","Predefined","EightGraph","Mindmap","ThreeGraph","BinaryTree","levels","createBalancedTree","Linear","Tree","siblingsCount","Forest","trees","createBalancedForest","Workflow","Grid","g","previous","graphString","previousLink","graph","parts","part","lin","_addShape","kendoDiagram","shapeDefaults","radius","fill","undoable","addShape","_addConnection","connect","createDiagramFromGraph","doLayout","randomSize","clientWidth","clientHeight","opt","color","gli","sourceShape","targetShape","SpringLayout","layoutGraph","shi","news","counter","lastAdded","parent","treeCount","createRandomConnectedGraph","nodeCount","maxIncidence","isTree","poolNode","randomAdditions","randomDiagram","shapeCount","layout","DiagramToHyperTreeAdapter","convert","finalNodeSet","initialTemperature","temperature","guessBounds","_expectedBounds","step","refineStage","_repulsion","_attraction","_shake","rho","alpha","sin","_InverseSquareForce","force","deltax","deltay","wn","hn","wm","hm","pow","_SquareForce","distance","squareSize","area","ceil","shapeMap","edges","edgeMap","finalNodes","finalLinks","ignoredConnections","ignoredShapes","hyperMap","hyperTree","finalGraph","_renormalizeShapes","_renormalizeConnections","l","mapConnection","mapShape","getEdge","listToRoot","containerGraph","parentContainer","firstNonIgnorableContainer","isContainer","isIgnorableItem","isContainerConnection","isDescendantOf","scope","containers","isCollapsed","_isVisible","_isTop","isShapeMapped","leastCommonAncestor","al","xa","xb","visible","_isCollapsed","sourceConnector","sink","targetConnector","sourceNode","sinkNode","areConnectedAlready","newEdge","intersectLine","start1","end1","start2","end2","isSegment","tangensdiff","Intersect","lines","segments","rectWithLine","rects","rect1","rect2","intersect","reverseAngle","MatrixVector","f","fromMatrix","Matrix","applyRect","fromSVGMatrix","vm","fromMatrixVector","fromList","translation","unit","rotation","scaling","nums","trim","substr","PathDefiner","Set","resource","kv","toArray","Size","Empty","Rotation","toMatrix","invert","create","values","ZERO","Scale","Translation","toMatrixVector","Length","CompositeTransform","translate","transform","render","_transform","_renderTransform","rotateMatrix","scaleMatrix","translatePoint","diffNumericOptions","fields","elementOptions","hasChanges","field","Element","_originSize","drawingContainer","redraw","drawingElement","matrix","M","_hover","_diffNumericOptions","_measure","_measured","box","_boundingBox","R","startPoint","_originWidth","_originHeight","rawBBox","sizeOptionsOrDefault","normalizeDrawingOptions","drawingOptions","getColor","C","toHex","createSegment","S","toDrawingRect","getSpacing","defaultSpacing","spacing","drawRoundedPolygon","path","prev","curr","cornerRadius","len1","hypot","len2","cosPhi","phi","acos","ds","tan","dsClamped","moveTo","lineTo","sweep","arcTo","close","fitToSize","strokeWidth","bb","bbox","targetH","sx","sy","inflatePolygon","out","bLen","outDir","defaultOptions$m","stroke","VisualBase","opacity","_fill","_stroke","show","hover","_setFill","_evalStrokeOptions","strokeOptions","dashType","_evalFillOptions","fillOptions","gradient","GradientClass","L","defaultOptions$l","MarkerBase","anchor","createElement","_transformToPath","transformCopy","defaultArrowOptions","ArrowMarker","positionMarker","_linePoints","transform$1","xDiff","yDiff","lineAngle","endPoint","targetSegment","controlOut","nextSegment","controlIn","prevSegment","Canvas$1","_translate","viewBox","_viewBox","surface","G","clippedBBox","setSize","draw","append","insertBefore","clearHtml","firstChild","removeChild","removeChildren$1","AutoSizeableMixin","_setScale","originWidth","originHeight","_setTranslate","_initSize","autoSize","_updateSize","Circle","_initCircle","circleOptions","_circle","setRadius","defaultOptions$k","CircleMarker","Rectangle","_initPath","_setPosition","_drawPath","drawPolygon","MultiPathShape","defaultOptions$j","shapesOffsetRatio","Collate","shapesOffset","halfWidth","halfHeight","OnPageConnector","centerX","defaultOptions$i","slantRatio","DataInputOutput","slant","defaultOptions$h","ellipseRxRatio","ellipseRyRatio","Database","rx","ellipseRY","cy","ry","defaultOptions$g","ellipseRadiusXRatio","ellipseRadiusYRatio","DataStorage","ellipseRX","leftCx","arc","Decision","inflated","defaultOptions$f","arcRadiusXRatio","arcRadiusYRatio","Delay","arcRadiusX","arcRadiusY","defaultOptions$e","ellipseRatio","DirectAccessStorage","cx","defaultOptions$d","sideCutRatio","Display","arcStartX","cut","cp1XRatio","cp2XRatio","docDefaultOptions","waveRatio","multyDocsDefaultOptions","docsXRatio","docsYRatio","drawDocument","amplitude","curveTo","Document","halfAmplitude","MultipleDocuments","docOffsetX","docOffsetY","path1","path2","Terminator","Extract","Group","_childrenChange","_remove","removeAt","toFront","visuals","toBack","_reorderChildren","toIndex","group","drawingChildren","fixedPosition","boundingBox","childBoundingBox","_includeInBBox","Image","_initImage","src","_rect","I","sizeOptions","o","defaultOptions$c","leftLineOffsetRatio","topLineOffsetRatio","InternalStorage","leftLineX","topLineOffset","MarkerPathMixin","_getPath","paths","_normalizeMarkerOptions","startCap","endCap","_removeMarker","marker","_markers","_createMarkers","_createMarker","markerType","FilledCircle","ArrowStart","ArrowEnd","_positionMarker","_capMap","_redrawMarker","pathChange","pathOptions","cap","pathCapType","optionsCap","created","_redrawMarkers","defaultOptions$b","topSlantRatio","ManualInputOutput","defaultOptions$a","baseShrinkRatio","ManualOperation","baseShrink","Merge","LogicalOr","centerY","defaultOptions$9","bottomEdgeYRatio","OffPageConnector","topY","leftY","rightY","bottomY","bottomMiddleX","bottomMiddleY","Path","_createElements","_setData","multipath","elements","Polyline","_updatePath","_pointsDiffer","currentPoints","differ","pts","eps","EPS","dist","dedupe","u2","isRightAngle","rightAngleTolerance","KAPPA","c1","c2","last","createRoundedPolyline","defaultOptions$8","sideLineOffsetRatio","PredefinedProcess","sideLineOffset","rightLineX","defaultOptions$7","horizontalInsetRatio","Preparation","xOffset","Process","defaultOptions$6","Sort","SummingJunction","SQRT2","textColor","defaultTextOptions","fontSize","fontFamily","lineSpacing","textWrap","padding","relativePadding","TextBlock","textElements","alignable","_font","_initText","T","text","font","fontOptions","fontStyle","fontWeight","sizeChanged","textOptions","TextLayout","measure","_initMap","groups","groupsSize","_initGroups","sizeField","groupsSizeField","_fieldMap","maxSize","transformation","emptyRect","currentTransform","rawBox","Box","pad","unpad","parseAlign","justifyContent","alignContent","textRect","shapeSize","userPadding","curPadding","style","getFont","measures","line","reduce","measured","sum","userRelativePadding","getContentSpacing","curRelativePadding","MultiLineTextBlock","arguments","_textLines","textElement","appendBreak","reflow","hasBackground","background","hasBorder","border","textBbox","_textOnlyRect","textPadding","bgRect","measureText$1","words","currentLine","word","testPart","substring","testLine","LayeredLayout","_initRuntimeProperties","layer","downstreamLinkCount","upstreamLinkCount","uBaryCenter","dBaryCenter","upstreamPriority","downstreamPriority","gridPosition","_prepare","layerMap","layerCount","targetLayer","shift","sortedNodes","o2","o1layer","o2layer","minLayer","layers","linksTo","layerVal","_dummify","_optimizeCrossings","_swapPairs","arrangeNodes","_moveThingsAround","_dedummify","setMinDist","_n","minDist","layerIndex","isInteger","minDistances","getMinDist","i1","i2","placeLeftToRight","leftClasses","leftPos","classNodes","placeLeft","POSITIVE_INFINITY","rightSibling","nodeLeftClass","D","upNodes","downNodes","neighbor","intDiv","placeRightToLeft","rightClasses","rightPos","placeRight","NEGATIVE_INFINITY","leftSibling","nodeRightClass","_getLeftWing","leftWing","computeClasses","_getRightWing","rightWing","wingPair","currentWing","wing","ndsinl","_nodesInLink","vnode","wings","classIndex","_isVerticalLayout","_isHorizontalLayout","_isIncreasingLayout","_gridPositionComparer","gNode","dest","down","up","currentNode","currDown","downNode","order","placed","sequenceStart","ll","layer2","virtualStartIndex","_firstVirtualNode","virtualStart","sequence","_sequencer","virtualEnd","nextVirtualNode","virtualEndIndex","adjustDirections","fromLayerIndex","layerIncrement","maximumHeight","ctx","nn","node2","prevBridge","prevBridgeTarget","nextBridge","nextBridgeTarget","getNeighborOnLayer","clayer","j1","j2","dir","_sequenceSingle","combineSequences","leftHeap","pair","_positionDescendingComparer","rightHeap","_positionAscendingComparer","leftRes","rightRes","leftClass","_getComposite","rightClass","it","layoutLayer","gridPos","iconsidered","considered","sorted","n1Priority","n2Priority","nodeGridPos","nodeBaryCenter","calcBaryCenter","nodePriority","moveRight","moveLeft","calcDownData","calcUpData","priority","rightNode","rightNodePriority","leftNode","leftNodePriority","mapVirtualNode","nodeToLinkMap","linkToNodeMap","addLinkBetweenLayers","upLayer","downLayer","oLayer","dLayer","oPos","dPos","depthOfDumminess","dedum","prevLink","moves","iter","optimizeLayerCrossings","total","presorted","n1BaryCenter","n2BaryCenter","compareByIndex","compareValue","inode","maxIterations","downwards","secondPass","hasSwapped","calcCrossings","memCrossings","crossBefore","countLinksCrossingBetweenTwoLayers","node1","node1GridPos","node2GridPos","crossAfter","revert","ulayer","dlayer","link1","link2","n11","n12","n21","n22","l1","l2","crossings","n11gp","n12gp","numerator","denominator","TreeLayoutProcessor","treeGraph","layoutSwitch","layoutLeft","setChildrenDirection","setChildrenLayout","TreeDirection","arrange","layoutRight","layoutUp","layoutDown","treeDirection","layoutRadialTree","previousRoot","startAngle","endAngle","maxDepth","calculateAngularWidth","radialLayout","Angle","tipOverTree","startFromLevel","diameter","aw","sectorAngle","sortChildren","basevalue","pl","nl","normalizeAngle","count","col","deltaTheta","deltaThetaHalf","parentSector","fraction","childNode","cp","childAngleFraction","setPolarLocation","BoundingRectangle","direction","includeStart","rootDirection","rootLayout","childrenLayout","givenSize","shapeWidth","shapeHeight","AngleToParent","SectorAngle","pp","childrenwidth","selfLocation","single","male","female","leftcount","tipOverTreeStartLevel","TreeLayout","adapter","layoutComponents","getTree","getTreeForRoot","AdornerBase","_adorners","refresh","ConnectionEditUndoUnit","undoSource","undoTarget","_undoSource","_undoTarget","_redoSource","_redoTarget","title","undo","_updateConnector","updateModel","redo","isAutoConnector","connector","closestConnector","connectors","resCtr","minimumDistance","distanceTo","indicesOfItems","filterShapeDataItem","dataItem","FlowchartShapeType","documentConnectors","shapeVisual","getPosition","triangleConnectors","RotateUnit","adorner","undoRotates","redoRotates","redoAngle","_angle","_innerBounds","_initialize","defaultOptions$5","Connector","toJSON","shapeId","tempStr","getConnector","DefaultConnectors","extra","defaults","minWidth","minHeight","tooltip","editable","tools","compile","template","_options","TemplateService","register","userImplementation","getTemplate","getSupportedFeatures","os","ua","agentRxs","wp","fire","android","iphone","ipad","playbook","windows","tizen","sailfish","osRxs","ios","flat","agent","match","navigator","device","testRegex","detectOS","userAgent","support","mobileOS","regexes","dflt","regex","test","extend$1","assign","addClass","className","classList","convertToHtml","html","div","document","innerHTML","prepend","originElement","getTextElementType","linesFit","styles","defaultOptions$4","cursor","selectable","serializable","enable","DiagramElement","isSelected","_template","_getCursor","serialize","json","_content","contentOptions","contentVisual","_contentVisual","_updateContentVisual","_createContentVisual","Type","_hitTest","elementTemplate","_canSelect","Shape","_originalWidth","_originalHeight","updateOptionsFromModel","createShapeVisual","updateBounds","_createConnectors","_setOptionsFromModel","model","modelOptions","redrawVisual","_isEditable","_redrawVisual","syncChanges","updateShapeModel","_rotate","_alignContent","containerRect","aligner","contentBounds","contentRect","alignedBounds","currentConnectors","connectorDefaults","_transformedBounds","pan","_pan","_rotatedBounds","_bounds","_setBounds","_triggerBoundsChange","_layouting","refreshConnections","cloneDataItem","selected","deselected","_selectedItems","_internalSelection","_selectionChanged","undoRedoService","_resizingAdorner","sc","deltaAngle","newPosition","_rotationOffset","_connectorsAdorner","con","cons","ctr","nameOrPoint","toLocaleLowerCase","side","fnName","_transformPoint","shapeOptions","boundsChange","_visualOptions","_updateConnectors","modelToView","_showConnectors","rotatedPoint","visualOptions","visualTemplate","translateToOrigin","ConnectionEditAdorner","handles","_ts","toolService","sp","sourcePoint","tp","targetPoint","spVisual","epVisual","handle","_initialSource","_initialTarget","_connectionManipulation","ts","hoveredItem","_hoveredConnector","_c","radiusX","radiusY","sourcePointDistance","targetPointDistance","sourceHandle","targetHandle","modelToLayer","ConnectorVisual","relative","_visualBounds","ConnectorsAdorner","_refreshHandler","_visible","_clearVisual","_cachedTouchTarget","_keepCachedTouchTarget","visualChildren","childrenCount","canDrag","drag","TransformUnit","undoStates","redoStates","refreshBounds","defaultOptions$3","ResizingAdorner","_manipulating","shapeStates","_initSelection","_createHandles","_internalChange","_rotatedHandler","_resizable","resize","_handleOptions","handlesCount","hit","handleBounds","_getHandleBounds","items","_startAngle","_rotates","_positions","initialRotates","initialStates","handleOptions","_sp","_cp","_lp","visibleHandles","currentAngle","dragging","newBounds","staticPoint","dtl","dbr","changed","_truncateAngle","_rotating","shouldSnap","thr","_truncateDistance","isDragHandle","hitToOppositeSide","_displaceBounds","newCenter","oldBounds","cancel","states","_truncatePositionToGuides","ruler","truncatePositionToGuides","_truncateSizeToGuides","truncateSizeToGuides","snap","snapOptions","snapAngle","snapSize","_a","_b","_diffStates","_syncShapeChanges","rotationThumb","thumb","_rotationThumbBounds","defaultOptions$2","Selector","_ep","_adorn","visualBounds","ConnectionRouterBase","LinearConnectionRouter","hitTest","getBounds","allPoints","CascadingRouter","SAME_SIDE_DISTANCE_RATIO","_connectorSides","axis","boundsPoint","secondarySign","routePoints","_connectorPoints","_floatingPoints","route","_resolvedSourceConnector","_resolvedTargetConnector","_connectorSide","shapeBounds","sides","sideDistance","minSide","_sameSideDistance","sourceConnectorSide","targetConnectorSide","sameSideDistance","pointX","pointY","cascadeStartHorizontal","_startHorizontal","shiftX","shiftY","sourceSide","horizontal","PolylineRouter","ConnectionEditTool","tryActivate","_p","meta","isActive","ctrlKey","nativeEvent","selectSingle","connectionHandle","handleName","_syncConnectionChanges","getCursor","ConnectionTool","_createConnection","_removeHover","activeConnection","cachedTouchTarget","EmptyTool","noMeta","altKey","shiftKey","PointerTool","eventMap","queryEventMap","applyEventMap","replace","elementOffset$1","TapCapture","domElement","_pressHandler","_press","_releaseHandler","_release","addEventListener","captureNext","cancelCapture","removeEventListener","PaneDimension","forcedEnabled","scrollSize","makeVirtual","virtual","_virtualMin","_virtualMax","virtualSize","outOfBounds","forceEnabled","getSize","getTotal","rescale","silent","scaledTotal","minScale","centerOffset","enabled","PaneDimensions","forcedMinScale","maxScale","newScale","centerCoordinates","fitScale","PaneAxis","dimension","movable","dragMove","dragDelta","resistance","translateAxis","Pane","elastic","dimensions","userEvents","gesturestart","gesture","press","closestAnchor","closest","matches","gesturechange","previousGesture","previousCenter","scaleDelta","coordinates","scaleWith","tagName","touch","skip","Movable","transformOrigin","_saveCoordinates","by","scaleTo","moveAxis","newCoordinates","animationFrame","callback","requestAnimationFrame","Animation","_tickProxy","_tick","_started","done","onEnd","onCancel","Transition","startDate","location","_easeProxy","ease","easeOutExpo","elementEventHandlers","WeakMap","ID","Symbol","on","useCapture","eventHandler","eventFilter","attachedHandler","closestMatchingTarget","currentTarget","defineProperty","guid","eventHandlers","Boolean","addEventListeners","off","handlerId","delete","removeEventListeners","preventDefault$1","PRESS","HOLD","SELECT","START","MOVE","END","CANCEL","TAP","DOUBLETAP","RELEASE","GESTURECHANGE","GESTUREEND","GESTURETAP","THRESHOLD","api","mouse","pointer","DEFAULT_MIN_HOLD","DEFAULT_THRESHOLD","getTouches","touches","originalEvent","pointerId","TouchAxis","invalidZeroEvents","_updateLocationData","startLocation","velocity","timeStamp","timeDelta","initialDelta","client","screen","Touch","touchInfo","threshold","initialTouch","pressEvent","_clicks","supportDoubleTap","_moved","_finished","_holdTimeout","setTimeout","_hold","minHold","_trigger","_tap","_clickTimeout","preventMove","_shouldNotMove","_withinIgnoreThreshold","UserEvents","dispose","_start","endTime","clearTimeout","activeTouches","activeTouchIndex","isMoved","startTime","notify","xDelta","yDelta","withEachUpEvent","downEvents","_maxTouches","multiTouch","allowSelection","captureUpIfMoved","stopPropagation","pressed","_surfaceMoveHandler","_move","_surfaceEndHandler","_end","_elementStartHandler","touchAction","preventDragEvent","_elementDragStartHandler","_elementSelectHandler","_select","surfaceElement","preventIfMovingProxy","preventIfMoving","_isMoved","_destroyed","_disposeAll","_isMultiTouch","touch1","touch2","touchDelta","_apiCall","_maxTouchesReached","which","eventTouches","eventTouch","_eachTouch","methodName","dict","matchingTouch","hasPointerCapture","setPointerCapture","pageX","pageY","clientX","clientY","defaultThreshold","extend","CHANGE","SCROLL","ZoomSnapBack","tapCapture","DragInertia","transition","_moveTo","paneAxis","_snapBack","velocityMultiplier","snapBack","AnimatedScroller","_to","_updateCoordinates","setCoordinates","setCallback","ScrollBar","elementSize","scrollMovable","alwaysVisible","appendChild","paneSize","sizeRatio","display","visibility","hide","defaultScrollerOptions","pullOffset","visibleScrollHints","useNative","mousewheelScrolling","avoidScrolling","pullToRefresh","messages","pullTemplate","releaseTemplate","refreshTemplate","Scroller","_initOptions","hasScrolling","hasNativeScrolling","_native","scrollHeader","scrollElement","fixedContainer","overflow","wrapper","wrapInner","inner","velocityX","velocityY","horizontalSwipe","verticalSwipe","pane","zoomSnapBack","animatedScroller","scrollTo","scrollTop","scrollLeft","_wheelScrollHandler","_wheelScroll","pulled","_initAxis","_wheelEnd","_wheel","_wheelY","_initPullToRefresh","_wheelTimeout","wheelDeltaY","wheelDelta","detail","VERTICAL_AXIS","scrollHeight","scrollWidth","_resize","contentResized","setOptions","reset","_scale","zoomOut","disable","animatedScrollTo","pullHandled","_dragEnd","_paneChange","scrollBar","macOS","ScrollerTool","canvas","_mobileOS","scroller","scrollable","scroll","movableCanvas","virtualScroll","pannable","macCmd","metaKey","hoveredAdorner","scrollPos","_storePan","SelectionTool","multiple","deselect","selector","selectArea","testKey","charCodeAt","toUpperCase","ConnectionEditUnit","redoSource","redoTarget","defaultOptions$1","fromConnector","toConnector","connectionTextOptions","bgColor","Connection","_initRouter","_sourcePoint","_targetPoint","_setSource","_setTarget","definers","dataMap","_dataMap","fromX","fromY","toX","toY","filterConnectionDataItem","updateConnectionModel","shapeSource","defaultConnector","_removeFromSourceConnector","_clearSourceConnector","_setFromOptions","addCompositeItem","fromPoint","sourceDefiner","_sourceDefiner","shapeTarget","_removeFromTargetConnector","_clearTargetConnector","_setToOptions","toPoint","targetDefiner","_targetDefiner","instance","getShapeById","connectorName","setNewTarget","inactiveItem","_inactiveShapeItems","getByUid","uid","_deferredConnectionUpdates","onActivate","hasVisual","hasTemplate","templateOptions","templateResult","textBlockOptions","endIdx","startIdx","alignToPath","verticalPosition","vertical","horizontalPosition","isInline","originOffsetX","originOffsetY","midIdx","isVertical","isHorizontal","selection","_router","definition","_resolveConnectors","_refreshPath","sourceConnectors","targetConnectors","_resolveAutoConnectors","minNonConflict","minNonConflictSource","minNonConflictTarget","minSource","minTarget","sourceIdx","targetIdx","_testRoutePoints","router","passRoute","exclude","_getRouteExclude","_shapesQuadTree","hitTestRect","_isPointInsideShape","boundsX","boundsY","ToolService","activeTool","_updateHoveredItem","_activateTool","_updateCursor","focus","suspendTracking","updateHovered","resumeTracking","keyDown","toRemove","_triggerRemove","_syncChanges","_destroyToolBar","_discardNewConnection","selectAll","paste","wheel","z","zoomRate","zoomOptions","zoomMin","zoomMax","setTool","tool","addToSelection","newConnection","disabledShape","isNew","selectedConnections","_hitTestItems","_hitTestElements","shapeHit","connectionHit","hitTestShapeConnectors","mainLayer","AddConnectionUnit","AddShapeUnit","CompositeUnit","units","undoUnit","DeleteConnectionUnit","DeleteShapeUnit","PositionAdapter","layoutState","froms","tos","subjects","LayoutUndoUnit","initialState","finalState","_initialState","_finalState","setState","state","ticker","ToBackUnit","initialIndices","_toIndex","ToFrontUnit","UndoRedoService","capacity","begin","composite","commit","execute","_restart","InactiveItem","callbacks","Promise","resolve","activate","InactiveItemsCollection","QuadRoot","_add","_quadNode","_testRect","QuadNode","inBounds","nodeRect","nodeBottomRight","overlapsBounds","inserted","_initChildren","childIdx","shapeIdx","ShapesQuadTree","ROOT_SIZE","boundsChangeHandler","_boundsChange","initRoots","rootMap","rootSize","sectors","getSectors","inRoot","bottomX","xIdx","yIdx","copyDefaultOptions","mainOptions","theme","dataSource","draggable","autoBind","delay","format","connectionDefaults","domEvents","splitDiagramElements","outerHeight","includeMargins","heightValue","offsetHeight","getComputedStyle","marginTop","marginBottom","$","A","B","E","F","H","J","K","O","Q","Infinity","curK","rangeIntegerScale","U","V","W","Z","_","__meta__","category","description","depends","hidden","chunk","a0","a1","drawingRect","a2","a3","a4","a5","a6","a7","a8","a9","aA","aB","initialPosition","finalPosition","finalPos","aC","aD","aE","aF","aG","aH","aI","aJ","aK","aL","aM","aN","aO","aP","aQ","aR","aS","aT","userOptions","themeOptions","_clipboard","_connectionsDataMap","_domEvent","_meta","_eventPositions","createToolBar","destroyToolBar","_initTheme","_initElements","_extendLayoutOptions","_initDefaults","_interactionDefaults","_initCanvas","adornerLayer","_createHandlers","pauseMouseHandlers","_createShape","setAttribute","userShapeDefaults","mobile","canvasContainer","viewPort","viewport","Canvas","_wheelHandler","_keydownHandler","_keydown","browser","mobilesafari","_userEvents","fastTap","tap","_dragStart","_drag","_gestureStart","_gestureChange","gestureend","_gestureEnd","doubleTap","_doubleTap","_mouseoverHandler","_mouseover","_mouseoutHandler","_mouseout","_mouseMoveHandler","_mouseMove","_mouseDownHandler","_mouseDown","_mouseUpHandler","_mouseUp","_initResizeObserver","_onMouseEnter","_onMouseLeave","_tooltipTimeOut","observer","ResizeObserver","entries","_resizeObserver","observe","_destroyResizeObserver","disconnect","_pauseMouseHandlers","focused","ctrlPressed","keyCode","mwDelta","documentToModel","initialCenter","_gesture","_initialCenter","documentToView","_zoom","updateZoom","_getValidZoom","zoomedPoint","_panTransform","_updateAdorners","pointPosition","toolBar","_kendoNode","srcElement","_createOptionElements","shapesLength","_createShapes","_createConnections","_findConnectionTarget","destroyScroller","_destroyGlobalToolBar","ownerDocument","activeElement","offsets","documentElement","scrollContainer","parentNode","preventScroll","load","addConnection","added","removed","_parseBounds","_suspendModelRefresh","_removeItem","_resumeModelRefresh","_shouldRefresh","_suspended","_addConnections","_addConnectionDataItem","_validateConnector","_addDataItems","parentShape","_addDataItemByUid","resolvedOptions","_getDiagramItems","_fixOrdering","bringIntoView","_zoomMainLayer","newPan","alignShapes","val","raw","hideTooltip","_getPan","paddingLeft","paddingRight","elementWidth","paddingTop","paddingBottom","elementHeight","_copyOffset","copied","mapping","_updateCopiedConnection","sourceConnection","di","_containerOffset","containerOffset","getBoundingClientRect","doc","defaultView","scrollX","scrollY","elementOffset","viewToDocument","viewToModel","_transformWithMatrix","_matrixInvert","_matrix","_layerMatrix","layerToModel","_layerMatrixInvert","viewPoint","modelToDocument","_redrawConnections","getShapeByModelId","shapeResult","getShapeByModelUid","_transformMainLayer","_finishPan","NaN","_storeViewMatrix","_storeLayerMatrix","canvasTransform","shapePos","conPos","_addItem","_toolBarClick","_normalizePointZoom","undone","redone","adorners","_refresh","removedConnections","_removeShapeDataItem","_removeShape","_removeConnectionDataItem","_removeConnection","_removeShapeConnections","exportDOMVisual","scrollOffset","viewRect","clipPath","fromRect","wrap","clipWrap","clip","exportVisual","aU","aV","aW","aX","aa","none","arrowStart","filledCircle","arrowEnd","ab","ac","ad","ae","af","ag","ah","ai","aj","ak","am","an","ao","ap","aq","ar","as","at","au","av","ay","az","mean","deviation","log"],"mappings":"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","file":"kendo.diagram-common.cmn.chunk.min.js","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('kendo.drawing.cmn.chunk.js'), require('kendo.common.cmn.chunk.js')) :\n    typeof define === 'function' && define.amd ? define(['exports', 'kendo.drawing.cmn.chunk', 'kendo.common.cmn.chunk'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.kendo = global.kendo || {}, global.kendo._globals = global.kendo._globals || {}, global.kendo._globals.DiagramCommonCmnChunk = {}), global.kendo._globals.DrawingCmnChunk, global.kendo._globals.CommonCmnChunk));\n})(this, (function (exports, kendo_drawing_cmn_chunk_js, kendo_common_cmn_chunk_js) {\n    const __meta__ = {\n        id: \"diagram-common.cmn.chunk\",\n        name: \"DiagramCommonCmnChunk\",\n        category: \"web\",\n        description: \"A reusable outputed chunk of code\",\n        depends: ['drawing.cmn.chunk', 'common.cmn.chunk'],\n        hidden: true,\n        chunk: true,\n        \n    };\n\n    const WIDTH = 'width';\n    const HEIGHT = 'height';\n    const X = 'x';\n    const Y = 'y';\n    const FULL_CIRCLE_ANGLE = 360;\n    const TRANSPARENT = 'transparent';\n    const START$1 = 'start';\n    const END$1 = 'end';\n    const CENTER = 'center';\n    const NEW_LINE_CHAR = '\\n';\n    const SPACE = ' ';\n    const EMPTY = '';\n    const PX = 'px';\n    const WRAP = 'wrap';\n    const NO_WRAP = 'no-wrap';\n    /**\n     * @deprecated Use `MarkerType` instead.\n     */\n    const Markers = {\n        none: 'none',\n        arrowStart: 'ArrowStart',\n        filledCircle: 'FilledCircle',\n        arrowEnd: 'ArrowEnd'\n    };\n    var MarkerType;\n    (function (MarkerType) {\n        MarkerType[\"None\"] = \"none\";\n        MarkerType[\"ArrowStart\"] = \"ArrowStart\";\n        MarkerType[\"FilledCircle\"] = \"FilledCircle\";\n        MarkerType[\"ArrowEnd\"] = \"ArrowEnd\";\n    })(MarkerType || (MarkerType = {}));\n    ;\n    const DEG_TO_RAD = Math.PI / 180;\n    const EPSILON = 1e-06;\n    const CHANGE$1 = 'change';\n    const Cursors = {\n        arrow: 'default',\n        grip: 'pointer',\n        cross: 'pointer',\n        add: 'pointer',\n        move: 'move',\n        select: 'pointer',\n        south: 's-resize',\n        east: 'e-resize',\n        west: 'w-resize',\n        north: 'n-resize',\n        rowresize: 'row-resize',\n        colresize: 'col-resize'\n    };\n    const HIT_TEST_DISTANCE = 10, AUTO = 'Auto', TOP = 'Top', RIGHT = 'Right', LEFT = 'Left', BOTTOM = 'Bottom', DEFAULT_SNAP_SIZE = 10, DEFAULT_SNAP_ANGLE = 10, DRAG_START = 'dragStart', DRAG = 'drag', DRAG_END = 'dragEnd', ITEMROTATE = 'itemRotate', ITEMBOUNDSCHANGE = 'itemBoundsChange', MIN_SNAP_SIZE = 5, MIN_SNAP_ANGLE = 5, MOUSE_ENTER = 'mouseEnter', MOUSE_LEAVE = 'mouseLeave', ZOOM_START = 'zoomStart', ZOOM_END = 'zoomEnd', TOOLTIP_SHOW = 'tooltipShow', TOOLTIP_HIDE = 'tooltipHide', SCROLL_MIN = -20000, SCROLL_MAX = 20000, FRICTION$1 = 0.90, FRICTION_MOBILE = 0.93, VELOCITY_MULTIPLIER$1 = 5, PAN = 'pan', ROTATED = 'rotated', SOURCE = 'source', TARGET = 'target', HANDLE_NAMES = {\n        '-1': SOURCE,\n        '1': TARGET\n    };\n    const ConnectionEditing = 'Connection Editing';\n    const INLINE = 'inline';\n    const INLINE_PADDING = { left: 4, right: 4, top: 2, bottom: 2 };\n    const NS = '.kendoDiagram', CASCADING = 'cascading', CLICK = 'click', ERROR = 'error', MAXINT = 9007199254740992, SELECT$1 = 'select', NONE = 'none', DEFAULT_CANVAS_WIDTH = 600, DEFAULT_CANVAS_HEIGHT = 600, DEFAULT_SHAPE_TYPE = 'rectangle', DEFAULT_SHAPE_WIDTH = 100, DEFAULT_SHAPE_HEIGHT = 100, DEFAULT_SHAPE_MINWIDTH = 20, DEFAULT_SHAPE_MINHEIGHT = 20, DEFAULT_SHAPE_POSITION = 0, DEFAULT_CONNECTION_BACKGROUND = 'Yellow', MAX_VALUE = Number.MAX_VALUE, MIN_VALUE = -Number.MAX_VALUE, ABSOLUTE = 'absolute', TRANSFORMED = 'transformed', MOUSEWHEEL_NS = 'DOMMouseScroll' + NS + ' mousewheel' + NS, MOBILE_ZOOM_RATE = 0.05, MOBILE_PAN_DISTANCE = 5, CONNECTION_CONTENT_OFFSET = 5;\n\n    const isNearZero = (value) => Math.abs(value) < EPSILON;\n    const isDefined = (obj) => typeof obj !== 'undefined';\n    const defined = isDefined;\n    const isFunction$1 = (obj) => typeof obj === 'function';\n    const isUndefined = (obj) => typeof obj === 'undefined' || obj === null;\n    /**\n     * Returns whether the given object is an object or a value.\n     */\n    const isObject = (obj) => obj === Object(obj);\n    /**\n     * Returns whether the object has a property with the given name.\n     */\n    const has = (obj, key) => Object.hasOwnProperty.call(obj, key);\n    /**\n     * Returns whether the given object is a string.\n     */\n    const isString$1 = (obj) => {\n        return Object.prototype.toString.call(obj) === '[object String]';\n    };\n    const isBoolean = (obj) => {\n        return Object.prototype.toString.call(obj) === '[object Boolean]';\n    };\n    const isType = (obj, type) => {\n        return Object.prototype.toString.call(obj) === '[object ' + type + ']';\n    };\n    /**\n     * Returns whether the given object is a number.\n     */\n    const isNumber = (obj) => !isNaN(parseFloat(obj)) && isFinite(obj);\n    /**\n     * Return whether the given object (array or dictionary).\n     */\n    const isEmpty = (obj) => {\n        if (obj === null) {\n            return true;\n        }\n        if (Array.isArray(obj) || isString$1(obj)) {\n            return obj.length === 0;\n        }\n        for (const key in obj) {\n            if (has(obj, key)) {\n                return false;\n            }\n        }\n        return true;\n    };\n    const simpleExtend = (destination, source) => {\n        if (!isObject(source)) {\n            return;\n        }\n        for (const name in source) {\n            if (name) {\n                destination[name] = source[name];\n            }\n        }\n    };\n    /**\n     * Returns an array of the specified size and with each entry set to the given value.\n     *\n     * @param size\n     * @param value\n     * @returns {Array}\n     */\n    const initArray = (size, value) => {\n        const array = [];\n        for (let i = 0; i < size; ++i) {\n            array[i] = value;\n        }\n        return array;\n    };\n    const serializePoints = (points) => {\n        const res = [];\n        for (let i = 0; i < points.length; i++) {\n            const p = points[i];\n            res.push(p.x + ';' + p.y);\n        }\n        return res.join(';');\n    };\n    const deserializePoints = (s) => {\n        const v = s.split(';');\n        const points = [];\n        if (v.length % 2 !== 0) {\n            throw new Error('Not an array of points.');\n        }\n        for (let i = 0; i < v.length; i += 2) {\n            points.push({\n                x: parseInt(v[i], 10),\n                y: parseInt(v[i + 1], 10)\n            });\n        }\n        return points;\n    };\n    /**\n     * Returns an integer within the given bounds.\n     *\n     * @param lower The inclusive lower bound.\n     * @param upper The exclusive upper bound.\n     * @returns {number}\n     */\n    const randomInteger = (lower, upper) => {\n        const random = Math.floor(Math.random() * upper) + lower;\n        return parseInt(random.toString(), 10);\n    };\n    /*\n     Depth-first traversal of the given node.\n     */\n    const DFT = (el, func) => {\n        func(el);\n        if (el.childNodes) {\n            for (let i = 0; i < el.childNodes.length; i++) {\n                const item = el.childNodes[i];\n                DFT(item, func);\n            }\n        }\n    };\n    /*\n     Returns the angle in degrees for the given matrix\n     */\n    const getMatrixAngle = (m) => {\n        if (m === null || m.d === 0) {\n            return 0;\n        }\n        return Math.atan2(m.b, m.d) * 180 / Math.PI;\n    };\n    /*\n     Returns the scaling factors for the given matrix.\n     */\n    const getMatrixScaling = (m) => {\n        const sX = Math.sqrt(m.a * m.a + m.c * m.c);\n        const sY = Math.sqrt(m.b * m.b + m.d * m.d);\n        return [sX, sY];\n    };\n    const findRadian = (start, end) => {\n        if (start === end) {\n            return 0;\n        }\n        const sngXComp = end.x - start.x;\n        const sngYComp = start.y - end.y;\n        const atan = Math.atan(sngXComp / sngYComp);\n        if (sngYComp >= 0) {\n            return sngXComp < 0 ? atan + (2 * Math.PI) : atan;\n        }\n        return atan + Math.PI;\n    };\n    const sign = (num) => {\n        return num ? num < 0 ? -1 : 1 : 0;\n    };\n    const findAngle = (center, end) => {\n        return findRadian(center, end) * 180 / Math.PI;\n    };\n    const forEach = (arr, iterator, thisRef) => {\n        for (let i = 0; i < arr.length; i++) {\n            iterator.call(thisRef, arr[i], i, arr);\n        }\n    };\n    const getAny = (arr, predicate) => {\n        for (let i = 0; i < arr.length; ++i) {\n            if (predicate(arr[i])) {\n                return arr[i];\n            }\n        }\n        return null;\n    };\n    const remove = (arr, what) => {\n        let ax = arr.indexOf(what);\n        while (ax !== -1) {\n            arr.splice(ax, 1);\n            ax = arr.indexOf(what);\n        }\n        return arr;\n    };\n    const contains = (arr, obj) => {\n        return (arr || []).includes(obj);\n    };\n    const indexOf = (arr, what) => {\n        return arr.indexOf(what);\n    };\n    const inArray = (what, arr) => {\n        return arr.indexOf(what);\n    };\n    const grep$1 = (arr, predicate) => arr.filter(predicate);\n    const fold = (list, iterator, acc, context) => {\n        let initial = acc !== undefined;\n        for (let i = 0; i < list.length; i++) {\n            const value = list[i];\n            if (!initial) {\n                acc = value;\n                initial = true;\n            }\n            else {\n                acc = iterator.call(context, acc, value, i, list);\n            }\n        }\n        if (!initial) {\n            throw new Error('Reduce of empty array with no initial value');\n        }\n        return acc;\n    };\n    const find = (arr, iterator, context) => {\n        return arr.find(iterator.bind(context)) || undefined;\n    };\n    const first = (arr, constraint, context) => {\n        if (arr.length === 0) {\n            return null;\n        }\n        if (isUndefined(constraint)) {\n            return arr[0];\n        }\n        return find(arr, constraint, context);\n    };\n    /**\n     * Inserts the given element at the specified position and returns the result.\n     */\n    const insert = (arr, element, position) => {\n        arr.splice(position, 0, element);\n        return arr;\n    };\n    const all = (arr, iterator, context) => {\n        let result = true;\n        let value;\n        for (let i = 0; i < arr.length; i++) {\n            value = arr[i];\n            result = result && iterator.call(context, value, i, arr);\n            if (!result) {\n                break;\n            }\n        }\n        return result;\n    };\n    const clear = (arr) => {\n        arr.splice(0, arr.length);\n    };\n    const bisort = (a, b, sortfunc) => {\n        if (isUndefined(a)) {\n            throw new Error('First array is not specified.');\n        }\n        if (isUndefined(b)) {\n            throw new Error('Second array is not specified.');\n        }\n        if (a.length !== b.length) {\n            throw new Error('The two arrays should have equal length');\n        }\n        const points = [];\n        for (let i = 0; i < a.length; i++) {\n            points.push({ x: a[i], y: b[i] });\n        }\n        if (isUndefined(sortfunc)) {\n            points.sort((m, n) => m.x - n.x);\n        }\n        else {\n            points.sort((m, n) => sortfunc(m.x, n.x));\n        }\n        clear(a);\n        clear(b);\n        for (let i = 0; i < points.length; i++) {\n            a.push(points[i].x);\n            b.push(points[i].y);\n        }\n    };\n    const addRange = (arr, range) => {\n        arr.push(...range);\n    };\n    const noop$1 = () => { };\n\n    const STRING = 'string';\n    const FUNCTION = 'function';\n    const preventDefault$2 = function () {\n        this._defaultPrevented = true;\n    };\n    const isDefaultPrevented = function () {\n        return this._defaultPrevented === true;\n    };\n    /** @hidden */\n    class Observable {\n        /**\n         * Creates a new Observable instance.\n         * Initializes the options, events array, and internal event handlers storage.\n         */\n        constructor() {\n            this.options = {};\n            this.events = [];\n            this._events = {};\n        }\n        /**\n         * Destroys the observable instance and removes all event handlers.\n         * This method should be called when the observable is no longer needed to prevent memory leaks.\n         */\n        destroy() {\n            this.unbind();\n        }\n        /**\n         * Binds event handlers to one or more events.\n         * @param event The event name(s) to bind to, or an object mapping event names to handlers\n         * @param handlers The event handler(s) to bind. Can be a function or an object mapping event names to handlers\n         * @param one If true, the handler will be executed only once and then automatically unbound\n         * @returns The Observable instance for method chaining\n         */\n        bind(event, handlers, one) {\n            if (!handlers && isObject(event) && !Array.isArray(event)) {\n                for (const name in event) {\n                    if (event[name]) {\n                        this.bind(name, event[name]);\n                    }\n                }\n                return this;\n            }\n            const eventNames = typeof event === STRING ? [event] : event, handlersIsFunction = typeof handlers === FUNCTION;\n            let original, handler;\n            for (let idx = 0, length = eventNames.length; idx < length; idx++) {\n                const eventName = eventNames[idx];\n                handler = handlersIsFunction ? handlers : handlers[eventName];\n                if (handler) {\n                    if (one) {\n                        original = handler;\n                        handler = (...args) => {\n                            this.unbind(eventName, handler);\n                            original.apply(this, args);\n                        };\n                        handler.original = original;\n                    }\n                    this._events[eventName] = this._events[eventName] || [];\n                    this._events[eventName].push(handler);\n                }\n            }\n            return this;\n        }\n        /**\n         * Binds event handlers that will be executed only once.\n         * After execution, the handlers are automatically unbound.\n         * @param eventNames The event name(s) to bind to\n         * @param handlers The event handler(s) to bind\n         * @returns The Observable instance for method chaining\n         */\n        one(eventNames, handlers) {\n            return this.bind(eventNames, handlers, true);\n        }\n        /**\n         * Binds event handlers to be executed first (prepends to the handlers list).\n         * These handlers will be called before any previously bound handlers for the same event.\n         * @param eventName The event name(s) to bind to\n         * @param handlers The event handler(s) to bind\n         * @returns The Observable instance for method chaining\n         */\n        first(eventName, handlers) {\n            const eventNames = typeof eventName === STRING ? [String(eventName)] : Array.from(eventName), handlersIsFunction = typeof handlers === FUNCTION;\n            let handler;\n            for (let idx = 0, length = eventNames.length; idx < length; idx++) {\n                const curName = eventNames[idx];\n                handler = handlersIsFunction ? handlers : handlers[curName];\n                if (handler) {\n                    this._events[curName] = this._events[curName] || [];\n                    this._events[curName].unshift(handler);\n                }\n            }\n            return this;\n        }\n        /**\n         * Triggers an event, calling all bound handlers for that event.\n         * @param eventName The name of the event to trigger\n         * @param eventArgs Optional event arguments to pass to the handlers\n         * @returns True if any handler called preventDefault(), false otherwise\n         */\n        trigger(eventName, eventArgs) {\n            let events = this._events[eventName];\n            if (events) {\n                const e = eventArgs || {};\n                e.sender = this;\n                e._defaultPrevented = false;\n                e.preventDefault = preventDefault$2;\n                e.isDefaultPrevented = isDefaultPrevented;\n                events = events.slice();\n                for (let idx = 0, length = events.length; idx < length; idx++) {\n                    events[idx].call(this, e);\n                }\n                return e._defaultPrevented === true;\n            }\n            return false;\n        }\n        /**\n         * Removes event handlers from events.\n         * @param eventName The event name to unbind from. If undefined, all events are unbound\n         * @param handler The specific handler to remove. If undefined, all handlers for the event are removed\n         * @returns The Observable instance for method chaining\n         */\n        unbind(eventName, handler) {\n            const events = this._events[eventName];\n            if (eventName === undefined) {\n                this._events = {};\n            }\n            else if (events) {\n                if (handler) {\n                    for (let idx = events.length - 1; idx >= 0; idx--) {\n                        if (events[idx] === handler || events[idx].original === handler) {\n                            events.splice(idx, 1);\n                        }\n                    }\n                }\n                else {\n                    this._events[eventName] = [];\n                }\n            }\n            return this;\n        }\n        /** @hidden */\n        _setEvents(options) {\n            const length = (this.events || []).length;\n            for (let idx = 0; idx < length; idx++) {\n                const name = this.events[idx];\n                if (this.options[name] && options[name]) {\n                    this.unbind(name, this.options[name]);\n                    if (this._events && this._events[name]) {\n                        delete this._events[name];\n                    }\n                }\n            }\n            this.bind(this.events, options);\n        }\n    }\n\n    var Utils$1 = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        DFT: DFT,\n        Observable: Observable,\n        addRange: addRange,\n        all: all,\n        bisort: bisort,\n        clear: clear,\n        contains: contains,\n        defined: defined,\n        deserializePoints: deserializePoints,\n        find: find,\n        findAngle: findAngle,\n        findRadian: findRadian,\n        first: first,\n        fold: fold,\n        forEach: forEach,\n        getAny: getAny,\n        getMatrixAngle: getMatrixAngle,\n        getMatrixScaling: getMatrixScaling,\n        grep: grep$1,\n        has: has,\n        inArray: inArray,\n        indexOf: indexOf,\n        initArray: initArray,\n        insert: insert,\n        isBoolean: isBoolean,\n        isDefined: isDefined,\n        isEmpty: isEmpty,\n        isFunction: isFunction$1,\n        isNearZero: isNearZero,\n        isNumber: isNumber,\n        isObject: isObject,\n        isString: isString$1,\n        isType: isType,\n        isUndefined: isUndefined,\n        noop: noop$1,\n        randomInteger: randomInteger,\n        remove: remove,\n        serializePoints: serializePoints,\n        sign: sign,\n        simpleExtend: simpleExtend\n    });\n\n    /**\n     * The Range defines an array of equally separated numbers.\n     *\n     * @param start The start-value of the Range.\n     * @param stop The end-value of the Range.\n     * @param step The separation between the values (default:1).\n     * @returns {Array}\n     */\n    function Range(start, stop, step) {\n        if (typeof start == 'undefined' || typeof stop == 'undefined') {\n            return [];\n        }\n        if (step && sign(stop - start) !== sign(step)) {\n            throw new Error('The sign of the increment should allow to reach the stop-value.');\n        }\n        step = step || 1;\n        start = start || 0;\n        stop = stop || start;\n        if ((stop - start) / step === Infinity) {\n            throw new Error('Infinite range defined.');\n        }\n        const range = [];\n        let i = -1, j;\n        function rangeIntegerScale(x) {\n            let curK = 1;\n            while (x * curK % 1) {\n                curK *= 10;\n            }\n            return curK;\n        }\n        const k = rangeIntegerScale(Math.abs(step));\n        start *= k;\n        stop *= k;\n        step *= k;\n        if (start > stop && step > 0) {\n            step = -step;\n        }\n        if (step < 0) {\n            while ((j = start + step * ++i) >= stop) {\n                range.push(j / k);\n            }\n        }\n        else {\n            while ((j = start + step * ++i) <= stop) {\n                range.push(j / k);\n            }\n        }\n        return range;\n    }\n    ;\n\n    const Easing = {\n        easeInOut(pos) {\n            return ((-Math.cos(pos * Math.PI) / 2) + 0.5);\n        }\n    };\n    /**\n     * An animation ticker driving an adapter which sets a particular\n     * property in function of the tick.\n     *\n     * @type {*}\n     */\n    class Ticker {\n        constructor() {\n            this.adapters = [];\n            this.target = 0;\n            this.tick = 0;\n            this.interval = 20;\n            this.duration = 800;\n            this.lastTime = null;\n            this.handlers = [];\n            this.timerDelegate = () => { };\n            this.intervalId = null;\n            this.caller = null;\n            this.timerDelegate = () => {\n                this.onTimerEvent();\n            };\n        }\n        ;\n        addAdapter(a) {\n            this.adapters.push(a);\n        }\n        ;\n        onComplete(handler) {\n            this.handlers.push(handler);\n        }\n        ;\n        removeHandler(handler) {\n            this.handlers = this.handlers.filter((h) => {\n                return h !== handler;\n            });\n        }\n        ;\n        trigger() {\n            if (this.handlers) {\n                forEach(this.handlers, (h) => {\n                    return h.call(this.caller !== null ? this.caller : this);\n                });\n            }\n        }\n        ;\n        onStep() {\n        }\n        ;\n        seekTo(to) {\n            this.seekFromTo(this.tick, to);\n        }\n        ;\n        seekFromTo(from, to) {\n            this.target = Math.max(0, Math.min(1, to));\n            this.tick = Math.max(0, Math.min(1, from));\n            this.lastTime = new Date().getTime();\n            if (!this.intervalId) {\n                this.intervalId = window.setInterval(this.timerDelegate, this.interval);\n            }\n        }\n        ;\n        stop() {\n            if (this.intervalId) {\n                window.clearInterval(this.intervalId);\n                this.intervalId = null;\n                // this.trigger.call(this);\n                this.trigger();\n                // this.next();\n            }\n        }\n        ;\n        play(origin) {\n            if (this.adapters.length === 0) {\n                return;\n            }\n            if (origin !== null) {\n                this.caller = origin;\n            }\n            this.initState();\n            this.seekFromTo(0, 1);\n        }\n        ;\n        reverse() {\n            this.seekFromTo(1, 0);\n        }\n        ;\n        initState() {\n            if (this.adapters.length === 0) {\n                return;\n            }\n            for (let i = 0; i < this.adapters.length; i++) {\n                this.adapters[i].initState();\n            }\n        }\n        ;\n        propagate() {\n            const value = Easing.easeInOut(this.tick);\n            for (let i = 0; i < this.adapters.length; i++) {\n                this.adapters[i].update(value);\n            }\n        }\n        ;\n        onTimerEvent() {\n            const now = new Date().getTime();\n            const timePassed = now - this.lastTime;\n            this.lastTime = now;\n            const movement = (timePassed / this.duration) * (this.tick < this.target ? 1 : -1);\n            if (Math.abs(movement) >= Math.abs(this.tick - this.target)) {\n                this.tick = this.target;\n            }\n            else {\n                this.tick += movement;\n            }\n            try {\n                this.propagate();\n            }\n            finally {\n                this.onStep.call(this);\n                if (this.target === this.tick) {\n                    this.stop();\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns a random identifier which can be used as an ID of objects, eventually augmented with a prefix.\n     *\n     * @returns {string}\n     */\n    function randomId(length) {\n        if (isUndefined(length)) {\n            length = 10;\n        }\n        // old version return Math.floor((1 + Math.random()) * 0x1000000).toString(16).substring(1);\n        let result = '';\n        const chars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n        for (let i = length; i > 0; --i) {\n            result += chars.charAt(Math.round(Math.random() * (chars.length - 1)));\n        }\n        return result;\n    }\n\n    /**\n     * Represents a collection of key-value pairs that are organized based on the hash code of the key.\n     * _buckets[hashId] = {key: key, value:...}\n     * Important: do not use the standard Array access method, use the get/set methods instead.\n     * See http://en.wikipedia.org/wiki/Hash_table\n     */\n    class HashTable {\n        constructor() {\n            this._buckets = {};\n            this.length = 0;\n            this._stringsMap = new Map();\n            this._stringsCounter = 0;\n        }\n        /**\n         * Adds the literal object with the given key (of the form {key: key,....}).\n         */\n        add(key, value) {\n            const obj = this._createGetBucket(key);\n            if (isDefined(value)) {\n                obj.value = value;\n            }\n            return obj;\n        }\n        /**\n         * Gets the literal object with the given key.\n         */\n        get(key) {\n            if (this._bucketExists(key)) {\n                return this._createGetBucket(key);\n            }\n            return null;\n        }\n        /**\n         * Set the key-value pair.\n         *\n         * @param key The key of the entry.\n         * @param value The value to set. If the key already exists the value will be overwritten.\n         */\n        set(key, value) {\n            this.add(key, value);\n        }\n        /**\n         * Determines whether the HashTable contains a specific key.\n         */\n        containsKey(key) {\n            return this._bucketExists(key);\n        }\n        /**\n         * Removes the element with the specified key from the hashtable.\n         * Returns the removed bucket.\n         */\n        remove(key) {\n            if (this._bucketExists(key)) {\n                const hashId = this._hash(key);\n                delete this._buckets[hashId];\n                this.length--;\n                return key;\n            }\n        }\n        /**\n         * Foreach with an iterator working on the key-value pairs.\n         *\n         * @param func\n         */\n        forEach(func) {\n            const hashes = this._hashes();\n            for (let i = 0, len = hashes.length; i < len; i++) {\n                const hash = hashes[i];\n                const bucket = this._buckets[hash];\n                if (isUndefined(bucket)) {\n                    continue;\n                }\n                func(bucket);\n            }\n        }\n        /**\n         * Returns a (shallow) clone of the current HashTable.\n         *\n         * @returns {HashTable}\n         */\n        clone() {\n            const ht = new HashTable();\n            const hashes = this._hashes();\n            for (let i = 0, len = hashes.length; i < len; i++) {\n                const hash = hashes[i];\n                const bucket = this._buckets[hash];\n                if (isUndefined(bucket)) {\n                    continue;\n                }\n                ht.add(bucket.key, bucket.value);\n            }\n            return ht;\n        }\n        /**\n         * Returns the hashes of the buckets.\n         *\n         * @returns {Array}\n         * @private\n         */\n        _hashes() {\n            const hashes = [];\n            for (const hash in this._buckets) {\n                if (Object.prototype.hasOwnProperty.call(this._buckets, hash)) {\n                    hashes.push(hash);\n                }\n            }\n            return hashes;\n        }\n        _bucketExists(key) {\n            const hashId = this._hash(key);\n            return isDefined(this._buckets[hashId]);\n        }\n        /**\n         * Returns-adds the createGetBucket with the given key. If not present it will\n         * be created and returned.\n         * A createGetBucket is a literal object of the form {key: key, ...}.\n         */\n        _createGetBucket(key) {\n            const hashId = this._hash(key);\n            let bucket = this._buckets[hashId];\n            if (isUndefined(bucket)) {\n                bucket = { key: key };\n                this._buckets[hashId] = bucket;\n                this.length++;\n            }\n            return bucket;\n        }\n        /**\n         * Hashing of the given key.\n         */\n        _hash(key) {\n            if (isString$1(key) || isNumber(key)) {\n                return this._hashString(String(key));\n            }\n            if (isObject(key)) {\n                return this._objectHashId(key);\n            }\n            throw new Error('Unsupported key type.');\n        }\n        /**\n         * Hashing of a string.\n         */\n        _hashString(s) {\n            let result = 0;\n            if (s.length === 0) {\n                return result;\n            }\n            if (this._stringsMap.has(s)) {\n                return this._stringsMap.get(s);\n            }\n            this._stringsCounter++;\n            this._stringsMap.set(s, this._stringsCounter);\n            result = this._stringsCounter;\n            return result;\n        }\n        /**\n         * Returns the unique identifier for an object. This is automatically assigned and add on the object.\n         */\n        _objectHashId(key) {\n            let id = key._hashId;\n            if (isUndefined(id)) {\n                id = randomId();\n                key._hashId = id;\n            }\n            return id;\n        }\n    }\n\n    /**\n     * Represents a collection of key-value pairs.\n     * Important: do not use the standard Array access method, use the get/Set methods instead.\n     */\n    class Dictionary extends Observable {\n        /**\n         * Initializes a new instance of the Dictionary class.\n         *\n         * @param dictionary Loads the content of the given dictionary into this new one.\n         */\n        constructor(dictionary) {\n            super();\n            this._hashTable = new HashTable();\n            this.length = 0;\n            if (isDefined(dictionary)) {\n                if (Array.isArray(dictionary)) {\n                    for (let i = 0; i < dictionary.length; i++) {\n                        this.add(dictionary[i]);\n                    }\n                }\n                else {\n                    dictionary.forEach(function (k, v) {\n                        this.add(k, v);\n                    }, this);\n                }\n            }\n        }\n        /**\n         * Adds a key-value to the dictionary.\n         * If the key already exists this will assign the given value to the existing entry.\n         */\n        add(key, value) {\n            let entry = this._hashTable.get(key);\n            if (!entry) {\n                entry = this._hashTable.add(key);\n                this.length++;\n                this.trigger('changed');\n            }\n            entry.value = value;\n        }\n        /**\n         * Set the key-value pair.\n         *\n         * @param key The key of the entry.\n         * @param value The value to set. If the key already exists the value will be overwritten.\n         */\n        set(key, value) {\n            this.add(key, value);\n        }\n        /**\n         * Gets the value associated with the given key in the dictionary.\n         */\n        get(key) {\n            const entry = this._hashTable.get(key);\n            if (entry) {\n                return entry.value;\n            }\n            throw new Error('Cannot find key ' + key);\n        }\n        /**\n         * Returns whether the dictionary contains the given key.\n         */\n        containsKey(key) {\n            return this._hashTable.containsKey(key);\n        }\n        /**\n         * Removes the element with the specified key from the dictionary.\n         */\n        remove(key) {\n            if (this.containsKey(key)) {\n                this.trigger('changed');\n                this.length--;\n                return this._hashTable.remove(key);\n            }\n        }\n        /**\n         * The functional gets the key and value as parameters.\n         */\n        forEach(func, thisRef) {\n            this._hashTable.forEach(function (entry) {\n                func.call(thisRef, entry.key, entry.value);\n            });\n        }\n        /**\n         * Same as forEach except that only the value is passed to the functional.\n         */\n        forEachValue(func, thisRef) {\n            this._hashTable.forEach(function (entry) {\n                func.call(thisRef, entry.value);\n            });\n        }\n        /**\n         * Calls a defined callback function for each key in the dictionary.\n         */\n        forEachKey(func, thisRef) {\n            this._hashTable.forEach(function (entry) {\n                func.call(thisRef, entry.key);\n            });\n        }\n        /**\n         * Gets an array with all keys in the dictionary.\n         */\n        keys() {\n            const keys = [];\n            this.forEachKey(function (key) {\n                keys.push(key);\n            });\n            return keys;\n        }\n    }\n\n    const Geometry = {\n        /**\n         * Returns the squared distance to the line defined by the two given Points.\n         *\n         * @param p An arbitrary Point.\n         * @param a An endpoint of the line or segment.\n         * @param b The complementary endpoint of the line or segment.\n         */\n        _distanceToLineSquared: function (p, a, b) {\n            function d2(pt1, pt2) {\n                return (pt1.x - pt2.x) * (pt1.x - pt2.x) + (pt1.y - pt2.y) * (pt1.y - pt2.y);\n            }\n            if (a === b) { // returns the distance of p to a\n                return d2(p, a);\n            }\n            const vx = b.x - a.x, vy = b.y - a.y;\n            let dot = (p.x - a.x) * vx + (p.y - a.y) * vy;\n            if (dot < 0) {\n                return d2(a, p); // sits on side of a\n            }\n            dot = (b.x - p.x) * vx + (b.y - p.y) * vy;\n            if (dot < 0) {\n                return d2(b, p); // sits on side of b\n            }\n            // regular case, use crossproduct to get the sine out\n            dot = (b.x - p.x) * vy - (b.y - p.y) * vx;\n            return dot * dot / (vx * vx + vy * vy);\n        },\n        /**\n         * Returns the distance to the line defined by the two given Points.\n         *\n         * @param p An arbitrary Point.\n         * @param a An endpoint of the line or segment.\n         * @param b The complementary endpoint of the line or segment.\n         */\n        distanceToLine: function (p, a, b) {\n            return Math.sqrt(this._distanceToLineSquared(p, a, b));\n        },\n        /**\n         * Returns the distance of the given points to the polyline defined by the points.\n         *\n         * @param p An arbitrary point.\n         * @param points The points defining the polyline.\n         * @returns {Number}\n         */\n        distanceToPolyline: function (p, points) {\n            let minimum = Number.MAX_VALUE;\n            if (isUndefined(points) || points.length === 0) {\n                return Number.MAX_VALUE;\n            }\n            for (let s = 0; s < points.length - 1; s++) {\n                const p1 = points[s];\n                const p2 = points[s + 1];\n                const d = this._distanceToLineSquared(p, p1, p2);\n                if (d < minimum) {\n                    minimum = d;\n                }\n            }\n            return Math.sqrt(minimum);\n        }\n    };\n\n    class Polar {\n        constructor(r, a) {\n            this.r = r;\n            this.angle = a;\n        }\n    }\n\n    const HITTESTAREA = 3;\n    /**\n     * Represents a 2D point with x and y coordinates.\n     * Extends the Kendo Drawing geometry Point class with additional utility methods.\n     */\n    class Point extends kendo_drawing_cmn_chunk_js.P {\n        /**\n         * Creates a new Point instance.\n         * @param x The x-coordinate of the point (defaults to 0)\n         * @param y The y-coordinate of the point (defaults to 0)\n         */\n        constructor(x, y) {\n            super(x, y);\n        }\n        /**\n         * Creates a copy of this point.\n         * @returns A new Point instance with the same coordinates\n         */\n        clone() {\n            return new Point(this.x, this.y);\n        }\n        /**\n         * Adds another point to this point.\n         * @param p The point to add\n         * @returns A new Point representing the sum of the two points\n         */\n        plus(p) {\n            return new Point(this.x + p.x, this.y + p.y);\n        }\n        /**\n         * Subtracts another point from this point.\n         * @param p The point to subtract\n         * @returns A new Point representing the difference\n         */\n        minus(p) {\n            return new Point(this.x - p.x, this.y - p.y);\n        }\n        /**\n         * Creates a new point offset by the specified value in both x and y directions.\n         * @param value The offset value to subtract from both coordinates\n         * @returns A new Point offset by the specified amount\n         */\n        offset(value) {\n            return new Point(this.x - value, this.y - value);\n        }\n        /**\n         * Multiplies this point by a scalar value.\n         * @param s The scalar multiplier\n         * @returns A new Point with coordinates multiplied by the scalar\n         */\n        times(s) {\n            return new Point(this.x * s, this.y * s);\n        }\n        /**\n         * Returns a normalized version of this point (unit vector).\n         * @returns A new Point with length 1 in the same direction, or origin if length is 0\n         */\n        normalize() {\n            if (this.length() === 0) {\n                return new Point();\n            }\n            return this.times(1 / this.length());\n        }\n        /**\n         * Calculates the length (magnitude) of this point vector.\n         * @returns The distance from origin to this point\n         */\n        length() {\n            return Math.sqrt(this.x * this.x + this.y * this.y);\n        }\n        /**\n         * Returns a string representation of this point.\n         * @returns A string in the format \"(x,y)\"\n         */\n        toString() {\n            return '(' + this.x + ',' + this.y + ')';\n        }\n        /**\n         * Calculates the squared length of this point vector.\n         * More efficient than length() when only comparing distances.\n         * @returns The squared distance from origin to this point\n         */\n        lengthSquared() {\n            return (this.x * this.x + this.y * this.y);\n        }\n        /**\n         * Calculates the midpoint between two points.\n         * @param p The first point\n         * @param q The second point\n         * @returns A new Point representing the midpoint between p and q\n         */\n        middleOf(p, q) {\n            return new Point(q.x - p.x, q.y - p.y).times(0.5).plus(p);\n        }\n        /**\n         * Converts this point to polar coordinates.\n         * @param useDegrees Whether to return angle in degrees (true) or radians (false)\n         * @returns A Polar object with radius and angle\n         */\n        toPolar(useDegrees) {\n            let factor = 1;\n            if (useDegrees) {\n                factor = 180 / Math.PI;\n            }\n            const a = Math.atan2(Math.abs(this.y), Math.abs(this.x));\n            const halfpi = Math.PI / 2;\n            const len = this.length();\n            if (this.x === 0) {\n                // note that the angle goes down and not the usual mathematical convention\n                if (this.y === 0) {\n                    return new Polar(0, 0);\n                }\n                if (this.y > 0) {\n                    return new Polar(len, factor * halfpi);\n                }\n                if (this.y < 0) {\n                    return new Polar(len, factor * 3 * halfpi);\n                }\n            }\n            else if (this.x > 0) {\n                if (this.y === 0) {\n                    return new Polar(len, 0);\n                }\n                if (this.y > 0) {\n                    return new Polar(len, factor * a);\n                }\n                if (this.y < 0) {\n                    return new Polar(len, factor * (4 * halfpi - a));\n                }\n            }\n            else {\n                if (this.y === 0) {\n                    return new Polar(len, 2 * halfpi);\n                }\n                if (this.y > 0) {\n                    return new Polar(len, factor * (2 * halfpi - a));\n                }\n                if (this.y < 0) {\n                    return new Polar(len, factor * (2 * halfpi + a));\n                }\n            }\n        }\n        /**\n         * Determines if this point lies on the line segment between two other points.\n         * @param from The starting point of the line segment\n         * @param to The ending point of the line segment\n         * @returns True if this point is on the line segment, false otherwise\n         */\n        isOnLine(from, to) {\n            if (from.x > to.x) { // from must be the leftmost point\n                const temp = to;\n                to = from;\n                from = temp;\n            }\n            const r1 = new Rect(from.x, from.y).inflate(HITTESTAREA, HITTESTAREA), r2 = new Rect(to.x, to.y).inflate(HITTESTAREA, HITTESTAREA);\n            let o1, u1;\n            if (r1.union(r2).contains(this)) {\n                if (from.x === to.x || from.y === to.y) {\n                    return true;\n                }\n                else if (from.y < to.y) {\n                    o1 = r1.x + (((r2.x - r1.x) * (this.y - (r1.y + r1.height))) / ((r2.y + r2.height) - (r1.y + r1.height)));\n                    u1 = (r1.x + r1.width) + ((((r2.x + r2.width) - (r1.x + r1.width)) * (this.y - r1.y)) / (r2.y - r1.y));\n                }\n                else {\n                    o1 = r1.x + (((r2.x - r1.x) * (this.y - r1.y)) / (r2.y - r1.y));\n                    u1 = (r1.x + r1.width) + ((((r2.x + r2.width) - (r1.x + r1.width)) * (this.y - (r1.y + r1.height))) / ((r2.y + r2.height) - (r1.y + r1.height)));\n                }\n                return (this.x > o1 && this.x < u1);\n            }\n            return false;\n        }\n        /**\n         * Parses a point from a string representation.\n         * @param str The string to parse, expected format: \"(x,y)\"\n         * @returns A new Point if parsing succeeds, undefined otherwise\n         */\n        parse(str) {\n            const tempStr = str.slice(1, str.length - 1), xy = tempStr.split(','), x = parseInt(xy[0], 10), y = parseInt(xy[1], 10);\n            if (!isNaN(x) && !isNaN(y)) {\n                return new Point(x, y);\n            }\n        }\n    }\n    /**\n     * Represents a rectangle with position and dimensions.\n     * Provides methods for geometric operations and transformations.\n     */\n    class Rect {\n        /**\n         * Creates a new Rect instance.\n         * @param x The x-coordinate of the top-left corner (defaults to 0)\n         * @param y The y-coordinate of the top-left corner (defaults to 0)\n         * @param width The width of the rectangle (defaults to 0)\n         * @param height The height of the rectangle (defaults to 0)\n         */\n        constructor(x, y, width, height) {\n            this.x = x || 0;\n            this.y = y || 0;\n            this.width = width || 0;\n            this.height = height || 0;\n        }\n        /**\n         * Determines if a point is contained within this rectangle.\n         * @param point The point to test\n         * @returns True if the point is inside the rectangle, false otherwise\n         */\n        contains(point) {\n            return ((point.x >= this.x) && (point.x <= (this.x + this.width)) && (point.y >= this.y) && (point.y <= (this.y + this.height)));\n        }\n        /**\n         * Inflates the rectangle by the specified amounts.\n         * @param dx The amount to inflate horizontally\n         * @param dy The amount to inflate vertically (defaults to dx if not provided)\n         * @returns This rectangle instance for chaining\n         */\n        inflate(dx, dy) {\n            if (dy === undefined) {\n                dy = dx;\n            }\n            this.x -= dx;\n            this.y -= dy;\n            this.width += 2 * dx + 1;\n            this.height += 2 * dy + 1;\n            return this;\n        }\n        /**\n         * Moves the rectangle by the specified offset.\n         * @param dx The horizontal offset (or a Point object)\n         * @param dy The vertical offset (ignored if dx is a Point)\n         * @returns This rectangle instance for chaining\n         */\n        offset(dx, dy) {\n            let x = dx, y = dy;\n            if (dx instanceof Point) {\n                x = dx.x;\n                y = dx.y;\n            }\n            this.x += x;\n            this.y += y;\n            return this;\n        }\n        /**\n         * Creates a new rectangle that is the union of this rectangle and another.\n         * @param r The rectangle to union with\n         * @returns A new Rect representing the union of both rectangles\n         */\n        union(r) {\n            const x1 = Math.min(this.x, r.x);\n            const y1 = Math.min(this.y, r.y);\n            const x2 = Math.max((this.x + this.width), (r.x + r.width));\n            const y2 = Math.max((this.y + this.height), (r.y + r.height));\n            return new Rect(x1, y1, x2 - x1, y2 - y1);\n        }\n        /**\n         * Gets the center point of the rectangle.\n         * @returns A Point representing the center of the rectangle\n         */\n        center() {\n            return new Point(this.x + this.width / 2, this.y + this.height / 2);\n        }\n        /**\n         * Gets the top center point of the rectangle.\n         * @returns A Point at the top center edge\n         */\n        top() {\n            return new Point(this.x + this.width / 2, this.y);\n        }\n        /**\n         * Gets the right center point of the rectangle.\n         * @returns A Point at the right center edge\n         */\n        right() {\n            return new Point(this.x + this.width, this.y + this.height / 2);\n        }\n        /**\n         * Gets the bottom center point of the rectangle.\n         * @returns A Point at the bottom center edge\n         */\n        bottom() {\n            return new Point(this.x + this.width / 2, this.y + this.height);\n        }\n        /**\n         * Gets the left center point of the rectangle.\n         * @returns A Point at the left center edge\n         */\n        left() {\n            return new Point(this.x, this.y + this.height / 2);\n        }\n        /**\n         * Gets the top-left corner point of the rectangle.\n         * @returns A Point at the top-left corner\n         */\n        topLeft() {\n            return new Point(this.x, this.y);\n        }\n        /**\n         * Gets the top-right corner point of the rectangle.\n         * @returns A Point at the top-right corner\n         */\n        topRight() {\n            return new Point(this.x + this.width, this.y);\n        }\n        /**\n         * Gets the bottom-left corner point of the rectangle.\n         * @returns A Point at the bottom-left corner\n         */\n        bottomLeft() {\n            return new Point(this.x, this.y + this.height);\n        }\n        /**\n         * Gets the bottom-right corner point of the rectangle.\n         * @returns A Point at the bottom-right corner\n         */\n        bottomRight() {\n            return new Point(this.x + this.width, this.y + this.height);\n        }\n        /**\n         * Creates a copy of this rectangle.\n         * @returns A new Rect with the same position and dimensions\n         */\n        clone() {\n            return new Rect(this.x, this.y, this.width, this.height);\n        }\n        /**\n         * Determines if this rectangle is empty (zero width and height).\n         * @returns True if the rectangle has no area, false otherwise\n         */\n        isEmpty() {\n            return !this.width && !this.height;\n        }\n        /**\n         * Determines if this rectangle is equal to another rectangle.\n         * @param rect The rectangle to compare with\n         * @returns True if both rectangles have the same position and dimensions\n         */\n        equals(rect) {\n            return this.x === rect.x && this.y === rect.y && this.width === rect.width && this.height === rect.height;\n        }\n        /**\n         * Calculates the bounding rectangle after rotating this rectangle by a given angle.\n         * @param angle The rotation angle in radians\n         * @returns A new Rect representing the axis-aligned bounding box of the rotated rectangle\n         */\n        rotatedBounds(angle) {\n            const rect = this.clone(), points = this.rotatedPoints(angle), tl = points[0], tr = points[1], br = points[2], bl = points[3];\n            rect.x = Math.min(br.x, tl.x, tr.x, bl.x);\n            rect.y = Math.min(br.y, tl.y, tr.y, bl.y);\n            rect.width = Math.max(br.x, tl.x, tr.x, bl.x) - rect.x;\n            rect.height = Math.max(br.y, tl.y, tr.y, bl.y) - rect.y;\n            return rect;\n        }\n        /**\n         * Gets the four corner points of this rectangle after rotation.\n         * @param angle The rotation angle in radians\n         * @returns An array of four Points representing the rotated corners [topLeft, topRight, bottomRight, bottomLeft]\n         */\n        rotatedPoints(angle) {\n            const c = this.center(), br = this.bottomRight().rotate(angle, c), tl = this.topLeft().rotate(angle, c), tr = this.topRight().rotate(angle, c), bl = this.bottomLeft().rotate(angle, c);\n            return [tl, tr, br, bl];\n        }\n        /**\n         * Returns a string representation of this rectangle.\n         * @param delimiter The delimiter to use between values (defaults to space)\n         * @returns A string in the format \"x y width height\" (or with custom delimiter)\n         */\n        toString(delimiter) {\n            delimiter = delimiter || ' ';\n            return this.x + delimiter + this.y + delimiter + this.width + delimiter + this.height;\n        }\n        /**\n         * Scales this rectangle while maintaining a static reference point.\n         * @param scaleX The horizontal scale factor\n         * @param scaleY The vertical scale factor\n         * @param staicPoint The static point that should remain fixed during scaling\n         * @param adornerCenter The center point of the adorner\n         * @param angle The rotation angle to apply during scaling\n         */\n        scale(scaleX, scaleY, staicPoint, adornerCenter, angle) {\n            let tl = this.topLeft();\n            const thisCenter = this.center();\n            tl.rotate(angle, thisCenter).rotate(angle, adornerCenter);\n            const delta = staicPoint.minus(tl);\n            const scaled = new Point(delta.x * scaleX, delta.y * scaleY);\n            const position = delta.minus(scaled);\n            tl = tl.plus(position);\n            tl.rotate(angle, adornerCenter).rotate(angle, thisCenter);\n            this.x = tl.x;\n            this.y = tl.y;\n            this.width *= scaleX;\n            this.height *= scaleY;\n        }\n        /**\n         * Scales this rectangle by a zoom factor.\n         * @param zoom The zoom factor to apply\n         * @returns This rectangle instance for chaining\n         */\n        zoom(zoom) {\n            this.x *= zoom;\n            this.y *= zoom;\n            this.width *= zoom;\n            this.height *= zoom;\n            return this;\n        }\n        /**\n         * Determines if this rectangle overlaps with another rectangle.\n         * @param rect The rectangle to check for overlap\n         * @returns True if the rectangles overlap, false otherwise\n         */\n        overlaps(rect) {\n            const bottomRight = this.bottomRight();\n            const rectBottomRight = rect.bottomRight();\n            const overlaps = !(bottomRight.x < rect.x || bottomRight.y < rect.y ||\n                rectBottomRight.x < this.x || rectBottomRight.y < this.y);\n            return overlaps;\n        }\n        /**\n         * Converts an object to a Rect instance.\n         * @param rect The object to convert (if not already a Rect)\n         * @returns A Rect instance\n         */\n        static toRect(rect) {\n            if (!(rect instanceof Rect)) {\n                rect = new Rect(rect.x, rect.y, rect.width, rect.height);\n            }\n            return rect;\n        }\n        /**\n         * Creates an empty rectangle (zero position and dimensions).\n         * @returns A new empty Rect instance\n         */\n        static empty() {\n            return new Rect(0, 0, 0, 0);\n        }\n        /**\n         * Creates a rectangle from two points.\n         * @param p The first point\n         * @param q The second point\n         * @returns A new Rect with the two points as opposite corners\n         * @throws Error if any coordinate values are NaN\n         */\n        static fromPoints(p, q) {\n            if (isNaN(p.x) || isNaN(p.y) || isNaN(q.x) || isNaN(q.y)) {\n                throw new Error('Some values are NaN.');\n            }\n            return new Rect(Math.min(p.x, q.x), Math.min(p.y, q.y), Math.abs(p.x - q.x), Math.abs(p.y - q.y));\n        }\n    }\n    /**\n     * Aligns two rectangles, where one is the container and the other is content.\n     */\n    class RectAlign {\n        constructor(container) {\n            this.container = Rect.toRect(container);\n        }\n        align(content, alignment) {\n            const alignValues = alignment.toLowerCase().split(' ');\n            for (let i = 0; i < alignValues.length; i++) {\n                content = this._singleAlign(content, alignValues[i]);\n            }\n            return content;\n        }\n        _singleAlign(content, alignment) {\n            if (isFunction$1(this[alignment])) {\n                return this[alignment](content);\n            }\n            else {\n                return content;\n            }\n        }\n        left(content) {\n            return this._align(content, this._left);\n        }\n        center(content) {\n            return this._align(content, this._center);\n        }\n        right(content) {\n            return this._align(content, this._right);\n        }\n        stretch(content) {\n            return this._align(content, this._stretch);\n        }\n        top(content) {\n            return this._align(content, this._top);\n        }\n        middle(content) {\n            return this._align(content, this._middle);\n        }\n        bottom(content) {\n            return this._align(content, this._bottom);\n        }\n        _left(container, content) {\n            content.x = container.x;\n        }\n        _center(container, content) {\n            content.x = ((container.width - content.width) / 2) || 0;\n        }\n        _right(container, content) {\n            content.x = container.width - content.width;\n        }\n        _top(container, content) {\n            content.y = container.y;\n        }\n        _middle(container, content) {\n            content.y = ((container.height - content.height) / 2) || 0;\n        }\n        _bottom(container, content) {\n            content.y = container.height - content.height;\n        }\n        _stretch(container, content) {\n            content.x = 0;\n            content.y = 0;\n            content.height = container.height;\n            content.width = container.width;\n        }\n        _align(content, alignCalc) {\n            content = Rect.toRect(content);\n            alignCalc(this.container, content);\n            return content;\n        }\n    }\n\n    class Queue {\n        constructor() {\n            this._tail = null;\n            this._head = null;\n            this.length = 0;\n        }\n        /**\n         * Enqueues an object to the end of the queue.\n         */\n        enqueue(value) {\n            const entry = { value: value, next: null };\n            if (!this._head) {\n                this._head = entry;\n                this._tail = this._head;\n            }\n            else {\n                this._tail.next = entry;\n                this._tail = this._tail.next;\n            }\n            this.length++;\n        }\n        /**\n         * Removes and returns the object at top of the queue.\n         */\n        dequeue() {\n            if (this.length < 1) {\n                throw new Error('The queue is empty.');\n            }\n            const value = this._head.value;\n            this._head = this._head.next;\n            this.length--;\n            return value;\n        }\n        contains(item) {\n            let current = this._head;\n            while (current) {\n                if (current.value === item) {\n                    return true;\n                }\n                current = current.next;\n            }\n            return false;\n        }\n    }\n\n    const OBJECT = 'object';\n    const UNDEFINED = 'undefined';\n    const isFunction = (obj) => typeof obj === 'function';\n    function deepExtendOne(destination, source) {\n        for (const property in source) {\n            if (property === '__proto__' || property === 'constructor') {\n                continue;\n            }\n            const propValue = source[property];\n            const propType = typeof propValue;\n            let propInit;\n            if (propType === OBJECT && propValue !== null) {\n                propInit = propValue.constructor;\n            }\n            else {\n                propInit = null;\n            }\n            if (propInit && propInit !== Array) {\n                if (propValue instanceof Date) {\n                    destination[property] = new Date(propValue.getTime());\n                }\n                else if (isFunction(propValue.clone)) {\n                    destination[property] = propValue.clone();\n                }\n                else {\n                    const destProp = destination[property];\n                    if (typeof (destProp) === OBJECT) {\n                        destination[property] = destProp || {};\n                    }\n                    else {\n                        destination[property] = {};\n                    }\n                    deepExtendOne(destination[property], propValue);\n                }\n            }\n            else if (propType !== UNDEFINED) {\n                destination[property] = propValue;\n            }\n        }\n        return destination;\n    }\n    function deepExtend(destination, ...sources) {\n        const length = sources.length;\n        for (let i = 0; i < length; i++) {\n            deepExtendOne(destination, sources[i]);\n        }\n        return destination;\n    }\n\n    const LayoutDefaultOptions = {\n        type: 'Tree',\n        subtype: 'Down',\n        roots: null,\n        animate: false,\n        // -------------------------------------------------------------------\n        /**\n         * Force-directed option: whether the motion of the nodes should be limited by the boundaries of the diagram surface.\n         */\n        limitToView: false,\n        /**\n         * Force-directed option: the amount of friction applied to the motion of the nodes.\n         */\n        friction: 0.9,\n        /**\n         * Force-directed option: the optimal distance between nodes (minimum energy).\n         */\n        nodeDistance: 50,\n        /**\n         * Force-directed option: the number of time things are being calculated.\n         */\n        iterations: 300,\n        // -------------------------------------------------------------------\n        /**\n         * Tree option: the separation in one direction (depends on the subtype what direction this is).\n         */\n        horizontalSeparation: 90,\n        /**\n         * Tree option: the separation in the complementary direction (depends on the subtype what direction this is).\n         */\n        verticalSeparation: 50,\n        // -------------------------------------------------------------------\n        /**\n         * Tip-over tree option: children-to-parent vertical distance.\n         */\n        underneathVerticalTopOffset: 15,\n        /**\n         * Tip-over tree option: children-to-parent horizontal distance.\n         */\n        underneathHorizontalOffset: 15,\n        /**\n         * Tip-over tree option: leaf-to-next-branch vertical distance.\n         */\n        underneathVerticalSeparation: 15,\n        // -------------------------------------------------------------------\n        /**\n         * Settings object to organize the different components of the diagram in a grid layout structure\n         */\n        grid: {\n            /**\n             * The width of the grid in which components are arranged. Beyond this width a component will be on the next row.\n             */\n            width: 1500,\n            /**\n             * The left offset of the grid.\n             */\n            offsetX: 50,\n            /**\n             * The top offset of the grid.\n             */\n            offsetY: 50,\n            /**\n             * The horizontal padding within a cell of the grid where a single component resides.\n             */\n            componentSpacingX: 20,\n            /**\n             * The vertical padding within a cell of the grid where a single component resides.\n             */\n            componentSpacingY: 20\n        },\n        // -------------------------------------------------------------------\n        /**\n         * Layered option: the separation height/width between the layers.\n         */\n        layerSeparation: 50,\n        /**\n         * Layered option: how many rounds of shifting and fine-tuning.\n         */\n        layeredIterations: 2,\n        /**\n         * Tree-radial option: the angle at which the layout starts.\n         */\n        startRadialAngle: 0,\n        /**\n         * Tree-radial option: the angle at which the layout starts.\n         */\n        endRadialAngle: 360,\n        /**\n         * Tree-radial option: the separation between levels.\n         */\n        radialSeparation: 150,\n        /**\n         * Tree-radial option: the separation between the root and the first level.\n         */\n        radialFirstLevelSeparation: 200,\n        /**\n         * Tree-radial option: whether a virtual roots bing the components in one radial layout.\n         */\n        keepComponentsInOneRadialLayout: false,\n        // -------------------------------------------------------------------\n        // TODO: ensure to change this to false when containers are around\n        ignoreContainers: true,\n        layoutContainerChildren: false,\n        ignoreInvisible: true,\n        animateTransitions: false\n    };\n    /**\n     * Base class for layout algorithms.\n     *\n     * @type {*}\n     */\n    class LayoutBase {\n        constructor() {\n            this.defaultOptions = { ...LayoutDefaultOptions, grid: { ...LayoutDefaultOptions.grid } };\n        }\n        /**\n         * Organizes the components in a grid.\n         * Returns the final set of nodes (not the Graph).\n         *\n         * @param components\n         */\n        gridLayoutComponents(components) {\n            if (!components) {\n                throw new Error('No components supplied.');\n            }\n            // calculate and cache the bounds of the components\n            forEach(components, function (c) {\n                c.calcBounds();\n            });\n            // order by decreasing width\n            components.sort(function (a, b) {\n                return b.bounds.width - a.bounds.width;\n            });\n            const maxWidth = this.options.grid.width, offsetX = this.options.grid.componentSpacingX, offsetY = this.options.grid.componentSpacingY, startX = this.options.grid.offsetX, startY = this.options.grid.offsetY, resultLinkSet = [], resultNodeSet = [];\n            let height = 0, x = startX, y = startY;\n            while (components.length > 0) {\n                if (x >= maxWidth) {\n                    // start a new row\n                    x = startX;\n                    y += height + offsetY;\n                    // reset the row height\n                    height = 0;\n                }\n                const component = components.pop();\n                this.moveToOffset(component, new Point(x, y));\n                for (let i = 0; i < component.nodes.length; i++) {\n                    resultNodeSet.push(component.nodes[i]); // to be returned in the end\n                }\n                for (let i = 0; i < component.links.length; i++) {\n                    resultLinkSet.push(component.links[i]);\n                }\n                const boundingRect = component.bounds;\n                let currentHeight = boundingRect.height;\n                if (currentHeight <= 0 || isNaN(currentHeight)) {\n                    currentHeight = 0;\n                }\n                let currentWidth = boundingRect.width;\n                if (currentWidth <= 0 || isNaN(currentWidth)) {\n                    currentWidth = 0;\n                }\n                if (currentHeight >= height) {\n                    height = currentHeight;\n                }\n                x += currentWidth + offsetX;\n            }\n            return {\n                nodes: resultNodeSet,\n                links: resultLinkSet\n            };\n        }\n        moveToOffset(component, p) {\n            let i, j;\n            const bounds = component.bounds, deltaX = p.x - bounds.x, deltaY = p.y - bounds.y;\n            for (i = 0; i < component.nodes.length; i++) {\n                const node = component.nodes[i];\n                let nodeBounds = node.bounds();\n                if (nodeBounds.width === 0 && nodeBounds.height === 0 && nodeBounds.x === 0 && nodeBounds.y === 0) {\n                    nodeBounds = new Rect(0, 0, 0, 0);\n                }\n                nodeBounds.x += deltaX;\n                nodeBounds.y += deltaY;\n                node.bounds(nodeBounds);\n            }\n            for (i = 0; i < component.links.length; i++) {\n                const link = component.links[i];\n                if (link.points) {\n                    const newPoints = [];\n                    const points = link.points;\n                    for (j = 0; j < points.length; j++) {\n                        const pt = points[j];\n                        pt.x += deltaX;\n                        pt.y += deltaY;\n                        newPoints.push(pt);\n                    }\n                    link.points = newPoints;\n                }\n            }\n            this.currentHorizontalOffset += bounds.width + this.options.grid.offsetX;\n            return new Point(deltaX, deltaY);\n        }\n        transferOptions(options) {\n            // Size options lead to stackoverflow and need special handling\n            this.options = deepExtend({}, this.defaultOptions);\n            if (isUndefined(options)) {\n                return;\n            }\n            this.options = deepExtend(this.options, options || {});\n        }\n    }\n\n    /**\n     * Captures the state of a diagram; node positions, link points and so on.\n     *\n     * @type {*}\n     */\n    class LayoutState {\n        constructor(diagram, graphOrNodes) {\n            if (isUndefined(diagram)) {\n                throw new Error('No diagram given');\n            }\n            this.diagram = diagram;\n            this.nodeMap = new Dictionary();\n            this.linkMap = new Dictionary();\n            this.capture(graphOrNodes ? graphOrNodes : diagram);\n        }\n        /**\n         * Will capture either\n         * - the state of the shapes and the intermediate points of the connections in the diagram\n         * - the bounds of the nodes contained in the Graph together with the intermediate points of the links in the Graph\n         * - the bounds of the nodes in the Array<Node>\n         * - the links points and node bounds in the literal object\n         *\n         * @param diagramOrGraphOrNodes\n         */\n        capture(diagramOrGraphOrNodes) {\n            let node, nodes, shape, i, conn, link, links;\n            if (diagramOrGraphOrNodes && diagramOrGraphOrNodes.type === 'Graph') {\n                for (i = 0; i < diagramOrGraphOrNodes.nodes.length; i++) {\n                    node = diagramOrGraphOrNodes.nodes[i];\n                    shape = node.associatedShape;\n                    // shape.bounds(new Rect(node.x, node.y, node.width, node.height));\n                    this.nodeMap.set(shape.visual.id, new Rect(node.x, node.y, node.width, node.height));\n                }\n                for (i = 0; i < diagramOrGraphOrNodes.links.length; i++) {\n                    link = diagramOrGraphOrNodes.links[i];\n                    conn = link.associatedConnection;\n                    this.linkMap.set(conn.visual.id, link.points());\n                }\n            }\n            else if (diagramOrGraphOrNodes instanceof Array) {\n                nodes = diagramOrGraphOrNodes;\n                for (i = 0; i < nodes.length; i++) {\n                    node = nodes[i];\n                    shape = node.associatedShape;\n                    if (shape) {\n                        this.nodeMap.set(shape.visual.id, new Rect(node.x, node.y, node.width, node.height));\n                    }\n                }\n            }\n            else if (Object.prototype.hasOwnProperty.call(diagramOrGraphOrNodes, 'links') && Object.prototype.hasOwnProperty.call(diagramOrGraphOrNodes, 'nodes')) {\n                nodes = diagramOrGraphOrNodes.nodes;\n                links = diagramOrGraphOrNodes.links;\n                for (i = 0; i < nodes.length; i++) {\n                    node = nodes[i];\n                    shape = node.associatedShape;\n                    if (shape) {\n                        this.nodeMap.set(shape.visual.id, new Rect(node.x, node.y, node.width, node.height));\n                    }\n                }\n                for (i = 0; i < links.length; i++) {\n                    link = links[i];\n                    conn = link.associatedConnection;\n                    if (conn) {\n                        this.linkMap.set(conn.visual.id, link.points);\n                    }\n                }\n            }\n            else { // capture the diagram\n                const shapes = this.diagram.shapes;\n                const connections = this.diagram.connections;\n                for (i = 0; i < shapes.length; i++) {\n                    shape = shapes[i];\n                    this.nodeMap.set(shape.visual.id, shape.bounds());\n                }\n                for (i = 0; i < connections.length; i++) {\n                    conn = connections[i];\n                    this.linkMap.set(conn.visual.id, conn.points());\n                }\n            }\n        }\n    }\n\n    /**\n     * Defines the node (vertex) of a Graph.\n     */\n    class Node {\n        constructor(id, shape) {\n            /**\n             * Holds all the links incident with the current node.\n             * Do not use this property to manage the incoming links, use the appropriate add/remove methods instead.\n             */\n            this.links = [];\n            /**\n             * Holds the links from the current one to another Node .\n             * Do not use this property to manage the incoming links, use the appropriate add/remove methods instead.\n             */\n            this.outgoing = [];\n            /**\n             * Holds the links from another Node to the current one.\n             * Do not use this property to manage the incoming links, use the appropriate add/remove methods instead.\n             */\n            this.incoming = [];\n            /**\n             * Holds the weight of this Node.\n             */\n            this.weight = 1;\n            /**\n             * The payload of the node.\n             *\n             * @type {null}\n             */\n            this.data = null;\n            this.type = 'Node';\n            /**\n             * Whether this is an injected node during the analysis or layout process.\n             *\n             * @type {boolean}\n             */\n            this.isVirtual = false;\n            if (isDefined(id)) {\n                this.id = id;\n            }\n            else {\n                this.id = randomId();\n            }\n            if (isDefined(shape)) {\n                this.associatedShape = shape;\n                // transfer the shape's bounds to the runtime props\n                const b = shape.bounds();\n                this.width = b.width;\n                this.height = b.height;\n                this.x = b.x;\n                this.y = b.y;\n            }\n            else {\n                this.associatedShape = null;\n            }\n            this.shortForm = 'Node \\'' + this.id + '\\'';\n        }\n        /**\n         * Returns whether this node has no links attached.\n         */\n        isIsolated() {\n            return isEmpty(this.links);\n        }\n        /**\n         * Gets or sets the bounding rectangle of this node.\n         * This should be considered as runtime data, the property is not hotlinked to a SVG item.\n         */\n        bounds(r) {\n            if (!isDefined(r)) {\n                return new Rect(this.x, this.y, this.width, this.height);\n            }\n            this.x = r.x;\n            this.y = r.y;\n            this.width = r.width;\n            this.height = r.height;\n        }\n        /**\n         * Returns whether there is at least one link with the given (complementary) node. This can be either an\n         * incoming or outgoing link.\n         */\n        isLinkedTo(node) {\n            return getAny(this.links, (link) => {\n                return link.getComplement(this) === node;\n            });\n        }\n        /**\n         * Gets the children of this node, defined as the adjacent nodes with a link from this node to the adjacent one.\n         *\n         * @returns {Array}\n         */\n        getChildren() {\n            if (this.outgoing.length === 0) {\n                return [];\n            }\n            const children = [];\n            for (let i = 0, len = this.outgoing.length; i < len; i++) {\n                const link = this.outgoing[i];\n                children.push(link.getComplement(this));\n            }\n            return children;\n        }\n        /**\n         * Gets the parents of this node, defined as the adjacent nodes with a link from the adjacent node to this one.\n         *\n         * @returns {Array}\n         */\n        getParents() {\n            if (this.incoming.length === 0) {\n                return [];\n            }\n            const parents = [];\n            for (let i = 0, len = this.incoming.length; i < len; i++) {\n                const link = this.incoming[i];\n                parents.push(link.getComplement(this));\n            }\n            return parents;\n        }\n        /**\n         * Returns a clone of the Node. Note that the identifier is not cloned since it's a different Node instance.\n         *\n         * @returns {Node}\n         */\n        clone() {\n            const copy = new Node();\n            if (isDefined(this.weight)) {\n                copy.weight = this.weight;\n            }\n            if (isDefined(this.balance)) {\n                copy.balance = this.balance;\n            }\n            if (isDefined(this.owner)) {\n                copy.owner = this.owner;\n            }\n            copy.associatedShape = this.associatedShape;\n            copy.x = this.x;\n            copy.y = this.y;\n            copy.width = this.width;\n            copy.height = this.height;\n            return copy;\n        }\n        /**\n         * Returns whether there is a link from the current node to the given node.\n         */\n        adjacentTo(node) {\n            return this.isLinkedTo(node) !== null;\n        }\n        /**\n         * Removes the given link from the link collection this node owns.\n         *\n         * @param link\n         */\n        removeLink(link) {\n            if (link.source === this) {\n                remove(this.links, link);\n                remove(this.outgoing, link);\n                link.source = null;\n            }\n            if (link.target === this) {\n                remove(this.links, link);\n                remove(this.incoming, link);\n                link.target = null;\n            }\n        }\n        /**\n         * Returns whether there is a (outgoing) link from the current node to the given one.\n         */\n        hasLinkTo(node) {\n            return getAny(this.outgoing, function (link) {\n                return link.target === node;\n            });\n        }\n        /**\n         * Returns the degree of this node, i.e. the sum of incoming and outgoing links.\n         */\n        degree() {\n            return this.links.length;\n        }\n        /**\n         * Returns whether this node is either the source or the target of the given link.\n         */\n        incidentWith(link) {\n            return contains(this.links, link);\n        }\n        /**\n         * Returns the links between this node and the given one.\n         */\n        getLinksWith(node) {\n            return all(this.links, function (link) {\n                return link.getComplement(this) === node;\n            }, this);\n        }\n        /**\n         * Returns the nodes (either parent or child) which are linked to the current one.\n         */\n        getNeighbors() {\n            const neighbors = [];\n            forEach(this.incoming, function (e) {\n                neighbors.push(e.getComplement(this));\n            }, this);\n            forEach(this.outgoing, function (e) {\n                neighbors.push(e.getComplement(this));\n            }, this);\n            return neighbors;\n        }\n    }\n    /**\n     * Defines a directed link (edge, connection) of a Graph.\n     */\n    class Link {\n        constructor(source, target, id, connection) {\n            if (isUndefined(source)) {\n                throw new Error('The source of the new link is not set.');\n            }\n            if (isUndefined(target)) {\n                throw new Error('The target of the new link is not set.');\n            }\n            let sourceFound, targetFound;\n            if (isString$1(source)) {\n                sourceFound = new Node(source);\n            }\n            else {\n                sourceFound = source;\n            }\n            if (isString$1(target)) {\n                targetFound = new Node(target);\n            }\n            else {\n                targetFound = target;\n            }\n            this.source = sourceFound;\n            this.target = targetFound;\n            this.source.links.push(this);\n            this.target.links.push(this);\n            this.source.outgoing.push(this);\n            this.target.incoming.push(this);\n            if (isDefined(id)) {\n                this.id = id;\n            }\n            else {\n                this.id = randomId();\n            }\n            if (isDefined(connection)) {\n                this.associatedConnection = connection;\n            }\n            else {\n                this.associatedConnection = null;\n            }\n            this.type = 'Link';\n            this.shortForm = 'Link \\'' + this.source.id + '->' + this.target.id + '\\'';\n        }\n        /**\n         * Returns the complementary node of the given one, if any.\n         */\n        getComplement(node) {\n            if (this.source !== node && this.target !== node) {\n                throw new Error('The given node is not incident with this link.');\n            }\n            return this.source === node ? this.target : this.source;\n        }\n        /**\n         * Returns the overlap of the current link with the given one, if any.\n         */\n        getCommonNode(link) {\n            if (this.source === link.source || this.source === link.target) {\n                return this.source;\n            }\n            if (this.target === link.source || this.target === link.target) {\n                return this.target;\n            }\n            return null;\n        }\n        /**\n         * Returns whether the current link is bridging the given nodes.\n         */\n        isBridging(v1, v2) {\n            return this.source === v1 && this.target === v2 || this.source === v2 && this.target === v1;\n        }\n        /**\n         * Returns the source and target of this link as a tuple.\n         */\n        getNodes() {\n            return [this.source, this.target];\n        }\n        /**\n         * Returns whether the given node is either the source or the target of the current link.\n         */\n        incidentWith(node) {\n            return this.source === node || this.target === node;\n        }\n        /**\n         * Returns whether the given link is a continuation of the current one. This can be both\n         * via an incoming or outgoing link.\n         */\n        adjacentTo(link) {\n            return contains(this.source.links, link) || contains(this.target.links, link);\n        }\n        /**\n         * Changes the source-node of this link.\n         */\n        changeSource(node) {\n            remove(this.source.links, this);\n            remove(this.source.outgoing, this);\n            node.links.push(this);\n            node.outgoing.push(this);\n            this.source = node;\n        }\n        /**\n         * Changes the target-node of this link.\n         *\n         * @param node\n         */\n        changeTarget(node) {\n            remove(this.target.links, this);\n            remove(this.target.incoming, this);\n            node.links.push(this);\n            node.incoming.push(this);\n            this.target = node;\n        }\n        /**\n         * Changes both the source and the target nodes of this link.\n         */\n        changesNodes(v, w) {\n            if (this.source === v) {\n                this.changeSource(w);\n            }\n            else if (this.target === v) {\n                this.changeTarget(w);\n            }\n        }\n        /**\n         * Reverses the direction of this link.\n         */\n        reverse() {\n            const oldSource = this.source;\n            const oldTarget = this.target;\n            this.source = oldTarget;\n            remove(oldSource.outgoing, this);\n            this.source.outgoing.push(this);\n            this.target = oldSource;\n            remove(oldTarget.incoming, this);\n            this.target.incoming.push(this);\n            return this;\n        }\n        /**\n         * Ensures that the given target defines the endpoint of this link.\n         */\n        directTo(target) {\n            if (this.source !== target && this.target !== target) {\n                throw new Error('The given node is not incident with this link.');\n            }\n            if (this.target !== target) {\n                this.reverse();\n            }\n        }\n        /**\n         * Returns a reversed clone of this link.\n         */\n        createReverseEdge() {\n            const r = this.clone();\n            r.reverse();\n            r.reversed = true;\n            return r;\n        }\n        /**\n         * Returns a clone of this link.\n         */\n        clone() {\n            const clone = new Link(this.source, this.target);\n            return clone;\n        }\n    }\n    /* --------------Graph structure---------------------------------*/\n    /**\n     * Defines a directed graph structure.\n     * Note that the incidence structure resides in the nodes through the incoming and outgoing links collection, rahter than\n     * inside the Graph.\n     */\n    class Graph {\n        constructor(idOrDiagram) {\n            /**\n             * The links or edge collection of this Graph.\n             *\n             * @type {Array}\n             */\n            this.links = [];\n            /**\n             * The node or vertex collection of this Graph.\n             *\n             * @type {Array}\n             */\n            this.nodes = [];\n            this._nodeMap = new Dictionary();\n            /**\n             * The optional reference to the Diagram on which this Graph is based.\n             *\n             * @type {null}\n             */\n            this.diagram = null;\n            /**\n             * The root of this Graph. If not set explicitly the first Node with zero incoming links will be taken.\n             *\n             * @type {null}\n             * @private\n             */\n            this._root = null;\n            /**\n             * The bounds of this graph if the nodes have spatial extension defined.\n             *\n             * @type {Rect}\n             */\n            this.bounds = new Rect();\n            // keeps track whether the children & parents have been created\n            this._hasCachedRelationships = false;\n            this.type = 'Graph';\n            this.componentIndex = 0;\n            if (isDefined(idOrDiagram)) {\n                if (isString$1(idOrDiagram)) {\n                    this.id = idOrDiagram;\n                }\n                else {\n                    this.diagram = idOrDiagram;\n                    this.id = idOrDiagram.id;\n                }\n            }\n            else {\n                this.id = randomId();\n            }\n        }\n        /**\n         * Caches the relational information of parents and children in the 'parents' and 'children'\n         * properties.\n         *\n         * @param forceRebuild If set to true the relational info will be rebuild even if already present.\n         */\n        cacheRelationships(forceRebuild) {\n            if (isUndefined(forceRebuild)) {\n                forceRebuild = false;\n            }\n            if (this._hasCachedRelationships && !forceRebuild) {\n                return;\n            }\n            for (let i = 0, len = this.nodes.length; i < len; i++) {\n                const node = this.nodes[i];\n                node.children = this.getChildren(node);\n                node.parents = this.getParents(node);\n            }\n            this._hasCachedRelationships = true;\n        }\n        /**\n         * Assigns tree-levels to the nodes assuming this is a tree graph.\n         * If not connected or not a tree the process will succeed but\n         * will have little meaning.\n         *\n         * @param startNode The node from where the level numbering starts, usually the root of the tree.\n         * @param visited The collection of visited nodes.\n         * @param offset The offset or starting counter of the level info.\n         */\n        assignLevels(startNode, offset, visited) {\n            if (!startNode) {\n                throw new Error('Start node not specified.');\n            }\n            if (isUndefined(offset)) {\n                offset = 0;\n            }\n            // if not done before, cache the parents and children\n            this.cacheRelationships();\n            if (isUndefined(visited)) {\n                visited = new Dictionary();\n                forEach(this.nodes, function (n) {\n                    visited.add(n, false);\n                });\n            }\n            visited.set(startNode, true);\n            startNode.level = offset;\n            const children = startNode.children;\n            for (let i = 0, len = children.length; i < len; i++) {\n                const child = children[i];\n                if (!child || visited.get(child)) {\n                    continue;\n                }\n                this.assignLevels(child, offset + 1, visited);\n            }\n        }\n        /**\n         * Gets or set the root of this graph.\n         * If not set explicitly the first Node with zero incoming links will be taken.\n         *\n         * @param value\n         * @returns {*}\n         */\n        root(value) {\n            if (isUndefined(value)) {\n                if (!this._root) {\n                    // TODO: better to use the longest path for the most probable root?\n                    const found = first(this.nodes, function (n) {\n                        return n.incoming.length === 0;\n                    });\n                    if (found) {\n                        return found;\n                    }\n                    return first(this.nodes);\n                }\n                else {\n                    return this._root;\n                }\n            }\n            else {\n                this._root = value;\n            }\n        }\n        /**\n         * Returns the connected components of this graph.\n         * Note that the returned graphs are made up of the nodes and links of this graph, i.e. a pointer to the items of this graph.\n         * If you alter the items of the components you'll alter the original graph and vice versa.\n         *\n         * @returns {Array}\n         */\n        getConnectedComponents() {\n            this.componentIndex = 0;\n            this.setItemIndices();\n            const componentId = initArray(this.nodes.length, -1);\n            for (let v = 0; v < this.nodes.length; v++) {\n                if (componentId[v] === -1) {\n                    this._collectConnectedNodes(componentId, v);\n                    this.componentIndex++;\n                }\n            }\n            const components = [];\n            let i;\n            for (i = 0; i < this.componentIndex; ++i) {\n                components[i] = new Graph();\n            }\n            for (i = 0; i < componentId.length; ++i) {\n                const graph = components[componentId[i]];\n                graph.addNodeAndOutgoings(this.nodes[i]);\n            }\n            // sorting the components in decreasing order of node count\n            components.sort(function (a, b) {\n                return b.nodes.length - a.nodes.length;\n            });\n            return components;\n        }\n        _collectConnectedNodes(setIds, nodeIndex) {\n            setIds[nodeIndex] = this.componentIndex; // part of the current component\n            const node = this.nodes[nodeIndex];\n            forEach(node.links, function (link) {\n                const next = link.getComplement(node);\n                const nextId = next.index;\n                if (setIds[nextId] === -1) {\n                    this._collectConnectedNodes(setIds, nextId);\n                }\n            }, this);\n        }\n        /**\n         * Calculates the bounds of this Graph if the Nodes have spatial dimensions defined.\n         *\n         * @returns {Rect}\n         */\n        calcBounds() {\n            if (this.isEmpty()) {\n                this.bounds = new Rect();\n                return this.bounds;\n            }\n            let b = null;\n            for (let i = 0, len = this.nodes.length; i < len; i++) {\n                const node = this.nodes[i];\n                if (!b) {\n                    b = node.bounds();\n                }\n                else {\n                    b = b.union(node.bounds());\n                }\n            }\n            this.bounds = b;\n            return this.bounds;\n        }\n        /**\n         * Creates a spanning tree for the current graph.\n         * Important: this will not return a spanning forest if the graph is disconnected.\n         * Prim's algorithm  finds a minimum-cost spanning tree of an edge-weighted, connected, undirected graph;\n         * see http://en.wikipedia.org/wiki/Prim%27s_algorithm .\n         *\n         * @param root The root of the spanning tree.\n         * @returns {Graph}\n         */\n        getSpanningTree(root) {\n            const tree = new Graph();\n            const map = new Dictionary();\n            let source, target;\n            const rootClone = root.clone();\n            tree.root(rootClone);\n            rootClone.level = 0;\n            rootClone.id = root.id;\n            map.add(root, tree.root());\n            root.level = 0;\n            const visited = [];\n            const remaining = [];\n            tree._addNode(tree.root());\n            visited.push(root);\n            remaining.push(root);\n            let levelCount = 1;\n            while (remaining.length > 0) {\n                const next = remaining.pop();\n                for (let ni = 0; ni < next.links.length; ni++) {\n                    const link = next.links[ni];\n                    const cn = link.getComplement(next);\n                    if (contains(visited, cn)) {\n                        continue;\n                    }\n                    cn.level = next.level + 1;\n                    if (levelCount < cn.level + 1) {\n                        levelCount = cn.level + 1;\n                    }\n                    if (!contains(remaining, cn)) {\n                        remaining.push(cn);\n                    }\n                    if (!contains(visited, cn)) {\n                        visited.push(cn);\n                    }\n                    if (map.containsKey(next)) {\n                        source = map.get(next);\n                    }\n                    else {\n                        source = next.clone();\n                        source.level = next.level;\n                        source.id = next.id;\n                        map.add(next, source);\n                    }\n                    if (map.containsKey(cn)) {\n                        target = map.get(cn);\n                    }\n                    else {\n                        target = cn.clone();\n                        target.level = cn.level;\n                        target.id = cn.id;\n                        map.add(cn, target);\n                    }\n                    const newLink = new Link(source, target);\n                    tree.addLink(newLink);\n                }\n            }\n            const treeLevels = [];\n            for (let i = 0; i < levelCount; i++) {\n                treeLevels.push([]);\n            }\n            forEach(tree.nodes, function (node) {\n                treeLevels[node.level].push(node);\n            });\n            tree.treeLevels = treeLevels;\n            tree.cacheRelationships();\n            return tree;\n        }\n        /**\n         * Returns a random node in this graph.\n         *\n         * @param excludedNodes The collection of nodes which should not be considered.\n         * @param incidenceLessThan The maximum degree or incidence the random node should have.\n         * @returns {*}\n         */\n        takeRandomNode(excludedNodes, incidenceLessThan) {\n            if (isUndefined(excludedNodes)) {\n                excludedNodes = [];\n            }\n            if (isUndefined(incidenceLessThan)) {\n                incidenceLessThan = 4;\n            }\n            if (this.nodes.length === 0) {\n                return null;\n            }\n            if (this.nodes.length === 1) {\n                return contains(excludedNodes, this.nodes[0]) ? null : this.nodes[0];\n            }\n            const pool = this.nodes.filter(function (node) {\n                return !contains(excludedNodes, node) && node.degree() <= incidenceLessThan;\n            });\n            if (isEmpty(pool)) {\n                return null;\n            }\n            return pool[randomInteger(0, pool.length)];\n        }\n        /**\n         * Returns whether this is an empty graph.\n         */\n        isEmpty() {\n            return isEmpty(this.nodes);\n        }\n        /**\n         * Checks whether the endpoints of the links are all in the nodes collection.\n         */\n        isHealthy() {\n            return all(this.links, function (link) {\n                return contains(this.nodes, link.source) && contains(this.nodes, link.target);\n            }, this);\n        }\n        /**\n         * Gets the parents of this node, defined as the adjacent nodes with a link from the adjacent node to this one.\n         *\n         * @returns {Array}\n         */\n        getParents(n) {\n            if (!this.hasNode(n)) {\n                throw new Error('The given node is not part of this graph.');\n            }\n            return n.getParents();\n        }\n        /**\n         * Gets the children of this node, defined as the adjacent nodes with a link from this node to the adjacent one.\n         *\n         * @returns {Array}\n         */\n        getChildren(n) {\n            if (!this.hasNode(n)) {\n                throw new Error('The given node is not part of this graph.');\n            }\n            return n.getChildren();\n        }\n        /**\n         * Adds a new link to the graph between the given nodes.\n         */\n        addLink(sourceOrLink, target, owner) {\n            if (isUndefined(sourceOrLink)) {\n                throw new Error('The source of the link is not defined.');\n            }\n            if (isUndefined(target)) {\n                // can only be undefined if the first one is a Link\n                if (isDefined(sourceOrLink.type) && sourceOrLink.type === 'Link') {\n                    this.addExistingLink(sourceOrLink);\n                    return;\n                }\n                else {\n                    throw new Error('The target of the link is not defined.');\n                }\n            }\n            let foundSource = this.getNode(sourceOrLink);\n            if (isUndefined(foundSource)) {\n                foundSource = this.addNode(sourceOrLink);\n            }\n            let foundTarget = this.getNode(target);\n            if (isUndefined(foundTarget)) {\n                foundTarget = this.addNode(target);\n            }\n            const newLink = new Link(foundSource, foundTarget);\n            if (isDefined(owner)) {\n                newLink.owner = owner;\n            }\n            /* newLink.source.outgoing.push(newLink);\n                newLink.source.links.push(newLink);\n                newLink.target.incoming.push(newLink);\n                newLink.target.links.push(newLink);*/\n            this.links.push(newLink);\n            return newLink;\n        }\n        /**\n         * Removes all the links in this graph.\n         */\n        removeAllLinks() {\n            while (this.links.length > 0) {\n                const link = this.links[0];\n                this.removeLink(link);\n            }\n        }\n        /**\n         * Adds the given link to the current graph.\n         */\n        addExistingLink(link) {\n            if (this.hasLink(link)) {\n                return;\n            }\n            this.links.push(link);\n            if (this.hasNode(link.source.id)) {\n                // priority to the existing node with the id even if other props are different\n                const s = this.getNode(link.source.id);\n                link.changeSource(s);\n            }\n            else {\n                this.addNode(link.source);\n            }\n            if (this.hasNode(link.target.id)) {\n                const t = this.getNode(link.target.id);\n                link.changeTarget(t);\n            }\n            else {\n                this.addNode(link.target);\n            }\n            /*  if (!link.source.outgoing.contains(link)) {\n                link.source.outgoing.push(link);\n                }\n                if (!link.source.links.contains(link)) {\n                link.source.links.push(link);\n                }\n                if (!link.target.incoming.contains(link)) {\n                link.target.incoming.push(link);\n                }\n                if (!link.target.links.contains(link)) {\n                link.target.links.push(link);\n                }*/\n        }\n        /**\n         * Returns whether the given identifier or Link is part of this graph.\n         *\n         * @param linkOrId An identifier or a Link object.\n         * @returns {*}\n         */\n        hasLink(linkOrId) {\n            if (isString$1(linkOrId)) {\n                return getAny(this.links, function (link) {\n                    return link.id === linkOrId;\n                });\n            }\n            if (linkOrId.type === 'Link') {\n                return contains(this.links, linkOrId);\n            }\n            throw new Error('The given object is neither an identifier nor a Link.');\n        }\n        /**\n         * Gets the node with the specified Id or null if not part of this graph.\n         */\n        getNode(nodeOrId) {\n            const id = nodeOrId.id || nodeOrId;\n            if (this._nodeMap.containsKey(id)) {\n                return this._nodeMap.get(id);\n            }\n        }\n        /**\n         * Returns whether the given node or node Id is part of this graph.\n         */\n        hasNode(nodeOrId) {\n            const id = nodeOrId.id || nodeOrId;\n            return this._nodeMap.containsKey(id);\n        }\n        _addNode(node) {\n            this.nodes.push(node);\n            this._nodeMap.add(node.id, node);\n        }\n        _removeNode(node) {\n            remove(this.nodes, node);\n            this._nodeMap.remove(node.id);\n        }\n        /**\n         * Removes the given node from this graph.\n         * The node can be specified as an object or as an identifier (string).\n         */\n        removeNode(nodeOrId) {\n            let n = nodeOrId;\n            if (isString$1(nodeOrId)) {\n                n = this.getNode(nodeOrId);\n            }\n            if (isDefined(n)) {\n                const links = n.links;\n                n.links = [];\n                for (let i = 0, len = links.length; i < len; i++) {\n                    const link = links[i];\n                    this.removeLink(link);\n                }\n                this._removeNode(n);\n            }\n            else {\n                throw new Error('The identifier should be a Node or the Id (string) of a node.');\n            }\n        }\n        /**\n         * Returns whether the given nodes are connected with a least one link independently of the direction.\n         */\n        areConnected(n1, n2) {\n            return getAny(this.links, function (link) {\n                return link.source === n1 && link.target === n2 || link.source === n2 && link.target === n1;\n            });\n        }\n        /**\n         * Removes the given link from this graph.\n         */\n        removeLink(link) {\n            /*    if (!this.links.contains(link)) {\n                throw \"The given link is not part of the Graph.\";\n                }\n                */\n            remove(this.links, link);\n            remove(link.source.outgoing, link);\n            remove(link.source.links, link);\n            remove(link.target.incoming, link);\n            remove(link.target.links, link);\n        }\n        /**\n         * Adds a new node to this graph, if not already present.\n         * The node can be an existing Node or the identifier of a new node.\n         * No error is thrown if the node is already there and the existing one is returned.\n         */\n        addNode(nodeOrId, layoutRect, owner) {\n            let newNode = null;\n            if (!isDefined(nodeOrId)) {\n                throw new Error('No Node or identifier for a new Node is given.');\n            }\n            if (isString$1(nodeOrId)) {\n                if (this.hasNode(nodeOrId)) {\n                    return this.getNode(nodeOrId);\n                }\n                newNode = new Node(nodeOrId);\n            }\n            else {\n                if (this.hasNode(nodeOrId)) {\n                    return this.getNode(nodeOrId);\n                }\n                // todo: ensure that the param is a Node?\n                newNode = nodeOrId;\n            }\n            if (isDefined(layoutRect)) {\n                newNode.bounds(layoutRect);\n            }\n            if (isDefined(owner)) {\n                newNode.owner = owner;\n            }\n            this._addNode(newNode);\n            return newNode;\n        }\n        /**\n         * Adds the given Node and its outgoing links.\n         */\n        addNodeAndOutgoings(node) {\n            if (!this.hasNode(node)) {\n                this._addNode(node);\n            }\n            const newLinks = node.outgoing;\n            node.outgoing = [];\n            forEach(newLinks, function (link) {\n                this.addExistingLink(link);\n            }, this);\n        }\n        /**\n         * Sets the 'index' property on the links and nodes of this graph.\n         */\n        setItemIndices() {\n            let i;\n            for (i = 0; i < this.nodes.length; ++i) {\n                this.nodes[i].index = i;\n            }\n            for (i = 0; i < this.links.length; ++i) {\n                this.links[i].index = i;\n            }\n        }\n        /**\n         * Returns a clone of this graph.\n         */\n        clone(saveMapping) {\n            const copy = new Graph();\n            const save = isDefined(saveMapping) && saveMapping === true;\n            if (save) {\n                copy.nodeMap = new Dictionary();\n                copy.linkMap = new Dictionary();\n            }\n            // we need a map even if the saveMapping is not set\n            const map = new Dictionary();\n            forEach(this.nodes, function (nOriginal) {\n                const nCopy = nOriginal.clone();\n                map.set(nOriginal, nCopy);\n                copy._addNode(nCopy);\n                if (save) {\n                    copy.nodeMap.set(nCopy, nOriginal);\n                }\n            });\n            forEach(this.links, function (linkOriginal) {\n                if (map.containsKey(linkOriginal.source) && map.containsKey(linkOriginal.target)) {\n                    const linkCopy = copy.addLink(map.get(linkOriginal.source), map.get(linkOriginal.target));\n                    if (save) {\n                        copy.linkMap.set(linkCopy, linkOriginal);\n                    }\n                }\n            });\n            return copy;\n        }\n        /**\n         * The parsing allows a quick way to create graphs.\n         *  - [\"n1->n2\", \"n2->n3\"]: creates the three nodes and adds the links\n         *  - [\"n1->n2\", {id: \"QSDF\"}, \"n2->n3\"]: same as previous but also performs a deep extend of the link between n1 and n2 with the given object.\n         */\n        linearize(addIds) {\n            return Graph.Utils.linearize(this, addIds);\n        }\n        /**\n         * Performs a depth-first traversal starting at the given node.\n         *\n         * @param startNode a node or id of a node in this graph\n         * @param action\n         */\n        depthFirstTraversal(startNode, action) {\n            if (isUndefined(startNode)) {\n                throw new Error('You need to supply a starting node.');\n            }\n            if (isUndefined(action)) {\n                throw new Error('You need to supply an action.');\n            }\n            if (!this.hasNode(startNode)) {\n                throw new Error('The given start-node is not part of this graph');\n            }\n            const foundNode = this.getNode(startNode); // case the given one is an Id\n            const visited = [];\n            this._dftIterator(foundNode, action, visited);\n        }\n        _dftIterator(node, action, visited) {\n            action(node);\n            visited.push(node);\n            const children = node.getChildren();\n            for (let i = 0, len = children.length; i < len; i++) {\n                const child = children[i];\n                if (contains(visited, child)) {\n                    continue;\n                }\n                this._dftIterator(child, action, visited);\n            }\n        }\n        /**\n         * Performs a breadth-first traversal starting at the given node.\n         *\n         * @param startNode a node or id of a node in this graph\n         * @param action\n         */\n        breadthFirstTraversal(startNode, action) {\n            if (isUndefined(startNode)) {\n                throw new Error('You need to supply a starting node.');\n            }\n            if (isUndefined(action)) {\n                throw new Error('You need to supply an action.');\n            }\n            if (!this.hasNode(startNode)) {\n                throw new Error('The given start-node is not part of this graph');\n            }\n            const foundNode = this.getNode(startNode); // case the given one is an Id\n            const queue = new Queue();\n            const visited = [];\n            queue.enqueue(foundNode);\n            while (queue.length > 0) {\n                const node = queue.dequeue();\n                action(node);\n                visited.push(node);\n                const children = node.getChildren();\n                for (let i = 0, len = children.length; i < len; i++) {\n                    const child = children[i];\n                    if (contains(visited, child) || queue.contains(child)) {\n                        continue;\n                    }\n                    queue.enqueue(child);\n                }\n            }\n        }\n        /**\n         * This is the classic Tarjan algorithm for strongly connected components.\n         * See e.g. http://en.wikipedia.org/wiki/Tarjan's_strongly_connected_components_algorithm\n         *\n         * @param excludeSingleItems Whether isolated nodes should be excluded from the analysis.\n         * @param node The start node from which the analysis starts.\n         * @param indices  Numbers the nodes consecutively in the order in which they are discovered.\n         * @param lowLinks The smallest index of any node known to be reachable from the node, including the node itself\n         * @param connected The current component.\n         * @param stack The bookkeeping stack of things to visit.\n         * @param index The counter of visited nodes used to assign the indices.\n         * @private\n         */\n        _stronglyConnectedComponents(excludeSingleItems, node, indices, lowLinks, connected, stack, index) {\n            indices.add(node, index);\n            lowLinks.add(node, index);\n            index++;\n            stack.push(node);\n            const children = node.getChildren();\n            let next;\n            for (let i = 0, len = children.length; i < len; i++) {\n                next = children[i];\n                if (!indices.containsKey(next)) {\n                    this._stronglyConnectedComponents(excludeSingleItems, next, indices, lowLinks, connected, stack, index);\n                    lowLinks.add(node, Math.min(lowLinks.get(node), lowLinks.get(next)));\n                }\n                else if (contains(stack, next)) {\n                    lowLinks.add(node, Math.min(lowLinks.get(node), indices.get(next)));\n                }\n            }\n            // If v is a root node, pop the stack and generate a strong component\n            if (lowLinks.get(node) === indices.get(node)) {\n                const component = [];\n                do {\n                    next = stack.pop();\n                    component.push(next);\n                } while (next !== node);\n                if (!excludeSingleItems || (component.length > 1)) {\n                    connected.push(component);\n                }\n            }\n        }\n        /**\n         * Returns the cycles found in this graph.\n         * The returned arrays consist of the nodes which are strongly coupled.\n         *\n         * @param excludeSingleItems Whether isolated nodes should be excluded.\n         * @returns {Array} The array of cycles found.\n         */\n        findCycles(excludeSingleItems) {\n            if (isUndefined(excludeSingleItems)) {\n                excludeSingleItems = true;\n            }\n            const indices = new Dictionary();\n            const lowLinks = new Dictionary();\n            const connected = [];\n            const stack = [];\n            for (let i = 0, len = this.nodes.length; i < len; i++) {\n                const node = this.nodes[i];\n                if (indices.containsKey(node)) {\n                    continue;\n                }\n                this._stronglyConnectedComponents(excludeSingleItems, node, indices, lowLinks, connected, stack, 0);\n            }\n            return connected;\n        }\n        /**\n         * Returns whether this graph is acyclic.\n         *\n         * @returns {*}\n         */\n        isAcyclic() {\n            return isEmpty(this.findCycles());\n        }\n        /**\n         * Returns whether the given graph is a subgraph of this one.\n         *\n         * @param other Another graph instance.\n         */\n        isSubGraph(other) {\n            const otherArray = other.linearize();\n            const thisArray = this.linearize();\n            return all(otherArray, function (s) {\n                return contains(thisArray, s);\n            });\n        }\n        /**\n         *  Makes an acyclic graph from the current (connected) one.\n         * * @returns {Array} The reversed links.\n         */\n        makeAcyclic() {\n            // if empty or almost empty\n            if (this.isEmpty() || this.nodes.length <= 1 || this.links.length <= 1) {\n                return [];\n            }\n            // singular case of just two nodes\n            if (this.nodes.length === 2) {\n                const result = [];\n                if (this.links.length > 1) {\n                    const oneLink = this.links[0];\n                    const oneNode = oneLink.source;\n                    for (let i = 0, len = this.links.length; i < len; i++) {\n                        const link = this.links[i];\n                        if (link.source === oneNode) {\n                            continue;\n                        }\n                        const rev = link.reverse();\n                        result.push(rev);\n                    }\n                }\n                return result;\n            }\n            const copy = this.clone(true); // copy.nodeMap tells you the mapping\n            const N = this.nodes.length;\n            const intensityCatalog = new Dictionary();\n            /**\n             * If there are both incoming and outgoing links this will return the flow intensity (out-in).\n             * Otherwise the node acts as a flow source with N specifying the (equal) intensity.\n             *\n             * @param node\n             * @returns {number}\n             */\n            const flowIntensity = function (node) {\n                if (node.outgoing.length === 0) {\n                    return (2 - N);\n                }\n                else if (node.incoming.length === 0) {\n                    return (N - 2);\n                }\n                else {\n                    return node.outgoing.length - node.incoming.length;\n                }\n            };\n            /**\n             * Collects the nodes with the same intensity.\n             *\n             * @param node\n             * @param intensityCatalog\n             */\n            const catalogEqualIntensity = function (node) {\n                const intensity = flowIntensity(node);\n                if (!intensityCatalog.containsKey(intensity)) {\n                    intensityCatalog.set(intensity, []);\n                }\n                intensityCatalog.get(intensity).push(node);\n            };\n            forEach(copy.nodes, function (v) {\n                catalogEqualIntensity(v);\n            });\n            let sourceStack = [];\n            const targetStack = [];\n            while (copy.nodes.length > 0) {\n                let source, target, intensity;\n                if (intensityCatalog.containsKey(2 - N)) {\n                    const targets = intensityCatalog.get(2 - N); // nodes without outgoings\n                    while (targets.length > 0) {\n                        target = targets.pop();\n                        for (let li = 0; li < target.links.length; li++) {\n                            const targetLink = target.links[li];\n                            source = targetLink.getComplement(target);\n                            intensity = flowIntensity(source);\n                            remove(intensityCatalog.get(intensity), source);\n                            source.removeLink(targetLink);\n                            catalogEqualIntensity(source);\n                        }\n                        copy._removeNode(target);\n                        targetStack.unshift(target);\n                    }\n                }\n                // move sources to sourceStack\n                if (intensityCatalog.containsKey(N - 2)) {\n                    const sources = intensityCatalog.get(N - 2); // nodes without incomings\n                    while (sources.length > 0) {\n                        source = sources.pop();\n                        for (let si = 0; si < source.links.length; si++) {\n                            const sourceLink = source.links[si];\n                            target = sourceLink.getComplement(source);\n                            intensity = flowIntensity(target);\n                            remove(intensityCatalog.get(intensity), target);\n                            target.removeLink(sourceLink);\n                            catalogEqualIntensity(target);\n                        }\n                        sourceStack.push(source);\n                        copy._removeNode(source);\n                    }\n                }\n                if (copy.nodes.length > 0) {\n                    for (let k = N - 3; k > 2 - N; k--) {\n                        if (intensityCatalog.containsKey(k) &&\n                            intensityCatalog.get(k).length > 0) {\n                            const maxdiff = intensityCatalog.get(k);\n                            const v = maxdiff.pop();\n                            for (let ri = 0; ri < v.links.length; ri++) {\n                                const ril = v.links[ri];\n                                const u = ril.getComplement(v);\n                                intensity = flowIntensity(u);\n                                remove(intensityCatalog.get(intensity), u);\n                                u.removeLink(ril);\n                                catalogEqualIntensity(u);\n                            }\n                            sourceStack.push(v);\n                            copy._removeNode(v);\n                            break;\n                        }\n                    }\n                }\n            }\n            sourceStack = sourceStack.concat(targetStack);\n            const vertexOrder = new Dictionary();\n            for (let kk = 0; kk < this.nodes.length; kk++) {\n                vertexOrder.set(copy.nodeMap.get(sourceStack[kk]), kk);\n            }\n            const reversedEdges = [];\n            forEach(this.links, function (link) {\n                if (vertexOrder.get(link.source) > vertexOrder.get(link.target)) {\n                    link.reverse();\n                    reversedEdges.push(link);\n                }\n            });\n            return reversedEdges;\n        }\n    }\n    /**\n     * A collection of predefined graphs for demo and testing purposes.\n     */\n    Graph.Predefined = {\n        /**\n         * Eight-shapes graph all connected in a cycle.\n         *\n         * @returns {*}\n         * @constructor\n         */\n        EightGraph() {\n            return Graph.Utils.parse(['1->2', '2->3', '3->4', '4->1', '3->5', '5->6', '6->7', '7->3']);\n        },\n        /**\n         * Creates a typical mindmap diagram.\n         *\n         * @returns {*}\n         * @constructor\n         */\n        Mindmap() {\n            return Graph.Utils.parse(['0->1', '0->2', '0->3', '0->4', '0->5', '1->6', '1->7', '7->8', '2->9', '9->10', '9->11', '3->12',\n                '12->13', '13->14', '4->15', '4->16', '15->17', '15->18', '18->19', '18->20', '14->21', '14->22', '5->23', '23->24', '23->25', '6->26']);\n        },\n        /**\n         * Three nodes connected in a cycle.\n         *\n         * @returns {*}\n         * @constructor\n         */\n        ThreeGraph() {\n            return Graph.Utils.parse(['1->2', '2->3', '3->1']);\n        },\n        /**\n         * A tree with each node having two children.\n         *\n         * @param levels How many levels the binary tree should have.\n         * @returns {diagram.Graph}\n         * @constructor\n         */\n        BinaryTree(levels) {\n            if (isUndefined(levels)) {\n                levels = 5;\n            }\n            return Graph.Utils.createBalancedTree(levels, 2);\n        },\n        /**\n         * A linear graph (discrete line segment).\n         *\n         * @param length How many segments (the node count is hence (length+1)).\n         * @returns {diagram.Graph}\n         * @constructor\n         */\n        Linear(length) {\n            if (isUndefined(length)) {\n                length = 10;\n            }\n            return Graph.Utils.createBalancedTree(length, 1);\n        },\n        /**\n         * A standard tree-graph with the specified levels and children (siblings) count.\n         * Note that for a balanced tree of level N and sibling count s, counting the root as level zero:\n         * - NodeCount = (1-s^(N+1))/(1-s)]\n         * - LinkCount = s.(1-s^N)/(1-s)\n         *\n         * @param levels How many levels the tree should have.\n         * @param siblingsCount How many siblings each level should have.\n         * @returns {diagram.Graph}\n         * @constructor\n         */\n        Tree(levels, siblingsCount) {\n            return Graph.Utils.createBalancedTree(levels, siblingsCount);\n        },\n        /**\n         * Creates a forest.\n         * Note that for a balanced forest of level N, sibling count s and tree count t, counting the root as level zero:\n         * - NodeCount = t.(1-s^(N+1))/(1-s)]\n         * - LinkCount = t.s.(1-s^N)/(1-s)\n         *\n         * @param levels How many levels the tree should have.\n         * @param siblingsCount How many siblings each level should have.\n         * @param trees The amount of trees the forest should have.\n         * @returns {diagram.Graph}\n         * @constructor\n         */\n        Forest(levels, siblingsCount, trees) {\n            return Graph.Utils.createBalancedForest(levels, siblingsCount, trees);\n        },\n        /**\n         * A workflow-like graph with cycles.\n         *\n         * @returns {*}\n         * @constructor\n         */\n        Workflow() {\n            return Graph.Utils.parse(['0->1', '1->2', '2->3', '1->4', '4->3', '3->5', '5->6', '6->3', '6->7', '5->4']);\n        },\n        /**\n         * A grid graph with the direction of the links avoiding cycles.\n         * Node count: (n+1).(m+1)\n         * Link count: n.(m+1) + m.(n+1)\n         *\n         * @param n Horizontal count of grid cells. If zero this will result in a linear graph.\n         * @param m Vertical count of grid cells. If zero this will result in a linear graph.\n         * @constructor\n         */\n        Grid(n, m) {\n            const g = new Graph();\n            if (n <= 0 && m <= 0) {\n                return g;\n            }\n            for (let i = 0; i < n + 1; i++) {\n                let previous = null;\n                for (let j = 0; j < m + 1; j++) {\n                    // using x-y coordinates to name the nodes\n                    const node = new Node(i.toString() + '.' + j.toString());\n                    g.addNode(node);\n                    if (previous) {\n                        g.addLink(previous, node);\n                    }\n                    if (i > 0) {\n                        const left = g.getNode((i - 1).toString() + '.' + j.toString());\n                        g.addLink(left, node);\n                    }\n                    previous = node;\n                }\n            }\n            return g;\n        }\n    };\n    /**\n     * Graph generation and other utilities.\n     */\n    Graph.Utils = {\n        /**\n         * The parsing allows a quick way to create graphs.\n         *  - [\"n1->n2\", \"n2->n3\"]: creates the three nodes and adds the links\n         *  - [\"n1->n2\", {id: \"id177\"}, \"n2->n3\"]: same as previous but also performs a deep extend of the link between n1 and n2 with the given object.\n         */\n        parse(graphString) {\n            let previousLink;\n            const graph = new Graph(), parts = graphString.slice();\n            for (let i = 0, len = parts.length; i < len; i++) {\n                const part = parts[i];\n                if (isString$1(part)) { // link spec\n                    if (part.indexOf('->') < 0) {\n                        throw new Error('The link should be specified as \\'a->b\\'.');\n                    }\n                    const p = part.split('->');\n                    if (p.length !== 2) {\n                        throw new Error('The link should be specified as \\'a->b\\'.');\n                    }\n                    previousLink = new Link(p[0], p[1]);\n                    graph.addLink(previousLink);\n                }\n                if (isObject(part)) {\n                    if (!previousLink) {\n                        throw new Error('Specification found before Link definition.');\n                    }\n                    deepExtend(previousLink, part);\n                }\n            }\n            return graph;\n        },\n        /**\n         * Returns a linearized representation of the given Graph.\n         * See also the Graph.Utils.parse method for the inverse operation.\n         */\n        linearize(graph, addIds) {\n            if (isUndefined(graph)) {\n                throw new Error('Expected an instance of a Graph object in slot one.');\n            }\n            if (isUndefined(addIds)) {\n                addIds = false;\n            }\n            const lin = [];\n            for (let i = 0, len = graph.links.length; i < len; i++) {\n                const link = graph.links[i];\n                lin.push(link.source.id + '->' + link.target.id);\n                if (addIds) {\n                    lin.push({ id: link.id });\n                }\n            }\n            return lin;\n        },\n        /**\n         * The method used by the diagram creation to instantiate a shape.\n         *\n         * @param kendoDiagram The Kendo diagram where the diagram will be created.\n         * @param p The position at which to place the shape.\n         * @param shapeDefaults Optional Shape options.\n         * @param id Optional identifier of the shape.\n         * @returns {*}\n         * @private\n         */\n        _addShape(kendoDiagram, p, id, shapeDefaults) {\n            if (isUndefined(p)) {\n                p = new Point(0, 0);\n            }\n            if (isUndefined(id)) {\n                id = randomId();\n            }\n            shapeDefaults = deepExtend({\n                width: 20,\n                height: 20,\n                id: id,\n                radius: 10,\n                fill: '#778899',\n                data: 'circle',\n                undoable: false,\n                x: p.x,\n                y: p.y\n            }, shapeDefaults);\n            return kendoDiagram.addShape(shapeDefaults);\n        },\n        /**\n         * The method used by the diagram creation to instantiate a connection.\n         *\n         * @param diagram he Kendo diagram where the diagram will be created.\n         * @param from The source shape.\n         * @param to The target shape.\n         * @param options Optional Connection options.\n         * @returns {*}\n         * @private\n         */\n        _addConnection(diagram, from, to, options) {\n            return diagram.connect(from, to, options);\n        },\n        /**\n         * Creates a diagram from the given Graph.\n         *\n         * @param diagram The Kendo diagram where the diagram will be created.\n         * @param graph The graph structure defining the diagram.\n         */\n        createDiagramFromGraph(diagram, graph, doLayout, randomSize) {\n            if (isUndefined(diagram)) {\n                throw new Error('The diagram surface is undefined.');\n            }\n            if (isUndefined(graph)) {\n                throw new Error('No graph specification defined.');\n            }\n            if (isUndefined(doLayout)) {\n                doLayout = true;\n            }\n            if (isUndefined(randomSize)) {\n                randomSize = false;\n            }\n            const width = diagram.element.clientWidth || 200;\n            const height = diagram.element.clientHeight || 200;\n            const map = [];\n            let node, shape;\n            for (let i = 0, len = graph.nodes.length; i < len; i++) {\n                node = graph.nodes[i];\n                let p = node.position;\n                if (isUndefined(p)) {\n                    if (isDefined(node.x) && isDefined(node.y)) {\n                        p = new Point(node.x, node.y);\n                    }\n                    else {\n                        p = new Point(randomInteger(10, width - 20), randomInteger(10, height - 20));\n                    }\n                }\n                const opt = {};\n                if (node.id === '0') {\n                    /* deepExtend(opt,\n                       {\n                       fill: \"Orange\",\n                       data: 'circle',\n                       width: 100,\n                       height: 100,\n                       center: new Point(50, 50)\n                       });*/\n                }\n                else if (randomSize) {\n                    deepExtend(opt, {\n                        width: Math.random() * 150 + 20,\n                        height: Math.random() * 80 + 50,\n                        data: 'rectangle',\n                        fill: {\n                            color: '#778899'\n                        }\n                    });\n                }\n                shape = this._addShape(diagram, p, node.id, opt);\n                // shape.content(node.id);\n                const bounds = shape.bounds();\n                if (isDefined(bounds)) {\n                    node.x = bounds.x;\n                    node.y = bounds.y;\n                    node.width = bounds.width;\n                    node.height = bounds.height;\n                }\n                map[node.id] = shape;\n            }\n            for (let gli = 0; gli < graph.links.length; gli++) {\n                const link = graph.links[gli];\n                const sourceShape = map[link.source.id];\n                if (isUndefined(sourceShape)) {\n                    continue;\n                }\n                const targetShape = map[link.target.id];\n                if (isUndefined(targetShape)) {\n                    continue;\n                }\n                this._addConnection(diagram, sourceShape, targetShape, { id: link.id });\n            }\n            if (doLayout) {\n                const l = new SpringLayout(diagram);\n                l.layoutGraph(graph, { limitToView: false });\n                for (let shi = 0; shi < graph.nodes.length; shi++) {\n                    node = graph.nodes[shi];\n                    shape = map[node.id];\n                    shape.bounds(new Rect(node.x, node.y, node.width, node.height));\n                }\n            }\n        },\n        /**\n         * Creates a balanced tree with the specified number of levels and siblings count.\n         * Note that for a balanced tree of level N and sibling count s, counting the root as level zero:\n         * - NodeCount = (1-s^(N+1))/(1-s)]\n         * - LinkCount = s.(1-s^N)/(1-s)\n         *\n         * @param levels How many levels the tree should have.\n         * @param siblingsCount How many siblings each level should have.\n         * @returns {diagram.Graph}\n         */\n        createBalancedTree(levels, siblingsCount) {\n            if (isUndefined(levels)) {\n                levels = 3;\n            }\n            if (isUndefined(siblingsCount)) {\n                siblingsCount = 3;\n            }\n            const g = new Graph();\n            let news, counter = -1, lastAdded = [];\n            if (levels <= 0 || siblingsCount <= 0) {\n                return g;\n            }\n            const root = new Node((++counter).toString());\n            g.addNode(root);\n            g.root(root);\n            lastAdded.push(root);\n            for (let i = 0; i < levels; i++) {\n                news = [];\n                for (let j = 0; j < lastAdded.length; j++) {\n                    const parent = lastAdded[j];\n                    for (let k = 0; k < siblingsCount; k++) {\n                        const item = new Node((++counter).toString());\n                        g.addLink(parent, item);\n                        news.push(item);\n                    }\n                }\n                lastAdded = news;\n            }\n            return g;\n        },\n        /**\n         * Creates a balanced tree with the specified number of levels and siblings count.\n         * Note that for a balanced forest of level N, sibling count s and tree count t, counting the root as level zero:\n         * - NodeCount = t.(1-s^(N+1))/(1-s)]\n         * - LinkCount = t.s.(1-s^N)/(1-s)\n         *\n         * @param levels How many levels the tree should have.\n         * @param siblingsCount How many siblings each level should have.\n         * @returns {diagram.Graph}\n         * @param treeCount The number of trees the forest should have.\n         */\n        createBalancedForest(levels, siblingsCount, treeCount) {\n            if (isUndefined(levels)) {\n                levels = 3;\n            }\n            if (isUndefined(siblingsCount)) {\n                siblingsCount = 3;\n            }\n            if (isUndefined(treeCount)) {\n                treeCount = 5;\n            }\n            const g = new Graph();\n            let counter = -1, lastAdded = [], news;\n            if (levels <= 0 || siblingsCount <= 0 || treeCount <= 0) {\n                return g;\n            }\n            for (let t = 0; t < treeCount; t++) {\n                const root = new Node((++counter).toString());\n                g.addNode(root);\n                lastAdded = [root];\n                for (let i = 0; i < levels; i++) {\n                    news = [];\n                    for (let j = 0; j < lastAdded.length; j++) {\n                        const parent = lastAdded[j];\n                        for (let k = 0; k < siblingsCount; k++) {\n                            const item = new Node((++counter).toString());\n                            g.addLink(parent, item);\n                            news.push(item);\n                        }\n                    }\n                    lastAdded = news;\n                }\n            }\n            return g;\n        },\n        /**\n         * Creates a random graph (uniform distribution) with the specified amount of nodes.\n         *\n         * @param nodeCount The amount of nodes the random graph should have.\n         * @param maxIncidence The maximum allowed degree of the nodes.\n         * @param isTree Whether the return graph should be a tree (default: false).\n         * @returns {diagram.Graph}\n         */\n        createRandomConnectedGraph(nodeCount, maxIncidence, isTree) {\n            /* Swa's Mathematica export of random Bernoulli graphs\n               gr[n_,p_]:=Module[{g=RandomGraph[BernoulliGraphDistribution[n,p],VertexLabels->\"Name\",DirectedEdges->True]},\n               While[Not[ConnectedGraphQ[g]],g=RandomGraph[BernoulliGraphDistribution[n,p],VertexLabels->\"Name\",DirectedEdges->True]];g];\n               project[a_]:=(\"\\\"\"<>ToString[Part[#,1]]<>\"->\"<>ToString[Part[#,2]]<>\"\\\"\")&     @ a;\n               export[g_]:=project/@ EdgeList[g]\n               g = gr[12,.1]\n               export [g]\n               */\n            if (isUndefined(nodeCount)) {\n                nodeCount = 40;\n            }\n            if (isUndefined(maxIncidence)) {\n                maxIncidence = 4;\n            }\n            if (isUndefined(isTree)) {\n                isTree = false;\n            }\n            const g = new Graph();\n            let counter = -1;\n            if (nodeCount <= 0) {\n                return g;\n            }\n            const root = new Node((++counter).toString());\n            g.addNode(root);\n            if (nodeCount === 1) {\n                return g;\n            }\n            if (nodeCount > 1) {\n                // random tree\n                for (let i = 1; i < nodeCount; i++) {\n                    const poolNode = g.takeRandomNode([], maxIncidence);\n                    if (!poolNode) {\n                        // failed to find one so the graph will have less nodes than specified\n                        break;\n                    }\n                    const newNode = g.addNode(i.toString());\n                    g.addLink(poolNode, newNode);\n                }\n                if (!isTree && nodeCount > 1) {\n                    const randomAdditions = randomInteger(1, nodeCount);\n                    for (let ri = 0; ri < randomAdditions; ri++) {\n                        const n1 = g.takeRandomNode([], maxIncidence);\n                        const n2 = g.takeRandomNode([], maxIncidence);\n                        if (n1 && n2 && !g.areConnected(n1, n2)) {\n                            g.addLink(n1, n2);\n                        }\n                    }\n                }\n                return g;\n            }\n        },\n        /**\n         * Generates a random diagram.\n         *\n         * @param diagram The host diagram.\n         * @param shapeCount The number of shapes the random diagram should contain.\n         * @param maxIncidence The maximum degree the shapes can have.\n         * @param isTree Whether the generated diagram should be a tree\n         * @param layoutType The optional layout type to apply after the diagram is generated.\n         */\n        randomDiagram(diagram, shapeCount, maxIncidence, isTree, randomSize) {\n            const g = Graph.Utils.createRandomConnectedGraph(shapeCount, maxIncidence, isTree);\n            Graph.Utils.createDiagramFromGraph(diagram, g, false, randomSize);\n        }\n    };\n    /**\n     * The classic spring-embedder (aka force-directed, Fruchterman-Rheingold, barycentric) algorithm.\n     * http://en.wikipedia.org/wiki/Force-directed_graph_drawing\n     * - Chapter 12 of Tamassia et al. \"Handbook of graph drawing and visualization\".\n     * - Kobourov on preprint arXiv; http://arxiv.org/pdf/1201.3011.pdf\n     * - Fruchterman and Rheingold in SOFTWARE-PRACTICE AND EXPERIENCE, VOL. 21(1 1), 1129-1164 (NOVEMBER 1991)\n     *\n     * @type {*}\n     */\n    class SpringLayout extends LayoutBase {\n        constructor(diagram) {\n            super();\n            if (isUndefined(diagram)) {\n                throw new Error('Diagram is not specified.');\n            }\n            this.diagram = diagram;\n        }\n        layout(options) {\n            this.transferOptions(options);\n            const adapter = new DiagramToHyperTreeAdapter(this.diagram);\n            const graph = adapter.convert(options);\n            if (graph.isEmpty()) {\n                return;\n            }\n            // split into connected components\n            const components = graph.getConnectedComponents();\n            if (isEmpty(components)) {\n                return;\n            }\n            for (let i = 0; i < components.length; i++) {\n                const component = components[i];\n                this.layoutGraph(component, options);\n            }\n            const finalNodeSet = this.gridLayoutComponents(components);\n            return new LayoutState(this.diagram, finalNodeSet);\n        }\n        layoutGraph(graph, options) {\n            if (isDefined(options)) {\n                this.transferOptions(options);\n            }\n            this.graph = graph;\n            const initialTemperature = this.options.nodeDistance * 9;\n            this.temperature = initialTemperature;\n            const guessBounds = this._expectedBounds();\n            this.width = guessBounds.width;\n            this.height = guessBounds.height;\n            for (let step = 0; step < this.options.iterations; step++) {\n                this.refineStage = step >= this.options.iterations * 5 / 6;\n                this.tick();\n                // exponential cooldown\n                this.temperature = this.refineStage ?\n                    initialTemperature / 30 :\n                    initialTemperature * (1 - step / (2 * this.options.iterations));\n            }\n        }\n        /**\n         * Single iteration of the simulation.\n         */\n        tick() {\n            let i;\n            // collect the repulsive forces on each node\n            for (i = 0; i < this.graph.nodes.length; i++) {\n                this._repulsion(this.graph.nodes[i]);\n            }\n            // collect the attractive forces on each node\n            for (i = 0; i < this.graph.links.length; i++) {\n                this._attraction(this.graph.links[i]);\n            }\n            // update the positions\n            for (i = 0; i < this.graph.nodes.length; i++) {\n                const node = this.graph.nodes[i];\n                const offset = Math.sqrt(node.dx * node.dx + node.dy * node.dy);\n                if (offset === 0) {\n                    return;\n                }\n                node.x += Math.min(offset, this.temperature) * node.dx / offset;\n                node.y += Math.min(offset, this.temperature) * node.dy / offset;\n                if (this.options.limitToView) {\n                    node.x = Math.min(this.width, Math.max(node.width / 2, node.x));\n                    node.y = Math.min(this.height, Math.max(node.height / 2, node.y));\n                }\n            }\n        }\n        /**\n         * Shakes the node away from its current position to escape the deadlock.\n         *\n         * @param node A Node.\n         * @private\n         */\n        _shake(node) {\n            // just a simple polar neighborhood\n            const rho = Math.random() * this.options.nodeDistance / 4;\n            const alpha = Math.random() * 2 * Math.PI;\n            node.x += rho * Math.cos(alpha);\n            node.y -= rho * Math.sin(alpha);\n        }\n        /**\n         * The typical Coulomb-Newton force law F=k/r^2\n         *\n         * @remark This only works in dimensions less than three.\n         * @param d\n         * @param n A Node.\n         * @param m Another Node.\n         * @returns {number}\n         * @private\n         */\n        _InverseSquareForce(d, n, m) {\n            let force;\n            if (!this.refineStage) {\n                force = Math.pow(d, 2) / Math.pow(this.options.nodeDistance, 2);\n            }\n            else {\n                const deltax = n.x - m.x;\n                const deltay = n.y - m.y;\n                const wn = n.width / 2;\n                const hn = n.height / 2;\n                const wm = m.width / 2;\n                const hm = m.height / 2;\n                force = (Math.pow(deltax, 2) / Math.pow(wn + wm + this.options.nodeDistance, 2)) + (Math.pow(deltay, 2) / Math.pow(hn + hm + this.options.nodeDistance, 2));\n            }\n            return force * 4 / 3;\n        }\n        /**\n         * The typical Hooke force law F=kr^2\n         *\n         * @param d\n         * @param n\n         * @param m\n         * @returns {number}\n         * @private\n         */\n        _SquareForce(d, n, m) {\n            return 1 / this._InverseSquareForce(d, n, m);\n        }\n        _repulsion(n) {\n            n.dx = 0;\n            n.dy = 0;\n            forEach(this.graph.nodes, function (m) {\n                if (m === n) {\n                    return;\n                }\n                while (n.x === m.x && n.y === m.y) {\n                    this._shake(m);\n                }\n                const vx = n.x - m.x;\n                const vy = n.y - m.y;\n                const distance = Math.sqrt(vx * vx + vy * vy);\n                const r = this._SquareForce(distance, n, m) * 2;\n                n.dx += (vx / distance) * r;\n                n.dy += (vy / distance) * r;\n            }, this);\n        }\n        _attraction(link) {\n            const t = link.target;\n            const s = link.source;\n            if (s === t) {\n                // loops induce endless shakes\n                return;\n            }\n            while (s.x === t.x && s.y === t.y) {\n                this._shake(t);\n            }\n            const vx = s.x - t.x;\n            const vy = s.y - t.y;\n            const distance = Math.sqrt(vx * vx + vy * vy);\n            const a = this._InverseSquareForce(distance, s, t) * 5;\n            const dx = (vx / distance) * a;\n            const dy = (vy / distance) * a;\n            t.dx += dx;\n            t.dy += dy;\n            s.dx -= dx;\n            s.dy -= dy;\n        }\n        /**\n         * Calculates the expected bounds after layout.\n         *\n         * @returns {*}\n         * @private\n         */\n        _expectedBounds() {\n            const N = this.graph.nodes.length, /* golden ration optimal?*/ ratio = 1.5, multiplier = 4;\n            if (N === 0) {\n                return;\n            }\n            const size = fold(this.graph.nodes, function (s, node) {\n                const area = node.width * node.height;\n                if (area > 0) {\n                    s += Math.sqrt(area);\n                    return s;\n                }\n                return 0;\n            }, 0, this);\n            const av = size / N;\n            const squareSize = av * Math.ceil(Math.sqrt(N));\n            const width = squareSize * Math.sqrt(ratio);\n            const height = squareSize / Math.sqrt(ratio);\n            return { width: width * multiplier, height: height * multiplier };\n        }\n    }\n    /**\n     * Adapter between the diagram control and the graph representation. It converts shape and connections to nodes and edges taking into the containers and their collapsef state,\n     * the visibility of items and more. If the layoutContainerChildren is true a hypertree is constructed which holds the hierarchy of containers and many conditions are analyzed\n     * to investigate how the effective graph structure looks like and how the layout has to be performed.\n     *\n     * @type {*}\n     */\n    class DiagramToHyperTreeAdapter {\n        constructor(diagram) {\n            /**\n             * The mapping to/from the original nodes.\n             *\n             * @type {Dictionary}\n             */\n            this.nodeMap = new Dictionary();\n            /**\n             * Gets the mapping of a shape to a container in case the shape sits in a collapsed container.\n             *\n             * @type {Dictionary}\n             */\n            this.shapeMap = new Dictionary();\n            /**\n             * The nodes being mapped.\n             *\n             * @type {Dictionary}\n             */\n            this.nodes = [];\n            /**\n             * The connections being mapped.\n             *\n             * @type {Dictionary}\n             */\n            this.edges = [];\n            // the mapping from an edge to all the connections it represents, this can be both because of multiple connections between\n            // two shapes or because a container holds multiple connections to another shape or container.\n            this.edgeMap = new Dictionary();\n            /**\n             * The resulting set of Nodes when the analysis has finished.\n             *\n             * @type {Array}\n             */\n            this.finalNodes = [];\n            /**\n             * The resulting set of Links when the analysis has finished.\n             *\n             * @type {Array}\n             */\n            this.finalLinks = [];\n            /**\n             * The items being omitted because of multigraph edges.\n             *\n             * @type {Array}\n             */\n            this.ignoredConnections = [];\n            /**\n             * The items being omitted because of containers, visibility and other factors.\n             *\n             * @type {Array}\n             */\n            this.ignoredShapes = [];\n            /**\n             * The map from a node to the partition/hypernode in which it sits. This hyperMap is null if 'options.layoutContainerChildren' is false.\n             *\n             * @type {Dictionary}\n             */\n            this.hyperMap = new Dictionary();\n            /**\n             * The hypertree contains the hierarchy defined by the containers.\n             * It's in essence a Graph of Graphs with a tree structure defined by the hierarchy of containers.\n             *\n             * @type {HyperTree}\n             */\n            this.hyperTree = new Graph();\n            /**\n             * The resulting graph after conversion. Note that this does not supply the information contained in the\n             * ignored connection and shape collections.\n             *\n             * @type {null}\n             */\n            this.finalGraph = null;\n            this.diagram = diagram;\n        }\n        /**\n         * The hyperTree is used when the 'options.layoutContainerChildren' is true. It contains the hierarchy of containers whereby each node is a ContainerGraph.\n         * This type of node has a Container reference to the container which holds the Graph items. There are three possible situations during the conversion process:\n         * - Ignore the containers: the container are non-existent and only normal shapes are mapped. If a shape has a connection to a container it will be ignored as well\n         * since there is no node mapped for the container.\n         * - Do not ignore the containers and leave the content of the containers untouched: the top-level elements are being mapped and the children within a container are not altered.\n         * - Do not ignore the containers and organize the content of the containers as well: the hypertree is constructed and there is a partitioning of all nodes and connections into the hypertree.\n         * The only reason a connection or node is not being mapped might be due to the visibility, which includes the visibility change through a collapsed parent container.\n         *\n         * @param options\n         */\n        convert(options) {\n            if (isUndefined(this.diagram)) {\n                throw new Error('No diagram to convert.');\n            }\n            this.options = deepExtend({\n                ignoreInvisible: true,\n                ignoreContainers: true,\n                layoutContainerChildren: false\n            }, options || {});\n            this.clear();\n            // create the nodes which participate effectively in the graph analysis\n            this._renormalizeShapes();\n            // recreate the incoming and outgoing collections of each and every node\n            this._renormalizeConnections();\n            // export the resulting graph\n            this.finalNodes = new Dictionary(this.nodes);\n            this.finalLinks = new Dictionary(this.edges);\n            this.finalGraph = new Graph();\n            this.finalNodes.forEach(function (n) {\n                this.finalGraph.addNode(n);\n            }, this);\n            this.finalLinks.forEach(function (l) {\n                this.finalGraph.addExistingLink(l);\n            }, this);\n            return this.finalGraph;\n        }\n        /**\n         * Maps the specified connection to an edge of the graph deduced from the given diagram.\n         *\n         * @param connection\n         * @returns {*}\n         */\n        mapConnection(connection) {\n            return this.edgeMap.get(connection.id);\n        }\n        /**\n         * Maps the specified shape to a node of the graph deduced from the given diagram.\n         *\n         * @param shape\n         * @returns {*}\n         */\n        mapShape(shape) {\n            return this.nodeMap.get(shape.id);\n        }\n        /**\n         * Gets the edge, if any, between the given nodes.\n         *\n         * @param a\n         * @param b\n         */\n        getEdge(a, b) {\n            return first(a.links, function (link) {\n                return link.getComplement(a) === b;\n            });\n        }\n        /**\n         * Clears all the collections used by the conversion process.\n         */\n        clear() {\n            this.finalGraph = null;\n            this.hyperTree = (!this.options.ignoreContainers && this.options.layoutContainerChildren) ? new Graph() : null;\n            this.hyperMap = (!this.options.ignoreContainers && this.options.layoutContainerChildren) ? new Dictionary() : null;\n            this.nodeMap = new Dictionary();\n            this.shapeMap = new Dictionary();\n            this.nodes = [];\n            this.edges = [];\n            this.edgeMap = new Dictionary();\n            this.ignoredConnections = [];\n            this.ignoredShapes = [];\n            this.finalNodes = [];\n            this.finalLinks = [];\n        }\n        /**\n         * The path from a given ContainerGraph to the root (container).\n         *\n         * @param containerGraph\n         * @returns {Array}\n         */\n        listToRoot(containerGraph) {\n            const list = [];\n            let s = containerGraph.container;\n            if (!s) {\n                return list;\n            }\n            list.push(s);\n            while (s.parentContainer) {\n                s = s.parentContainer;\n                list.push(s);\n            }\n            list.reverse();\n            return list;\n        }\n        firstNonIgnorableContainer(shape) {\n            if (shape.isContainer && !this.isIgnorableItem(shape)) {\n                return shape;\n            }\n            return !shape.parentContainer ? null : this.firstNonIgnorableContainer(shape.parentContainer);\n        }\n        isContainerConnection(a, b) {\n            if (a.isContainer && this.isDescendantOf(a, b)) {\n                return true;\n            }\n            return b.isContainer && this.isDescendantOf(b, a);\n        }\n        /**\n         * Returns true if the given shape is a direct child or a nested container child of the given container.\n         * If the given container and shape are the same this will return false since a shape cannot be its own child.\n         *\n         * @param scope\n         * @param a\n         * @returns {boolean}\n         */\n        isDescendantOf(scope, a) {\n            if (!scope.isContainer) {\n                throw new Error('Expecting a container.');\n            }\n            if (scope === a) {\n                return false;\n            }\n            if (contains(scope.children, a)) {\n                return true;\n            }\n            const containers = [];\n            for (let i = 0, len = scope.children.length; i < len; i++) {\n                const c = scope.children[i];\n                if (c.isContainer && this.isDescendantOf(c, a)) {\n                    containers.push(c);\n                }\n            }\n            return containers.length > 0;\n        }\n        isIgnorableItem(shape) {\n            if (this.options.ignoreInvisible) {\n                if (shape.isCollapsed && this._isVisible(shape)) {\n                    return false;\n                }\n                if (!shape.isCollapsed && this._isVisible(shape)) {\n                    return false;\n                }\n                return true;\n            }\n            else {\n                return shape.isCollapsed && !this._isTop(shape);\n            }\n        }\n        /**\n         *  Determines whether the shape is or needs to be mapped to another shape. This occurs essentially when the shape sits in\n         *  a collapsed container hierarchy and an external connection needs a node endpoint. This node then corresponds to the mapped shape and is\n         *  necessarily a container in the parent hierarchy of the shape.\n         *\n         * @param shape\n         */\n        isShapeMapped(shape) {\n            return shape.isCollapsed && !this._isVisible(shape) && !this._isTop(shape);\n        }\n        leastCommonAncestor(a, b) {\n            if (!a) {\n                throw new Error('Parameter should not be null.');\n            }\n            if (!b) {\n                throw new Error('Parameter should not be null.');\n            }\n            if (!this.hyperTree) {\n                throw new Error('No hypertree available.');\n            }\n            const al = this.listToRoot(a);\n            const bl = this.listToRoot(b);\n            let found = null;\n            if (isEmpty(al) || isEmpty(bl)) {\n                return this.hyperTree.root().data;\n            }\n            let xa = al[0];\n            let xb = bl[0];\n            let i = 0;\n            while (xa === xb) {\n                found = al[i];\n                i++;\n                if (i >= al.length || i >= bl.length) {\n                    break;\n                }\n                xa = al[i];\n                xb = bl[i];\n            }\n            if (!found) {\n                return this.hyperTree.root().data;\n            }\n            else {\n                return this.hyperTree.nodes.filter(function (n) {\n                    return n.data.container === found;\n                });\n            }\n        }\n        /**\n         * Determines whether the specified item is a top-level shape or container.\n         *\n         * @param item\n         * @returns {boolean}\n         * @private\n         */\n        _isTop(item) {\n            return !item.parentContainer;\n        }\n        /**\n         * Determines iteratively (by walking up the container stack) whether the specified shape is visible.\n         * This does NOT tell whether the item is not visible due to an explicit Visibility change or due to a collapse state.\n         *\n         * @param shape\n         * @returns {*}\n         * @private\n         */\n        _isVisible(shape) {\n            if (!shape.visible()) {\n                return false;\n            }\n            return !shape.parentContainer ? shape.visible() : this._isVisible(shape.parentContainer);\n        }\n        _isCollapsed(shape) {\n            if (shape.isContainer && shape.isCollapsed) {\n                return true;\n            }\n            return shape.parentContainer && this._isCollapsed(shape.parentContainer);\n        }\n        /**\n         * First part of the graph creation; analyzing the shapes and containers and deciding whether they should be mapped to a Node.\n         *\n         * @private\n         */\n        _renormalizeShapes() {\n            // add the nodes, the adjacency structure will be reconstructed later on\n            if (this.options.ignoreContainers) {\n                for (let i = 0, len = this.diagram.shapes.length; i < len; i++) {\n                    const shape = this.diagram.shapes[i];\n                    // if not visible (and ignoring the invisible ones) or a container we skip\n                    if ((this.options.ignoreInvisible && !this._isVisible(shape)) || shape.isContainer) {\n                        this.ignoredShapes.push(shape);\n                        continue;\n                    }\n                    const node = new Node(shape.id, shape);\n                    node.isVirtual = false;\n                    // the mapping will always contain singletons and the hyperTree will be null\n                    this.nodeMap.add(shape.id, node);\n                    this.nodes.push(node);\n                }\n            }\n            else {\n                throw new Error('Containers are not supported yet, but stay tuned.');\n            }\n        }\n        /**\n         * Second part of the graph creation; analyzing the connections and deciding whether they should be mapped to an edge.\n         *\n         * @private\n         */\n        _renormalizeConnections() {\n            if (this.diagram.connections.length === 0) {\n                return;\n            }\n            for (let i = 0, len = this.diagram.connections.length; i < len; i++) {\n                const conn = this.diagram.connections[i];\n                if (this.isIgnorableItem(conn)) {\n                    this.ignoredConnections.push(conn);\n                    continue;\n                }\n                let source = !conn.sourceConnector ? null : conn.sourceConnector.shape;\n                let sink = !conn.targetConnector ? null : conn.targetConnector.shape;\n                // no layout for floating connections\n                if (!source || !sink) {\n                    this.ignoredConnections.push(conn);\n                    continue;\n                }\n                if (contains(this.ignoredShapes, source) && !this.shapeMap.containsKey(source)) {\n                    this.ignoredConnections.push(conn);\n                    continue;\n                }\n                if (contains(this.ignoredShapes, sink) && !this.shapeMap.containsKey(sink)) {\n                    this.ignoredConnections.push(conn);\n                    continue;\n                }\n                // if the endpoint sits in a collapsed container we need the container rather than the shape itself\n                if (this.shapeMap.containsKey(source)) {\n                    source = this.shapeMap[source];\n                }\n                if (this.shapeMap.containsKey(sink)) {\n                    sink = this.shapeMap[sink];\n                }\n                const sourceNode = this.mapShape(source);\n                const sinkNode = this.mapShape(sink);\n                if ((sourceNode === sinkNode) || this.areConnectedAlready(sourceNode, sinkNode)) {\n                    this.ignoredConnections.push(conn);\n                    continue;\n                }\n                if (sourceNode === null || sinkNode === null) {\n                    throw new Error('A shape was not mapped to a node.');\n                }\n                if (this.options.ignoreContainers) {\n                    // much like a floating connection here since at least one end is attached to a container\n                    if (sourceNode.isVirtual || sinkNode.isVirtual) {\n                        this.ignoredConnections.push(conn);\n                        continue;\n                    }\n                    const newEdge = new Link(sourceNode, sinkNode, conn.id, conn);\n                    this.edgeMap.add(conn.id, newEdge);\n                    this.edges.push(newEdge);\n                }\n                else {\n                    throw new Error('Containers are not supported yet, but stay tuned.');\n                }\n            }\n        }\n        areConnectedAlready(n, m) {\n            return getAny(this.edges, function (l) {\n                return l.source === n && l.target === m || l.source === m && l.target === n;\n            });\n        }\n    }\n\n    function intersectLine(start1, end1, start2, end2, isSegment) {\n        const tangensdiff = ((end1.x - start1.x) * (end2.y - start2.y)) - ((end1.y - start1.y) * (end2.x - start2.x));\n        if (isNearZero(tangensdiff)) {\n            // parallel lines\n            return;\n        }\n        const num1 = ((start1.y - start2.y) * (end2.x - start2.x)) - ((start1.x - start2.x) * (end2.y - start2.y));\n        const num2 = ((start1.y - start2.y) * (end1.x - start1.x)) - ((start1.x - start2.x) * (end1.y - start1.y));\n        const r = num1 / tangensdiff;\n        const s = num2 / tangensdiff;\n        if (isSegment && (r < 0 || r > 1 || s < 0 || s > 1)) {\n            // r < 0 => line 1 is below line 2\n            // r > 1 => line 1 is above line 2\n            // s < 0 => line 2 is below line 1\n            // s > 1 => line 2 is above line 1\n            return;\n        }\n        return new Point(start1.x + (r * (end1.x - start1.x)), start1.y + (r * (end1.y - start1.y)));\n    }\n    const Intersect = {\n        lines(start1, end1, start2, end2) {\n            return intersectLine(start1, end1, start2, end2);\n        },\n        segments(start1, end1, start2, end2) {\n            return intersectLine(start1, end1, start2, end2, true);\n        },\n        rectWithLine(rect, start, end) {\n            return Intersect.segments(start, end, rect.topLeft(), rect.topRight()) ||\n                Intersect.segments(start, end, rect.topRight(), rect.bottomRight()) ||\n                Intersect.segments(start, end, rect.bottomLeft(), rect.bottomRight()) ||\n                Intersect.segments(start, end, rect.topLeft(), rect.bottomLeft());\n        },\n        rects(rect1, rect2, angle) {\n            let tl = rect2.topLeft(), tr = rect2.topRight(), bl = rect2.bottomLeft(), br = rect2.bottomRight();\n            const center = rect2.center();\n            if (angle) {\n                tl = tl.rotate(angle, center);\n                tr = tr.rotate(angle, center);\n                bl = bl.rotate(angle, center);\n                br = br.rotate(angle, center);\n            }\n            let intersect = rect1.contains(tl) ||\n                rect1.contains(tr) ||\n                rect1.contains(bl) ||\n                rect1.contains(br) ||\n                Intersect.rectWithLine(rect1, tl, tr) ||\n                Intersect.rectWithLine(rect1, tl, bl) ||\n                Intersect.rectWithLine(rect1, tr, br) ||\n                Intersect.rectWithLine(rect1, bl, br);\n            if (!intersect) { // last possible case is rect1 to be completely within rect2\n                tl = rect1.topLeft();\n                tr = rect1.topRight();\n                bl = rect1.bottomLeft();\n                br = rect1.bottomRight();\n                if (angle) {\n                    const reverseAngle = 360 - angle;\n                    tl = tl.rotate(reverseAngle, center);\n                    tr = tr.rotate(reverseAngle, center);\n                    bl = bl.rotate(reverseAngle, center);\n                    br = br.rotate(reverseAngle, center);\n                }\n                intersect = rect2.contains(tl) ||\n                    rect2.contains(tr) ||\n                    rect2.contains(bl) ||\n                    rect2.contains(br);\n            }\n            return intersect;\n        }\n    };\n\n    const map = (arr, func) => arr.map(func);\n    /**\n     * SVG transformation represented as a vector.\n     */\n    class MatrixVector {\n        constructor(a, b, c, d, e, f) {\n            this.a = a || 0;\n            this.b = b || 0;\n            this.c = c || 0;\n            this.d = d || 0;\n            this.e = e || 0;\n            this.f = f || 0;\n        }\n        fromMatrix(m) {\n            const v = new MatrixVector();\n            v.a = m.a;\n            v.b = m.b;\n            v.c = m.c;\n            v.d = m.d;\n            v.e = m.e;\n            v.f = m.f;\n            return v;\n        }\n    }\n    /**\n     * SVG transformation matrix.\n     */\n    class Matrix {\n        constructor(a, b, c, d, e, f) {\n            this.a = a || 0;\n            this.b = b || 0;\n            this.c = c || 0;\n            this.d = d || 0;\n            this.e = e || 0;\n            this.f = f || 0;\n        }\n        plus(m) {\n            this.a += m.a;\n            this.b += m.b;\n            this.c += m.c;\n            this.d += m.d;\n            this.e += m.e;\n            this.f += m.f;\n        }\n        minus(m) {\n            this.a -= m.a;\n            this.b -= m.b;\n            this.c -= m.c;\n            this.d -= m.d;\n            this.e -= m.e;\n            this.f -= m.f;\n        }\n        times(m) {\n            return new Matrix(this.a * m.a + this.c * m.b, this.b * m.a + this.d * m.b, this.a * m.c + this.c * m.d, this.b * m.c + this.d * m.d, this.a * m.e + this.c * m.f + this.e, this.b * m.e + this.d * m.f + this.f);\n        }\n        apply(p) {\n            return new Point(this.a * p.x + this.c * p.y + this.e, this.b * p.x + this.d * p.y + this.f);\n        }\n        applyRect(r) {\n            return Rect.fromPoints(this.apply(r.topLeft()), this.apply(r.bottomRight()));\n        }\n        toString() {\n            return 'matrix(' + this.a + ' ' + this.b + ' ' + this.c + ' ' + this.d + ' ' + this.e + ' ' + this.f + ')';\n        }\n        static fromSVGMatrix(vm) {\n            const m = new Matrix();\n            m.a = vm.a;\n            m.b = vm.b;\n            m.c = vm.c;\n            m.d = vm.d;\n            m.e = vm.e;\n            m.f = vm.f;\n            return m;\n        }\n        static fromMatrixVector(v) {\n            const m = new Matrix();\n            m.a = v.a;\n            m.b = v.b;\n            m.c = v.c;\n            m.d = v.d;\n            m.e = v.e;\n            m.f = v.f;\n            return m;\n        }\n        static fromList(v) {\n            if (v.length !== 6) {\n                throw new Error('The given list should consist of six elements.');\n            }\n            const m = new Matrix();\n            m.a = v[0];\n            m.b = v[1];\n            m.c = v[2];\n            m.d = v[3];\n            m.e = v[4];\n            m.f = v[5];\n            return m;\n        }\n        static translation(x, y) {\n            const m = new Matrix();\n            m.a = 1;\n            m.b = 0;\n            m.c = 0;\n            m.d = 1;\n            m.e = x;\n            m.f = y;\n            return m;\n        }\n        static unit() {\n            return new Matrix(1, 0, 0, 1, 0, 0);\n        }\n        static rotation(angle, x, y) {\n            const m = new Matrix();\n            m.a = Math.cos(angle * Math.PI / 180);\n            m.b = Math.sin(angle * Math.PI / 180);\n            m.c = -m.b;\n            m.d = m.a;\n            m.e = (x - x * m.a + y * m.b) || 0;\n            m.f = (y - y * m.a - x * m.b) || 0;\n            return m;\n        }\n        static scaling(scaleX, scaleY) {\n            const m = new Matrix();\n            m.a = scaleX;\n            m.b = 0;\n            m.c = 0;\n            m.d = scaleY;\n            m.e = 0;\n            m.f = 0;\n            return m;\n        }\n        static parse(v) {\n            let parts, nums;\n            if (v) {\n                v = v.trim();\n                // of the form \"matrix(...)\"\n                if (v.slice(0, 6).toLowerCase() === 'matrix') {\n                    nums = v.slice(7, v.length - 1).trim();\n                    parts = nums.split(',');\n                    if (parts.length === 6) {\n                        return Matrix.fromList(map(parts, function (p) {\n                            return parseFloat(p);\n                        }));\n                    }\n                    parts = nums.split(' ');\n                    if (parts.length === 6) {\n                        return Matrix.fromList(map(parts, function (p) {\n                            return parseFloat(p);\n                        }));\n                    }\n                }\n                // of the form \"(...)\"\n                if (v.slice(0, 1) === '(' && v.slice(v.length - 1) === ')') {\n                    v = v.substr(1, v.length - 1);\n                }\n                if (v.indexOf(',') > 0) {\n                    parts = v.split(',');\n                    if (parts.length === 6) {\n                        return Matrix.fromList(map(parts, function (p) {\n                            return parseFloat(p);\n                        }));\n                    }\n                }\n                if (v.indexOf(' ') > 0) {\n                    parts = v.split(' ');\n                    if (parts.length === 6) {\n                        return Matrix.fromList(map(parts, function (p) {\n                            return parseFloat(p);\n                        }));\n                    }\n                }\n            }\n            return parts;\n        }\n    }\n\n    /**\n     * Returns a value with Gaussian (normal) distribution.\n     *\n     * @param mean The mean value of the distribution.\n     * @param deviation The deviation (spreading at half-height) of the distribution.\n     * @returns {number}\n     */\n    function normalVariable(mean, deviation) {\n        let x, y, r;\n        do {\n            x = Math.random() * 2 - 1;\n            y = Math.random() * 2 - 1;\n            r = x * x + y * y;\n        } while (!r || r > 1);\n        return mean + deviation * x * Math.sqrt(-2 * Math.log(r) / r);\n    }\n\n    /**\n     * Structure combining a Point with two additional points representing the handles or tangents attached to the first point.\n     * If the additional points are null or equal to the first point the path will be sharp.\n     * Left and right correspond to the direction of the underlying path.\n     */\n    class PathDefiner {\n        constructor(p, left, right) {\n            this.point = p;\n            this.left = left;\n            this.right = right;\n        }\n    }\n\n    /**\n     * While other data structures can have multiple times the same item a Set owns only\n     * once a particular item.\n     *\n     * @type {*}\n     */\n    class Set extends Observable {\n        constructor(resource) {\n            super();\n            this._hashTable = new HashTable();\n            this.length = 0;\n            if (isDefined(resource)) {\n                if (resource instanceof HashTable) {\n                    resource.forEach(function (d) {\n                        this.add(d);\n                    });\n                }\n                else if (resource instanceof Dictionary) {\n                    resource.forEach(function (k, v) {\n                        this.add({ key: k, value: v });\n                    }, this);\n                }\n            }\n        }\n        contains(item) {\n            return this._hashTable.containsKey(item);\n        }\n        add(item) {\n            const entry = this._hashTable.get(item);\n            if (!entry) {\n                this._hashTable.add(item, item);\n                this.length++;\n                this.trigger('changed');\n            }\n        }\n        get(item) {\n            if (this.contains(item)) {\n                return this._hashTable.get(item).value;\n            }\n            else {\n                return null;\n            }\n        }\n        /**\n         * Returns the hash of the item.\n         *\n         * @param item\n         * @returns {*}\n         */\n        hash(item) {\n            return this._hashTable._hash(item);\n        }\n        /**\n         * Removes the given item from the set. No exception is thrown if the item is not in the Set.\n         *\n         * @param item\n         */\n        remove(item) {\n            if (this.contains(item)) {\n                this._hashTable.remove(item);\n                this.length--;\n                this.trigger('changed');\n            }\n        }\n        /**\n         * Foreach with an iterator working on the key-value pairs.\n         *\n         * @param func\n         */\n        forEach(func, context) {\n            const call = context ? func.bind(context) : func;\n            this._hashTable.forEach(function (kv) {\n                call(kv.value);\n            });\n        }\n        toArray() {\n            const r = [];\n            this.forEach(function (d) {\n                r.push(d);\n            });\n            return r;\n        }\n    }\n\n    class Size {\n        constructor(width, height) {\n            this.width = width;\n            this.height = height;\n        }\n        static Empty() {\n            return new Size(0, 0);\n        }\n    }\n\n    /**\n     * Represents a rotation transformation with angle and optional center point.\n     * Provides methods to convert to matrix form and create inverse transformations.\n     */\n    class Rotation {\n        /**\n         * Creates a new Rotation transformation.\n         * @param angle The rotation angle in radians\n         * @param x The x coordinate of the rotation center (optional)\n         * @param y The y coordinate of the rotation center (optional)\n         */\n        constructor(angle, x, y) {\n            this.x = x || 0;\n            this.y = y || 0;\n            this.angle = angle;\n        }\n        /**\n         * Returns a string representation of the rotation transformation.\n         * @returns String representation in CSS transform format\n         */\n        toString() {\n            if (this.x && this.y) {\n                return `rotate(${this.angle},${this.x},${this.y})`;\n            }\n            else {\n                return `rotate(${this.angle})`;\n            }\n        }\n        /**\n         * Converts the rotation transformation to a matrix representation.\n         * @returns A matrix representing the rotation transformation\n         */\n        toMatrix() {\n            return Matrix.rotation(this.angle, this.x, this.y); // T*R*T^-1\n        }\n        /**\n         * Gets the center point of the rotation.\n         * @returns A Point representing the rotation center\n         */\n        center() {\n            return new Point(this.x, this.y);\n        }\n        /**\n         * Creates an inverted version of this rotation transformation.\n         * @returns A new Rotation with inverted angle\n         */\n        invert() {\n            return new Rotation(FULL_CIRCLE_ANGLE - this.angle, this.x, this.y);\n        }\n        /**\n         * Creates a new Rotation instance from an existing rotation.\n         * @param rotation The rotation to copy\n         * @returns A new Rotation instance\n         */\n        static create(rotation) {\n            return new Rotation(rotation.angle, rotation.x, rotation.y);\n        }\n        /**\n         * Parses a rotation from a string representation.\n         * @param str The string to parse\n         * @returns A new Rotation instance\n         */\n        static parse(str) {\n            const values = str.slice(1, str.length - 1).split(',');\n            const angle = parseFloat(values[0]);\n            const x = parseFloat(values[1]);\n            const y = parseFloat(values[2]);\n            return new Rotation(angle, x, y);\n        }\n    }\n    /** A static instance representing zero rotation. */\n    Rotation.ZERO = new Rotation(0);\n\n    /**\n     * Represents a scaling transformation with separate x and y scaling factors.\n     * Provides methods to convert to matrix form and create inverse transformations.\n     */\n    class Scale {\n        /**\n         * Creates a new Scale transformation.\n         * @param x The scaling factor for the x-axis\n         * @param y The scaling factor for the y-axis\n         */\n        constructor(x, y) {\n            this.x = x;\n            this.y = y;\n        }\n        /**\n         * Converts the scaling transformation to a matrix representation.\n         * @returns A matrix representing the scaling transformation\n         */\n        toMatrix() {\n            return Matrix.scaling(this.x, this.y);\n        }\n        /**\n         * Returns a string representation of the scaling transformation.\n         * @returns String representation in CSS transform format\n         */\n        toString() {\n            return `scale(${this.x},${this.y})`;\n        }\n        /**\n         * Creates an inverted version of this scaling transformation.\n         * @returns A new Scale with inverted scaling factors\n         */\n        invert() {\n            return new Scale(1 / this.x, 1 / this.y);\n        }\n    }\n    ;\n\n    /**\n     * Represents a translation transformation with x and y offset values.\n     * Provides methods to convert to matrix form and perform vector operations.\n     */\n    class Translation {\n        /**\n         * Creates a new Translation transformation.\n         * @param x The x offset\n         * @param y The y offset\n         */\n        constructor(x, y) {\n            this.x = x;\n            this.y = y;\n        }\n        /**\n         * Converts the translation to a matrix vector representation.\n         * @returns A MatrixVector representing the translation\n         */\n        toMatrixVector() {\n            return new MatrixVector(0, 0, 0, 0, this.x, this.y);\n        }\n        /**\n         * Converts the translation transformation to a matrix representation.\n         * @returns A matrix representing the translation transformation\n         */\n        toMatrix() {\n            return Matrix.translation(this.x, this.y);\n        }\n        /**\n         * Returns a string representation of the translation transformation.\n         * @returns String representation in CSS transform format\n         */\n        toString() {\n            return `translate(${this.x},${this.y})`;\n        }\n        /**\n         * Adds another translation to this one.\n         * @param delta The translation to add\n         */\n        plus(delta) {\n            this.x += delta.x;\n            this.y += delta.y;\n        }\n        /**\n         * Multiplies the translation by a scaling factor.\n         * @param factor The scaling factor to apply\n         */\n        times(factor) {\n            this.x *= factor;\n            this.y *= factor;\n        }\n        /**\n         * Calculates the length (magnitude) of the translation vector.\n         * @returns The length of the translation vector\n         */\n        length() {\n            return Math.sqrt(this.x * this.x + this.y * this.y);\n        }\n        /**\n         * Normalizes the translation vector to unit length.\n         */\n        normalize() {\n            if (this.Length === 0) {\n                return;\n            }\n            this.times(1 / this.length());\n        }\n        /**\n         * Creates an inverted version of this translation transformation.\n         * @returns A new Translation with inverted offsets\n         */\n        invert() {\n            return new Translation(-this.x, -this.y);\n        }\n    }\n\n    /**\n     * A composite transformation that combines translation, rotation, and scaling operations.\n     * Provides methods to apply multiple transformations as a single matrix operation.\n     */\n    class CompositeTransform {\n        /**\n         * Creates a new CompositeTransform instance.\n         * @param x The x translation offset\n         * @param y The y translation offset\n         * @param scaleX The x scaling factor\n         * @param scaleY The y scaling factor\n         * @param angle The rotation angle in radians\n         * @param center The center point for rotation\n         */\n        constructor(x, y, scaleX, scaleY, angle, center) {\n            this.translate = new Translation(x, y);\n            if (scaleX !== undefined && scaleY !== undefined) {\n                this.scale = new Scale(scaleX, scaleY);\n            }\n            if (angle !== undefined) {\n                this.rotate = center ? new Rotation(angle, center.x, center.y) : new Rotation(angle);\n            }\n        }\n        /**\n         * Returns a string representation of the composite transformation.\n         * @returns String representation of all transformations\n         */\n        toString() {\n            const toString = function (transform) {\n                return transform ? transform.toString() : '';\n            };\n            return toString(this.translate) +\n                toString(this.rotate) +\n                toString(this.scale);\n        }\n        /**\n         * Renders the transformation by applying it to a visual element.\n         * @param visual The visual element to apply the transformation to\n         */\n        render(visual) {\n            visual._transform = this;\n            visual._renderTransform();\n        }\n        /**\n         * Converts the composite transformation to a matrix representation.\n         * @returns A matrix representing the combined transformations\n         */\n        toMatrix() {\n            let m = Matrix.unit();\n            if (this.translate) {\n                m = m.times(this.translate.toMatrix());\n            }\n            if (this.rotate) {\n                m = m.times(this.rotate.toMatrix());\n            }\n            if (this.scale) {\n                m = m.times(this.scale.toMatrix());\n            }\n            return m;\n        }\n        /**\n         * Creates an inverted version of this composite transformation.\n         * @returns A new CompositeTransform that represents the inverse transformation\n         */\n        invert() {\n            const rotate = this.rotate ? this.rotate.invert() : undefined, rotateMatrix = rotate ? rotate.toMatrix() : Matrix.unit(), scale = this.scale ? this.scale.invert() : undefined, scaleMatrix = scale ? scale.toMatrix() : Matrix.unit();\n            let translatePoint = new Point(-this.translate.x, -this.translate.y);\n            translatePoint = rotateMatrix.times(scaleMatrix).apply(translatePoint);\n            const translate = new Translation(translatePoint.x, translatePoint.y);\n            const transform = new CompositeTransform();\n            transform.translate = translate;\n            transform.rotate = rotate;\n            transform.scale = scale;\n            return transform;\n        }\n    }\n\n    /**\n     * Compares numeric options and updates element options if they have changed.\n     * @param options - The new options to compare against\n     * @param fields - Array of field names to check for changes\n     * @returns True if any numeric options have changed, false otherwise\n     */\n    function diffNumericOptions(options, fields) {\n        const elementOptions = this.options;\n        let hasChanges = false;\n        let value, field;\n        for (let i = 0; i < fields.length; i++) {\n            field = fields[i];\n            value = options[field];\n            if (isNumber(value) && elementOptions[field] !== value) {\n                elementOptions[field] = value;\n                hasChanges = true;\n            }\n        }\n        return hasChanges;\n    }\n\n    /**\n     * Base class for all visual elements in the diagram system.\n     * Provides core functionality for positioning, transformation, and drawing operations.\n     */\n    class Element {\n        /**\n         * Creates a new Element instance.\n         * @param options Configuration options for the element\n         */\n        constructor(options) {\n            this.options = deepExtend({}, this.options, options);\n            this.id = this.options.id;\n            this._originSize = Rect.empty();\n            this._transform = new CompositeTransform();\n        }\n        /**\n         * Gets or sets the visibility of the element.\n         * @param value The visibility value to set, or undefined to get current visibility\n         * @returns The current visibility state when called as getter\n         */\n        visible(value) {\n            return this.drawingContainer().visible(value);\n        }\n        /**\n         * Redraws the element with updated options.\n         * @param options New options to apply to the element\n         */\n        redraw(options) {\n            if (options && options.id) {\n                this.id = options.id;\n            }\n        }\n        /**\n         * Gets or sets the position of the element.\n         * @param x The x coordinate or Point object, or undefined to get current position\n         * @param y The y coordinate when x is a number\n         * @returns The current position as a Point when called as getter\n         */\n        position(x, y) {\n            const options = this.options;\n            if (!defined(x)) {\n                return new Point(options.x, options.y);\n            }\n            if (defined(y)) {\n                options.x = x;\n                options.y = y;\n            }\n            else if (x instanceof Point) {\n                options.x = x.x;\n                options.y = x.y;\n            }\n            this._transform.translate = new Translation(options.x, options.y);\n            this._renderTransform();\n        }\n        /**\n         * Gets or sets the rotation of the element.\n         * @param angle The rotation angle in radians, or undefined to get current rotation\n         * @param center The center point for rotation\n         * @returns The current rotation when called as getter\n         */\n        rotate(angle, center) {\n            if (defined(angle)) {\n                this._transform.rotate = new Rotation(angle, center.x, center.y);\n                this._renderTransform();\n            }\n            return this._transform.rotate || Rotation.ZERO;\n        }\n        /**\n         * Gets the drawing container for this element.\n         * @returns The drawing element container\n         */\n        drawingContainer() {\n            return this.drawingElement;\n        }\n        /** @hidden */\n        _renderTransform() {\n            const matrix = this._transform.toMatrix();\n            this.drawingContainer().transform(new kendo_drawing_cmn_chunk_js.M(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f));\n        }\n        /** @hidden */\n        _hover() { }\n        /** @hidden */\n        _diffNumericOptions(options, fields) {\n            return diffNumericOptions.call(this, options, fields);\n        }\n        /** @hidden */\n        _measure(force) {\n            let rect;\n            if (!this._measured || force) {\n                const box = this._boundingBox() || new kendo_drawing_cmn_chunk_js.R([0, 0], [0, 0]);\n                const startPoint = box.topLeft();\n                rect = new Rect(startPoint.x, startPoint.y, box.width(), box.height());\n                this._originSize = rect;\n                this._originWidth = rect.width;\n                this._originHeight = rect.height;\n                this._measured = true;\n            }\n            else {\n                rect = this._originSize;\n            }\n            return rect;\n        }\n        /** @hidden */\n        _boundingBox() {\n            return this.drawingElement.rawBBox();\n        }\n    }\n\n    /**\n     * Gets size options from configuration or returns default values.\n     * @param options - The options object to extract size values from\n     * @returns An object containing x, y, width, and height values\n     */\n    function sizeOptionsOrDefault(options) {\n        return {\n            x: options.x || 0,\n            y: options.y || 0,\n            width: options.width || 0,\n            height: options.height || 0\n        };\n    }\n    /**\n     * Normalizes drawing options to ensure consistent format.\n     * @param options - The drawing options to normalize\n     * @returns Normalized drawing options with proper color format\n     */\n    function normalizeDrawingOptions(options) {\n        if (options) {\n            let drawingOptions = options;\n            if (isString$1(drawingOptions)) {\n                drawingOptions = {\n                    color: drawingOptions\n                };\n            }\n            if (drawingOptions.color) {\n                drawingOptions.color = getColor(drawingOptions.color);\n            }\n            return drawingOptions;\n        }\n    }\n    /**\n     * Converts a color value to a proper hex color format.\n     * @param value - The color value to convert\n     * @returns The converted color in hex format or the original value for transparent\n     */\n    function getColor(value) {\n        let color;\n        if (value !== TRANSPARENT) {\n            color = new kendo_drawing_cmn_chunk_js.C(value).toHex();\n        }\n        else {\n            color = value;\n        }\n        return color;\n    }\n    /**\n     * Calculates the angle of a line between two points.\n     * @param p1 - The first point\n     * @param p2 - The second point\n     * @returns The angle in degrees between the two points\n     */\n    function lineAngle(p1, p2) {\n        const xDiff = p2.x - p1.x;\n        const yDiff = p2.y - p1.y;\n        const angle = kendo_drawing_cmn_chunk_js.q(Math.atan2(yDiff, xDiff));\n        return angle;\n    }\n    /**\n     * Creates a path segment from x and y coordinates.\n     * @param x - The x coordinate\n     * @param y - The y coordinate\n     * @returns A new path segment\n     */\n    function createSegment(x, y) {\n        return new kendo_drawing_cmn_chunk_js.S(new kendo_drawing_cmn_chunk_js.P(x, y));\n    }\n    /**\n     * Converts a rectangle to a drawing rectangle format.\n     * @param rect - The rectangle to convert\n     * @returns A drawing rectangle or undefined if rect is not provided\n     */\n    function toDrawingRect(rect) {\n        if (rect) {\n            return new kendo_drawing_cmn_chunk_js.R([rect.x, rect.y], [rect.width, rect.height]);\n        }\n    }\n    /**\n     * Removes all child elements from a DOM element.\n     * @param element - The DOM element to remove children from\n     */\n    function removeChildren$1(element) {\n        while (element.firstChild) {\n            element.removeChild(element.firstChild);\n        }\n    }\n    /**\n     * Gets spacing values from a number or spacing object.\n     * @param value - The spacing value as number or object with side-specific values\n     * @param defaultSpacing - Default spacing value to use for undefined sides\n     * @returns A complete spacing object with values for all four sides\n     */\n    function getSpacing(value, defaultSpacing = 0) {\n        const spacing = { top: 0, right: 0, bottom: 0, left: 0 };\n        if (typeof value === 'number') {\n            spacing.top = spacing.right = spacing.bottom = spacing.left = value;\n        }\n        else {\n            spacing.top = value.top || defaultSpacing;\n            spacing.right = value.right || defaultSpacing;\n            spacing.bottom = value.bottom || defaultSpacing;\n            spacing.left = value.left || defaultSpacing;\n        }\n        return spacing;\n    }\n    /**\n     * Draws a polygon with rounded corners.\n     * @param path - The path or multipath to draw on\n     * @param points - Array of points defining the polygon vertices\n     * @param r - Corner radius value or array of radius values per vertex\n     */\n    const drawRoundedPolygon = (path, points, r) => {\n        const n = points.length;\n        for (let i = 0; i < n; i++) {\n            const prev = points[(i + n - 1) % n];\n            const curr = points[i];\n            const next = points[(i + 1) % n];\n            const cornerRadius = Array.isArray(r) ? r[i] : r;\n            // --- vectors from the vertex to the neighbors ---\n            const v1 = { x: prev.x - curr.x, y: prev.y - curr.y };\n            const v2 = { x: next.x - curr.x, y: next.y - curr.y };\n            const len1 = Math.hypot(v1.x, v1.y);\n            const len2 = Math.hypot(v2.x, v2.y);\n            // --- internal angle  (phi) ---\n            const cosPhi = (v1.x * v2.x + v1.y * v2.y) / (len1 * len2);\n            const phi = Math.acos(Math.max(-1, Math.min(1, cosPhi))); // clamp for safety\n            // --- distance s = r / tan(/2) ---\n            const ds = cornerRadius / Math.tan(phi / 2);\n            // --- clamp if the side is too short ---\n            const dsClamped = Math.min(ds, len1 - 1e-3, len2 - 1e-3);\n            // --- tangent points ---\n            const start = {\n                x: curr.x + (v1.x / len1) * dsClamped,\n                y: curr.y + (v1.y / len1) * dsClamped\n            };\n            const end = {\n                x: curr.x + (v2.x / len2) * dsClamped,\n                y: curr.y + (v2.y / len2) * dsClamped\n            };\n            // --- first / next segments ---\n            if (i === 0) {\n                path.moveTo(start.x, start.y);\n            }\n            else {\n                path.lineTo(start.x, start.y);\n            }\n            // --- direction of the arc (CW / CCW) ---\n            const cross = v1.x * v2.y - v1.y * v2.x; // z-component\n            const sweep = cross < 0; // for CW sweep (Canvas Y axis down)\n            // --- always the short arc (largeArc = false) ---\n            path.arcTo([end.x, end.y], cornerRadius, cornerRadius, /*largeArc*/ false, sweep);\n        }\n        path.close();\n    };\n    /**\n     * Draws a polygon by connecting a series of points.\n     * @param path - The path or multipath to draw on\n     * @param points - Array of points defining the polygon vertices\n     */\n    const drawPolygon = (path, points) => {\n        const n = points.length;\n        for (let i = 0; i < n; i++) {\n            const point = points[i];\n            if (i === 0) {\n                path.moveTo(point.x, point.y);\n            }\n            else {\n                path.lineTo(point.x, point.y);\n            }\n        }\n        path.close();\n    };\n    /**\n     * Scales and positions a drawing element to fit within specified dimensions.\n     * @param drawingElement - The path or multipath element to fit\n     * @param width - Target width\n     * @param height - Target height\n     * @param strokeWidth - Stroke width to account for in sizing\n     */\n    const fitToSize = (drawingElement, width, height, strokeWidth) => {\n        const bb = drawingElement.bbox();\n        if (!bb.size.width || !bb.size.height) {\n            return;\n        }\n        const targetW = width + strokeWidth;\n        const targetH = height + strokeWidth;\n        const sx = targetW / bb.size.width;\n        const sy = targetH / bb.size.height;\n        drawingElement.transform(new kendo_drawing_cmn_chunk_js.v(new kendo_drawing_cmn_chunk_js.M(sx, 0, 0, sy, -bb.origin.x * sx, -bb.origin.y * sy)));\n    };\n    /**\n     * Inflates (expands outward) a polygon by moving each vertex along the external bisector.\n     * @param points - Array of points defining the polygon vertices\n     * @param r - Inflation radius value or array of radius values per vertex\n     * @returns Array of inflated polygon points\n     */\n    function inflatePolygon(points, r) {\n        const n = points.length;\n        const out = [];\n        for (let i = 0; i < n; i++) {\n            const prev = points[(i + n - 1) % n];\n            const curr = points[i];\n            const next = points[(i + 1) % n];\n            const radius = Array.isArray(r) ? r[i] : r;\n            // --- vectors to the neighbors ---\n            const v1 = { x: prev.x - curr.x, y: prev.y - curr.y };\n            const v2 = { x: next.x - curr.x, y: next.y - curr.y };\n            const len1 = Math.hypot(v1.x, v1.y);\n            const len2 = Math.hypot(v2.x, v2.y);\n            // --- normalized ---\n            const n1 = { x: v1.x / len1, y: v1.y / len1 };\n            const n2 = { x: v2.x / len2, y: v2.y / len2 };\n            // --- internal angle  (phi) ---\n            const phi = Math.acos(Math.max(-1, Math.min(1, n1.x * n2.x + n1.y * n2.y)));\n            // --- distance  along the external bisector ---\n            const delta = radius / Math.sin(phi / 2) - radius;\n            // --- internal bisector ---\n            let b = { x: n1.x + n2.x, y: n1.y + n2.y };\n            const bLen = Math.hypot(b.x, b.y);\n            b = { x: b.x / bLen, y: b.y / bLen };\n            // --- external bisector = -internal bisector (for clockwise polygon) ---\n            const outDir = { x: -b.x, y: -b.y };\n            out.push({\n                x: curr.x + outDir.x * delta,\n                y: curr.y + outDir.y * delta\n            });\n        }\n        return out;\n    }\n\n    const defaultOptions$m = {\n        stroke: {\n            color: 'gray',\n            width: 1\n        },\n        fill: {\n            color: TRANSPARENT\n        }\n    };\n    /**\n     * Base class for visual elements that can be rendered with fill and stroke properties.\n     * Extends Element and provides common functionality for visual styling and drawing operations.\n     */\n    class VisualBase extends Element {\n        /**\n         * Creates a new VisualBase instance.\n         * @param options Configuration options for the visual element\n         */\n        constructor(options) {\n            options = deepExtend({}, defaultOptions$m, options);\n            super(options);\n            options = this.options;\n            options.fill = normalizeDrawingOptions(options.fill);\n            options.stroke = normalizeDrawingOptions(options.stroke);\n        }\n        /**\n         * Sets the fill color and opacity of the visual element.\n         * @param color The fill color\n         * @param opacity The fill opacity (optional)\n         */\n        fill(color, opacity) {\n            this._fill({\n                color: getColor(color),\n                opacity: opacity\n            });\n        }\n        /**\n         * Sets the stroke color, width, and opacity of the visual element.\n         * @param color The stroke color\n         * @param width The stroke width\n         * @param opacity The stroke opacity\n         */\n        stroke(color, width, opacity) {\n            this._stroke({\n                color: getColor(color),\n                width: width,\n                opacity: opacity\n            });\n        }\n        /**\n         * Redraws the visual element with updated options.\n         * @param options New options to apply to the visual element\n         */\n        redraw(options) {\n            if (options) {\n                const stroke = options.stroke;\n                const fill = options.fill;\n                if (stroke) {\n                    this._stroke(normalizeDrawingOptions(stroke));\n                }\n                if (fill) {\n                    this._fill(normalizeDrawingOptions(fill));\n                }\n                super.redraw(options);\n            }\n        }\n        /** @hidden */\n        _hover(show) {\n            const options = this.options;\n            const hover = options.hover;\n            if (hover && hover.fill) {\n                const fill = show ? normalizeDrawingOptions(hover.fill) : options.fill;\n                this._setFill(fill);\n            }\n        }\n        /** @hidden */\n        _setFill(fill) {\n            this.drawingElement.fill(fill.color, fill.opacity);\n        }\n        /** @hidden */\n        _evalStrokeOptions(strokeOptions) {\n            const options = this.options;\n            deepExtend(options, {\n                stroke: strokeOptions\n            });\n            strokeOptions = options.stroke;\n            let stroke = null;\n            if (strokeOptions.width > 0) {\n                stroke = {\n                    color: strokeOptions.color,\n                    width: strokeOptions.width,\n                    opacity: strokeOptions.opacity,\n                    dashType: strokeOptions.dashType\n                };\n            }\n            return stroke;\n        }\n        /** @hidden */\n        _evalFillOptions(fillOptions) {\n            const options = this.options;\n            deepExtend(options, {\n                fill: fillOptions || {}\n            });\n            return options.fill;\n        }\n        /** @hidden */\n        _stroke(strokeOptions) {\n            const stroke = this._evalStrokeOptions(strokeOptions);\n            this.drawingElement.options.set('stroke', stroke);\n        }\n        /** @hidden */\n        _fill(fillOptions) {\n            const fill = this._evalFillOptions(fillOptions);\n            if (fill.gradient) {\n                const gradient = fill.gradient;\n                const GradientClass = (gradient.type === 'radial' ? kendo_drawing_cmn_chunk_js.h : kendo_drawing_cmn_chunk_js.L);\n                this.drawingElement.fill(new GradientClass(gradient));\n            }\n            else {\n                this.drawingElement.fill(fill.color, fill.opacity);\n            }\n        }\n    }\n\n    const defaultOptions$l = {\n        stroke: {\n            color: TRANSPARENT,\n            width: 0\n        },\n        fill: {\n            color: 'black'\n        }\n    };\n    /**\n     * Base class for visual markers that can be positioned on paths.\n     * Extends VisualBase and provides common functionality for marker positioning and transformation.\n     */\n    class MarkerBase extends VisualBase {\n        /**\n         * Creates a new MarkerBase instance.\n         * @param options Configuration options for the marker\n         */\n        constructor(options) {\n            options = deepExtend({}, defaultOptions$l, options);\n            super(options);\n            const anchor = this.options.anchor || {};\n            this.anchor = new kendo_drawing_cmn_chunk_js.P(anchor.x, anchor.y);\n            this.createElement();\n        }\n        /**\n         * Creates the drawing element for the marker. Should be overridden by subclasses.\n         */\n        createElement() { }\n        /** @hidden */\n        _transformToPath(point, path) {\n            const transform = path.transform();\n            if (point && transform) {\n                point = point.transformCopy(transform);\n            }\n            return point;\n        }\n        /**\n         * Redraws the marker with updated options.\n         * @param options New options to apply to the marker\n         */\n        redraw(options) {\n            if (options) {\n                if (options.position) {\n                    this.options.position = options.position;\n                }\n                super.redraw(options);\n            }\n        }\n    }\n\n    /**\n     * An object that defines the default options for the arrow marker.\n     */\n    const defaultArrowOptions = {\n        path: 'M 0 0 L 10 5 L 0 10 L 3 5 z',\n        anchor: {\n            x: 10,\n            y: 5\n        }\n    };\n    /**\n     * An object that defines the line arrow options for the arrow marker.\n     */\n    const lineArrowOptions = {\n        path: 'M 0 0 L 8 7 L 0 14',\n        anchor: {\n            x: 8,\n            y: 7\n        },\n        fill: null,\n        stroke: {\n            color: '#000',\n            lineCap: 'round',\n            lineJoin: 'round',\n            width: 1\n        }\n    };\n    /**\n     * An object that defines the triangle arrow options for the arrow marker.\n     */\n    const triangleArrowOptions = {\n        path: 'M 0 0 L 8.5 5 L 0 10 L 0 0 z',\n        anchor: {\n            x: 8.5,\n            y: 5\n        }\n    };\n    /**\n     * A visual marker that renders an arrow shape at the start or end of a path.\n     * Extends MarkerBase to provide arrow-specific positioning and rendering functionality.\n     */\n    class ArrowMarker extends MarkerBase {\n        /**\n         * Creates a new ArrowMarker instance.\n         * @param options Configuration options for the arrow marker\n         */\n        constructor(options) {\n            options = deepExtend({}, defaultArrowOptions, options);\n            super(options);\n        }\n        /**\n         * Creates the drawing element for the arrow marker.\n         */\n        createElement() {\n            const options = this.options;\n            this.drawingElement = kendo_drawing_cmn_chunk_js.a.parse(options.path, {\n                fill: options.fill,\n                stroke: options.stroke\n            });\n        }\n        /**\n         * Positions the arrow marker on the specified path.\n         * @param path The path on which to position the arrow marker\n         */\n        positionMarker(path) {\n            const points = this._linePoints(path);\n            const start = points.start;\n            const end = points.end;\n            const transform$1 = kendo_drawing_cmn_chunk_js.t();\n            if (start) {\n                transform$1.rotate(lineAngle(start, end), end);\n            }\n            if (end) {\n                const anchor = this.anchor;\n                const translate = end.clone().translate(-anchor.x, -anchor.y);\n                transform$1.translate(translate.x, translate.y);\n            }\n            this.drawingElement.transform(transform$1);\n        }\n        /** @hidden */\n        _linePoints(path) {\n            const options = this.options;\n            const segments = path.segments;\n            let startPoint, endPoint, targetSegment;\n            if (options.position === START$1) {\n                targetSegment = segments[0];\n                if (targetSegment) {\n                    endPoint = targetSegment.anchor();\n                    startPoint = targetSegment.controlOut();\n                    const nextSegment = segments[1];\n                    if (!startPoint && nextSegment) {\n                        startPoint = nextSegment.anchor();\n                    }\n                }\n            }\n            else {\n                targetSegment = segments[segments.length - 1];\n                if (targetSegment) {\n                    endPoint = targetSegment.anchor();\n                    startPoint = targetSegment.controlIn();\n                    const prevSegment = segments[segments.length - 2];\n                    if (!startPoint && prevSegment) {\n                        startPoint = prevSegment.anchor();\n                    }\n                }\n            }\n            if (endPoint) {\n                return {\n                    start: this._transformToPath(startPoint, path),\n                    end: this._transformToPath(endPoint, path)\n                };\n            }\n        }\n    }\n\n    /**\n     * A canvas that provides a drawing surface for rendering visual elements.\n     * Manages the underlying drawing surface and provides methods for drawing operations.\n     */\n    let Canvas$1 = class Canvas {\n        /**\n         * Creates a new Canvas instance.\n         * @param element The HTML element to attach the canvas to\n         * @param options Configuration options for the canvas\n         */\n        constructor(element, options) {\n            /** @hidden */\n            this._translate = (x, y) => {\n                const viewBox = this._viewBox;\n                if (defined(x) && defined(y)) {\n                    viewBox.x = x;\n                    viewBox.y = y;\n                    this.surface.translate({ x: x, y: y });\n                }\n                return {\n                    x: viewBox.x,\n                    y: viewBox.y\n                };\n            };\n            this.element = element;\n            this.surface = kendo_drawing_cmn_chunk_js.k.create(element, options);\n            if (isFunction$1(this.surface.translate)) {\n                this.translate = this._translate;\n            }\n            this.drawingElement = new kendo_drawing_cmn_chunk_js.G();\n            this._viewBox = new Rect(0, 0, options.width, options.height);\n            this.size(this._viewBox);\n        }\n        /**\n         * Gets the bounding box of all drawing elements on the canvas.\n         * @returns A rectangle representing the bounds of the canvas content\n         */\n        bounds() {\n            const box = this.drawingElement.clippedBBox();\n            return new Rect(0, 0, box.width(), box.height());\n        }\n        /**\n         * Gets or sets the size of the canvas.\n         * @param size The size to set, or undefined to get current size\n         * @returns The current size when called as getter\n         */\n        size(size) {\n            const viewBox = this._viewBox;\n            if (defined(size)) {\n                viewBox.width = size.width;\n                viewBox.height = size.height;\n                this.surface.setSize(size);\n            }\n            return {\n                width: viewBox.width,\n                height: viewBox.height\n            };\n        }\n        /**\n         * Draws all visual elements to the canvas surface.\n         */\n        draw() {\n            this.surface.draw(this.drawingElement);\n        }\n        /**\n         * Appends a visual element to the canvas.\n         * @param visual The visual element to append\n         * @returns The canvas instance for method chaining\n         */\n        append(visual) {\n            this.drawingElement.append(visual.drawingContainer());\n            return this;\n        }\n        /**\n         * Removes a visual element from the canvas.\n         * @param visual The visual element to remove\n         */\n        remove(visual) {\n            this.drawingElement.remove(visual.drawingContainer());\n        }\n        /**\n         * Inserts a visual element before another element (currently not implemented).\n         */\n        insertBefore() { }\n        /**\n         * Clears all visual elements from the canvas.\n         */\n        clear() {\n            this.drawingElement.clear();\n        }\n        /**\n         * Destroys the canvas and optionally removes the HTML element.\n         * @param clearHtml Whether to remove the HTML element from the DOM\n         */\n        destroy(clearHtml) {\n            this.surface.destroy();\n            if (clearHtml) {\n                removeChildren$1(this.element);\n                this.element.remove();\n            }\n        }\n    };\n\n    /**\n     * Mixin that provides automatic sizing and positioning capabilities for visual elements.\n     * Can be mixed into classes to add automatic scaling and translation functionality.\n     */\n    const AutoSizeableMixin = {\n        /**\n         * @hidden\n         * Sets the scale transformation based on the difference between original and target dimensions.\n         */\n        _setScale: function () {\n            const options = this.options;\n            const originWidth = this._originWidth;\n            const originHeight = this._originHeight;\n            let scaleX = options.width / originWidth;\n            let scaleY = options.height / originHeight;\n            if (!isNumber(scaleX)) {\n                scaleX = 1;\n            }\n            if (!isNumber(scaleY)) {\n                scaleY = 1;\n            }\n            this._transform.scale = new Scale(scaleX, scaleY);\n        },\n        /**\n         * @hidden\n         * Sets the translation transformation based on x and y position options.\n         */\n        _setTranslate: function () {\n            const options = this.options;\n            const x = options.x || 0;\n            const y = options.y || 0;\n            this._transform.translate = new Translation(x, y);\n        },\n        /**\n         * @hidden\n         * Initializes the element size by setting up scaling and translation transforms.\n         */\n        _initSize: function () {\n            const options = this.options;\n            let transform = false;\n            if (options.autoSize !== false && (isDefined(options.width) || isDefined(options.height))) {\n                this._measure(true);\n                this._setScale();\n                transform = true;\n            }\n            if (isDefined(options.x) || isDefined(options.y)) {\n                this._setTranslate();\n                transform = true;\n            }\n            if (transform) {\n                this._renderTransform();\n            }\n        },\n        /**\n         * @hidden\n         * Updates the element size and position based on new options.\n         * @param options - The new options to apply\n         * @returns True if the element was updated, false otherwise\n         */\n        _updateSize: function (options) {\n            let update = false;\n            if (this.options.autoSize !== false && this._diffNumericOptions(options, [WIDTH, HEIGHT])) {\n                update = true;\n                this._measure(true);\n                this._setScale();\n            }\n            if (this._diffNumericOptions(options, [X, Y])) {\n                update = true;\n                this._setTranslate();\n            }\n            if (update) {\n                this._renderTransform();\n            }\n            return update;\n        }\n    };\n\n    /**\n     * A visual element that renders a circle shape.\n     * Extends VisualBase and provides functionality for creating and managing circular graphics.\n     */\n    class Circle extends VisualBase {\n        /**\n         * Creates a new Circle instance.\n         * @param options Configuration options for the circle\n         */\n        constructor(options) {\n            super(options);\n            // Bind mixin methods to current instance\n            this._setScale = AutoSizeableMixin._setScale.bind(this);\n            this._setTranslate = AutoSizeableMixin._setTranslate.bind(this);\n            this._initSize = AutoSizeableMixin._initSize.bind(this);\n            this._updateSize = AutoSizeableMixin._updateSize.bind(this);\n            this._initCircle();\n            this._initSize();\n        }\n        /**\n         * Redraws the circle with updated options.\n         * @param options New options to apply to the circle\n         */\n        redraw(options) {\n            if (options) {\n                const circleOptions = this.options;\n                if (options.center) {\n                    deepExtend(circleOptions, {\n                        center: options.center\n                    });\n                    this._center.move(circleOptions.center.x, circleOptions.center.y);\n                }\n                if (this._diffNumericOptions(options, ['radius'])) {\n                    this._circle.setRadius(circleOptions.radius);\n                }\n                this._updateSize(options);\n                super.redraw.call(this, options);\n            }\n        }\n        /** @hidden */\n        _initCircle() {\n            const options = this.options;\n            let width = options.width;\n            let height = options.height;\n            let radius = options.radius;\n            if (!defined(radius)) {\n                if (!defined(width)) {\n                    width = height;\n                }\n                if (!defined(height)) {\n                    height = width;\n                }\n                options.radius = radius = Math.min(width, height) / 2;\n            }\n            const center = options.center || { x: radius, y: radius };\n            this._center = new kendo_drawing_cmn_chunk_js.P(center.x, center.y);\n            this._circle = new kendo_drawing_cmn_chunk_js.f(this._center, radius);\n            this.drawingElement = new kendo_drawing_cmn_chunk_js.e(this._circle, {\n                stroke: options.stroke\n            });\n            this._fill();\n        }\n    }\n\n    const defaultOptions$k = {\n        radius: 4,\n        anchor: {\n            x: 0,\n            y: 0\n        }\n    };\n    /**\n     * A visual marker that renders a circle shape at the start or end of a path.\n     * Extends MarkerBase to provide circle-specific positioning and rendering functionality.\n     */\n    class CircleMarker extends MarkerBase {\n        /**\n         * Creates a new CircleMarker instance.\n         * @param options Configuration options for the circle marker\n         */\n        constructor(options) {\n            options = deepExtend({}, defaultOptions$k, options);\n            super(options);\n        }\n        /**\n         * Creates the drawing element for the circle marker.\n         */\n        createElement() {\n            const options = this.options;\n            this.drawingElement = new kendo_drawing_cmn_chunk_js.e(new kendo_drawing_cmn_chunk_js.f(this.anchor, options.radius), {\n                fill: options.fill,\n                stroke: options.stroke\n            });\n        }\n        /**\n         * Positions the circle marker on the specified path.\n         * @param path The path on which to position the circle marker\n         */\n        positionMarker(path) {\n            const options = this.options;\n            const position = options.position;\n            const segments = path.segments;\n            let targetSegment;\n            let point;\n            if (position === START$1) {\n                targetSegment = segments[0];\n            }\n            else {\n                targetSegment = segments[segments.length - 1];\n            }\n            if (targetSegment) {\n                point = this._transformToPath(targetSegment.anchor(), path);\n                this.drawingElement.transform(kendo_drawing_cmn_chunk_js.t().translate(point.x, point.y));\n            }\n        }\n    }\n\n    /**\n     * A visual element that renders a rectangle shape.\n     * Extends VisualBase and provides functionality for creating and managing rectangular graphics.\n     */\n    class Rectangle extends VisualBase {\n        /**\n         * Creates a new Rectangle instance.\n         * @param options Configuration options for the rectangle\n         */\n        constructor(options) {\n            super(options);\n            this._initPath();\n            this._setPosition();\n        }\n        /** @hidden */\n        _setPosition() {\n            const options = this.options;\n            const x = options.x;\n            const y = options.y;\n            if (defined(x) || defined(y)) {\n                this.position(x || 0, y || 0);\n            }\n        }\n        /**\n         * Redraws the rectangle with updated options.\n         * @param options New options to apply to the rectangle\n         */\n        redraw(options) {\n            if (options) {\n                super.redraw(options);\n                if (this._diffNumericOptions(options, [WIDTH, HEIGHT])) {\n                    this._drawPath();\n                }\n                if (this._diffNumericOptions(options, [X, Y])) {\n                    this._setPosition();\n                }\n            }\n        }\n        /** @hidden */\n        _initPath() {\n            const options = this.options;\n            this.drawingElement = new kendo_drawing_cmn_chunk_js.a({\n                stroke: options.stroke\n            });\n            this._fill();\n            this._drawPath();\n        }\n        /** @hidden */\n        _drawPath() {\n            const { width, height } = sizeOptionsOrDefault(this.options);\n            const drawingElement = this.drawingElement;\n            const points = [\n                { x: 0, y: 0 },\n                { x: width, y: 0 },\n                { x: width, y: height },\n                { x: 0, y: height }\n            ];\n            if (this.options.cornerRadius > 0) {\n                drawRoundedPolygon(drawingElement, points, this.options.cornerRadius);\n            }\n            else {\n                drawPolygon(drawingElement, points);\n            }\n        }\n    }\n\n    /**\n     * @hidden\n     *\n     * A base class for shapes that require multiple path elements for rendering.\n     * Extends Rectangle and provides functionality for complex shapes with multiple drawing paths.\n     */\n    class MultiPathShape extends Rectangle {\n        /** @hidden */\n        _initPath() {\n            const options = this.options;\n            this.drawingElement = new kendo_drawing_cmn_chunk_js.g({\n                stroke: options.stroke\n            });\n            this._fill();\n            this._drawPath();\n        }\n    }\n\n    const defaultOptions$j = {\n        shapesOffsetRatio: 0.025,\n    };\n    /**\n     * Represents a Collate shape, a flowchart element used to indicate collating or gathering operations.\n     * Extends MultiPathShape with two triangular shapes arranged in an hourglass pattern.\n     */\n    class Collate extends MultiPathShape {\n        /**\n         * Creates a new Collate instance.\n         * @param options - Configuration options for the collate shape\n         */\n        constructor(options) {\n            super({ ...defaultOptions$j, ...options });\n        }\n        /**\n         * @hidden\n         * Draws the collate shape path as two triangular shapes forming an hourglass.\n         */\n        _drawPath() {\n            const drawingElement = this.drawingElement;\n            const { width, height } = sizeOptionsOrDefault(this.options);\n            const cornerRadius = this.options.cornerRadius;\n            const strokeWidth = this.options.stroke.width || 0;\n            const shapesOffset = height * this.options.shapesOffsetRatio - cornerRadius / 2;\n            const halfWidth = width / 2;\n            const halfHeight = height / 2;\n            const firstShape = [\n                { x: halfWidth, y: halfHeight - shapesOffset },\n                { x: 0, y: 0 },\n                { x: width, y: 0 },\n            ];\n            drawRoundedPolygon(drawingElement, firstShape, [cornerRadius / 3, cornerRadius, cornerRadius]);\n            const secondShape = [\n                { x: halfWidth, y: halfHeight + shapesOffset },\n                { x: width, y: height },\n                { x: 0, y: height }\n            ];\n            drawRoundedPolygon(drawingElement, secondShape, [cornerRadius / 3, cornerRadius, cornerRadius]);\n            fitToSize(drawingElement, width, height, strokeWidth);\n        }\n    }\n\n    /**\n     * Represents an On-Page Connector shape, a flowchart element used to indicate continuation\n     * of a flowchart on the same page. Extends the Rectangle class with a custom circular path.\n     */\n    class OnPageConnector extends Rectangle {\n        /**\n         * @hidden\n         * Draws the on-page connector shape path as a circle with arcs.\n         */\n        _drawPath() {\n            const drawingElement = this.drawingElement;\n            const { width, height } = sizeOptionsOrDefault(this.options);\n            const centerX = width / 2;\n            const radius = (Math.min(width, height) / 2);\n            drawingElement\n                .moveTo([centerX, 0])\n                .arcTo([centerX, height], radius, radius, false, true)\n                .arcTo([centerX, 0], radius, radius, false, true);\n        }\n    }\n\n    const defaultOptions$i = {\n        slantRatio: 0.15\n    };\n    /**\n     * Represents a Data Input/Output shape, a flowchart element used to indicate\n     * data input or output operations. Extends Rectangle with a parallelogram path.\n     */\n    class DataInputOutput extends Rectangle {\n        /**\n         * Creates a new DataInputOutput instance.\n         * @param options - Configuration options for the data input/output shape\n         */\n        constructor(options) {\n            super({ ...defaultOptions$i, ...options });\n        }\n        /**\n         * @hidden\n         * Draws the data input/output shape path as a parallelogram.\n         */\n        _drawPath() {\n            const drawingElement = this.drawingElement;\n            const { width, height } = sizeOptionsOrDefault(this.options);\n            const strokeWidth = this.options.stroke.width || 0;\n            const { slantRatio, cornerRadius } = this.options;\n            const slant = width * slantRatio;\n            const points = [\n                { x: slant, y: 0 },\n                { x: width, y: 0 },\n                { x: width - slant, y: height },\n                { x: 0, y: height }\n            ];\n            drawRoundedPolygon(drawingElement, points, cornerRadius);\n            fitToSize(drawingElement, width, height, strokeWidth);\n        }\n    }\n\n    const defaultOptions$h = {\n        ellipseRxRatio: 0.5,\n        ellipseRyRatio: 0.2\n    };\n    /**\n     * A visual element that renders a database symbol with cylindrical appearance.\n     * Extends Rectangle and provides functionality for creating database storage shapes with elliptical top and bottom.\n     */\n    class Database extends Rectangle {\n        /**\n         * Creates a new Database instance.\n         * @param options Configuration options for the database shape\n         */\n        constructor(options) {\n            super({ ...defaultOptions$h, ...options });\n        }\n        /** @hidden */\n        _drawPath() {\n            const drawingElement = this.drawingElement;\n            const { width, height } = sizeOptionsOrDefault(this.options);\n            const strokeWidth = this.options.stroke.width || 0;\n            const rx = width * this.options.ellipseRxRatio;\n            const ellipseRY = height * this.options.ellipseRyRatio;\n            const cy = ellipseRY;\n            const ry = ellipseRY;\n            drawingElement\n                .moveTo([width, cy])\n                .arcTo([0, cy], rx, ry, false, true)\n                .arcTo([width, cy], rx, ry, false, true)\n                .lineTo([width, height])\n                .arcTo([0, height], rx, ry, false, true)\n                .lineTo([0, cy]);\n            fitToSize(this.drawingElement, width, height, strokeWidth);\n        }\n    }\n\n    const defaultOptions$g = {\n        ellipseRadiusXRatio: 0.165,\n        ellipseRadiusYRatio: 0.5\n    };\n    /**\n     * A visual element that renders a data storage symbol with curved sides.\n     * Extends MultiPathShape and provides functionality for creating storage device shapes.\n     */\n    class DataStorage extends MultiPathShape {\n        /**\n         * Creates a new DataStorage instance.\n         * @param options Configuration options for the data storage shape\n         */\n        constructor(options) {\n            super({ ...defaultOptions$g, ...options });\n        }\n        /** @hidden */\n        _drawPath() {\n            const drawingElement = this.drawingElement;\n            const { width, height } = sizeOptionsOrDefault(this.options);\n            const ellipseRX = width * this.options.ellipseRadiusXRatio;\n            const rx = ellipseRX;\n            const ry = height * this.options.ellipseRadiusYRatio;\n            const leftCx = ellipseRX;\n            drawingElement\n                .moveTo(leftCx, 0)\n                .lineTo(width, 0)\n                .arc(270, 90, rx, ry, true)\n                .lineTo(leftCx, height)\n                .arcTo([leftCx, 0], rx, ry, false, true)\n                .close();\n        }\n    }\n\n    /**\n     * A visual element that renders a diamond-shaped decision flowchart symbol.\n     * Extends Rectangle and provides functionality for creating diamond/rhombus shapes.\n     */\n    class Decision extends Rectangle {\n        /** @hidden */\n        _drawPath() {\n            const drawingElement = this.drawingElement;\n            const { width, height } = sizeOptionsOrDefault(this.options);\n            const strokeWidth = this.options.stroke.width || 0;\n            const points = [\n                { x: 0, y: height / 2 },\n                { x: width / 2, y: 0 },\n                { x: width, y: height / 2 },\n                { x: width / 2, y: height }\n            ];\n            const inflated = inflatePolygon(points, this.options.cornerRadius);\n            drawRoundedPolygon(drawingElement, inflated, this.options.cornerRadius);\n            fitToSize(drawingElement, width, height, strokeWidth);\n        }\n    }\n\n    const defaultOptions$f = {\n        arcRadiusXRatio: 0.17,\n        arcRadiusYRatio: 0.3,\n    };\n    /**\n     * A visual element that renders a delay symbol with curved right edge.\n     * Extends Rectangle and provides functionality for creating delay/wait process shapes.\n     */\n    class Delay extends Rectangle {\n        /**\n         * Creates a new Delay instance.\n         * @param options Configuration options for the delay shape\n         */\n        constructor(options) {\n            super({ ...defaultOptions$f, ...options });\n        }\n        /** @hidden */\n        _drawPath() {\n            const drawingElement = this.drawingElement;\n            const { width, height } = sizeOptionsOrDefault(this.options);\n            const strokeWidth = this.options.stroke.width || 0;\n            const { arcRadiusXRatio, arcRadiusYRatio, cornerRadius } = this.options;\n            const arcRadiusX = width * arcRadiusXRatio;\n            const arcRadiusY = height * arcRadiusYRatio;\n            drawingElement\n                .moveTo([0, cornerRadius])\n                .arcTo([cornerRadius, 0], cornerRadius, cornerRadius, true, false)\n                .lineTo([width - arcRadiusX, 0])\n                .arcTo([width - arcRadiusX, height], arcRadiusX, arcRadiusY, false, false)\n                .lineTo([cornerRadius, height])\n                .arcTo([0, height - cornerRadius], cornerRadius, cornerRadius, true, false)\n                .close();\n            fitToSize(this.drawingElement, width, height, strokeWidth);\n        }\n    }\n\n    const defaultOptions$e = {\n        ellipseRatio: 0.1407\n    };\n    /**\n     * Represents a Direct Access Storage shape, a flowchart element used to indicate\n     * direct access storage devices like magnetic disks. Extends Rectangle with\n     * rounded ends.\n     */\n    class DirectAccessStorage extends Rectangle {\n        /**\n         * Creates a new DirectAccessStorage instance.\n         * @param options - Configuration options for the direct access storage shape\n         */\n        constructor(options) {\n            super({ ...defaultOptions$e, ...options });\n        }\n        /**\n         * @hidden\n         * Draws the direct access storage shape path as a rounded rectangle with elliptical ends.\n         */\n        _drawPath() {\n            const drawingElement = this.drawingElement;\n            const { width, height } = sizeOptionsOrDefault(this.options);\n            const ellipseRX = width * this.options.ellipseRatio;\n            const cx = ellipseRX;\n            const rx = ellipseRX;\n            const ry = height / 2;\n            drawingElement\n                .moveTo([width - cx, height])\n                .arcTo([width - cx, 0], rx, ry, false, true)\n                .arcTo([width - cx, height], rx, ry, false, true)\n                .lineTo([cx, height])\n                .arcTo([cx, 0], rx, ry, false, true)\n                .lineTo([width - cx, 0]);\n        }\n    }\n\n    const defaultOptions$d = {\n        sideCutRatio: 0.35,\n        arcRadiusYRatio: 0.3,\n        arcRadiusXRatio: 0.08\n    };\n    /**\n     * A visual element that renders a display symbol with angled left side and curved right edge.\n     * Extends Rectangle and provides functionality for creating display/output device shapes.\n     */\n    class Display extends Rectangle {\n        /**\n         * Creates a new Display instance.\n         * @param options Configuration options for the display shape\n         */\n        constructor(options) {\n            super({ ...defaultOptions$d, ...options });\n        }\n        /** @hidden */\n        _drawPath() {\n            const drawingElement = this.drawingElement;\n            const { width, height } = sizeOptionsOrDefault(this.options);\n            const strokeWidth = this.options.stroke.width || 0;\n            const arcRadiusY = height * this.options.arcRadiusYRatio;\n            const arcRadiusX = width * this.options.arcRadiusXRatio;\n            const arcStartX = width - arcRadiusX;\n            const cut = width * this.options.sideCutRatio;\n            drawingElement\n                .moveTo([cut, 0])\n                .lineTo([arcStartX, 0])\n                .arcTo([arcStartX, height], arcRadiusX, arcRadiusY, false, true)\n                .lineTo([arcStartX, height])\n                .lineTo([cut, height])\n                .lineTo([0, height / 2])\n                .close();\n            fitToSize(this.drawingElement, width, height, strokeWidth);\n        }\n    }\n\n    const cp1XRatio = 5 / 6;\n    const cp2XRatio = 1 / 6;\n    const docDefaultOptions = {\n        waveRatio: 0.37\n    };\n    const multyDocsDefaultOptions = {\n        ...docDefaultOptions,\n        docsXRatio: 0.14,\n        docsYRatio: 0.2,\n    };\n    /**\n     * @hidden\n     * Draws a document shape with a wavy bottom edge.\n     * @param drawingElement - The drawing element to draw on\n     * @param origin - Starting position coordinates\n     * @param width - Width of the document\n     * @param height - Height of the document\n     * @param waveRatio - Ratio for the wave amplitude\n     * @param cornerRadius - Corner radius for rounded corners\n     */\n    const drawDocument = (drawingElement, origin, width, height, waveRatio, cornerRadius) => {\n        const amplitude = height * waveRatio;\n        drawingElement\n            .moveTo(origin[0] + width, origin[1] + height)\n            .curveTo([origin[0] + width, origin[1] + height], [origin[0] + width * cp1XRatio, origin[1] + height - amplitude], [origin[0] + width / 2, origin[1] + height])\n            .curveTo([origin[0] + width * cp2XRatio, origin[1] + height + amplitude], [origin[0], origin[1] + height], [origin[0], origin[1] + height])\n            .lineTo(origin[0], origin[1] + cornerRadius)\n            .arcTo([origin[0] + cornerRadius, origin[1]], cornerRadius, cornerRadius, true, false)\n            .lineTo(origin[0] + width - cornerRadius, origin[1])\n            .arcTo([origin[0] + width, origin[1] + cornerRadius], cornerRadius, cornerRadius, true, false)\n            .lineTo(origin[0] + width, origin[1] + height)\n            .close();\n    };\n    /**\n     * Represents a Document shape, a flowchart element used to indicate documents\n     * or printed output. Extends Rectangle with a wavy bottom edge.\n     */\n    class Document extends Rectangle {\n        /**\n         * Creates a new Document instance.\n         * @param options - Configuration options for the document shape\n         */\n        constructor(options) {\n            super({ ...docDefaultOptions, ...options });\n        }\n        /**\n         * @hidden\n         * Draws the document shape path with a wavy bottom edge.\n         */\n        _drawPath() {\n            const { width, height } = sizeOptionsOrDefault(this.options);\n            const strokeWidth = this.options.stroke.width || 0;\n            const { waveRatio, cornerRadius } = this.options;\n            const halfAmplitude = height * waveRatio * 0.5;\n            drawDocument(this.drawingElement, [0, 0], width, height - halfAmplitude, waveRatio, cornerRadius);\n            fitToSize(this.drawingElement, width, height, strokeWidth);\n        }\n    }\n    /**\n     * Represents a Multiple Documents shape, indicating multiple documents or pages.\n     * Extends Document with additional overlapping document shapes.\n     */\n    class MultipleDocuments extends Document {\n        /**\n         * Creates a new MultipleDocuments instance.\n         * @param options - Configuration options for the multiple documents shape\n         */\n        constructor(options) {\n            super({ ...multyDocsDefaultOptions, ...options });\n        }\n        /**\n         * @hidden\n         * Initializes the path using a group for multiple document shapes.\n         */\n        _initPath() {\n            this.drawingElement = new kendo_drawing_cmn_chunk_js.G();\n            this._fill();\n            this._drawPath();\n        }\n        /**\n         * @hidden\n         * Fills the multiple document shapes with the specified fill options.\n         * @param fillOptions - Fill options to apply\n         */\n        _fill(fillOptions) {\n            const fill = this._evalFillOptions(fillOptions);\n            if (fill.gradient) {\n                const gradient = fill.gradient;\n                const GradientClass = (gradient.type === 'radial' ? kendo_drawing_cmn_chunk_js.h : kendo_drawing_cmn_chunk_js.L);\n                this.drawingElement.children.forEach((child) => {\n                    child.fill(new GradientClass(gradient));\n                });\n            }\n            else {\n                this.drawingElement.children.forEach((child) => {\n                    child.fill(fill.color, fill.opacity);\n                });\n            }\n        }\n        /**\n         * @hidden\n         * Draws multiple overlapping document shapes.\n         */\n        _drawPath() {\n            const { width, height } = sizeOptionsOrDefault(this.options);\n            const strokeWidth = this.options.stroke.width || 0;\n            const { waveRatio, docsXRatio, docsYRatio, stroke, fill, cornerRadius } = this.options;\n            const docOffsetX = width * docsXRatio;\n            const docOffsetY = height * docsYRatio;\n            const drawingElement = this.drawingElement;\n            const path1 = new kendo_drawing_cmn_chunk_js.g({ stroke, fill });\n            const path2 = new kendo_drawing_cmn_chunk_js.g({ stroke, fill });\n            const halfAmplitude = height * waveRatio * 0.5;\n            drawDocument(path1, [docOffsetX, 0], width - docOffsetX, height - docOffsetY - halfAmplitude, waveRatio, cornerRadius);\n            drawDocument(path2, [0, docOffsetY], width - docOffsetX, height - docOffsetY - halfAmplitude, waveRatio, cornerRadius);\n            drawingElement.append(path1);\n            drawingElement.append(path2);\n            fitToSize(this.drawingElement, width, height, strokeWidth);\n        }\n    }\n\n    /**\n     * A visual element that renders a terminator symbol with rounded ends.\n     * Extends Rectangle and provides functionality for creating start/end flowchart shapes.\n     */\n    class Terminator extends Rectangle {\n        /** @hidden */\n        _drawPath() {\n            const { width, height } = sizeOptionsOrDefault(this.options);\n            const drawingElement = this.drawingElement;\n            const r = height / 2;\n            drawingElement\n                .moveTo(r, 0)\n                .lineTo(width - 2 * r, 0)\n                .arcTo([width - 2 * r, height], r, r, false, false)\n                .lineTo(r, height)\n                .arcTo([r, 0], r, r, false, false)\n                .close();\n        }\n    }\n\n    /**\n     * Represents an Extract shape, a flowchart element used to indicate extraction of data or a process step.\n     * Extends the Rectangle class with a custom triangular path.\n     */\n    class Extract extends Rectangle {\n        /**\n         * @hidden\n         * Draws the extract shape path as a triangle.\n         */\n        _drawPath() {\n            const drawingElement = this.drawingElement;\n            const { width, height } = sizeOptionsOrDefault(this.options);\n            const strokeWidth = this.options.stroke.width || 0;\n            const r = this.options.cornerRadius || 0;\n            const points = [\n                { x: width / 2, y: 0 },\n                { x: width, y: height },\n                { x: 0, y: height }\n            ];\n            const inflated = inflatePolygon(points, r);\n            drawRoundedPolygon(drawingElement, inflated, r);\n            fitToSize(drawingElement, width, height, strokeWidth);\n        }\n    }\n\n    /**\n     * Represents a group of visual elements that can be managed and manipulated as a single unit.\n     * Extends Element and incorporates AutoSizeableMixin functionality for automatic sizing.\n     */\n    class Group extends Element {\n        /**\n         * Creates a new Group instance.\n         * @param options Configuration options for the group\n         */\n        constructor(options) {\n            options = deepExtend({ autoSize: false }, options);\n            super(options);\n            /**\n             * Array of child visual elements contained in this group.\n             */\n            this.children = [];\n            /** @hidden */\n            this._childrenChange = false;\n            // Bind mixin methods to current instance\n            this._setScale = AutoSizeableMixin._setScale.bind(this);\n            this._setTranslate = AutoSizeableMixin._setTranslate.bind(this);\n            this._initSize = AutoSizeableMixin._initSize.bind(this);\n            this._updateSize = AutoSizeableMixin._updateSize.bind(this);\n            this.drawingElement = new kendo_drawing_cmn_chunk_js.G();\n            this._initSize();\n        }\n        /**\n         * Appends a visual element to this group.\n         * @param visual The visual element to append to the group\n         */\n        append(visual) {\n            this.drawingElement.append(visual.drawingContainer());\n            this.children.push(visual);\n            this._childrenChange = true;\n        }\n        ;\n        /**\n         * Removes a visual element from this group.\n         * @param visual The visual element to remove from the group\n         */\n        remove(visual) {\n            if (this._remove(visual)) {\n                this._childrenChange = true;\n            }\n        }\n        /** @hidden */\n        _remove(visual) {\n            const index = this.children.indexOf(visual);\n            if (index >= 0) {\n                this.drawingElement.removeAt(index);\n                this.children.splice(index, 1);\n                return true;\n            }\n        }\n        /**\n         * Removes all child visual elements from this group.\n         */\n        clear() {\n            this.drawingElement.clear();\n            this.children = [];\n            this._childrenChange = true;\n        }\n        /**\n         * Moves the specified visual elements to the front of the display order.\n         * @param visuals Array of visual elements to move to front\n         */\n        toFront(visuals) {\n            let visual;\n            for (let i = 0; i < visuals.length; i++) {\n                visual = visuals[i];\n                if (this._remove(visual)) {\n                    this.append(visual);\n                }\n            }\n        }\n        // TO DO: add drawing group support for moving and inserting children\n        /**\n         * Moves the specified visual elements to the back of the display order.\n         * @param visuals Array of visual elements to move to back\n         */\n        toBack(visuals) {\n            this._reorderChildren(visuals, 0);\n        }\n        /**\n         * Moves the specified visual elements to specific indices in the display order.\n         * @param visuals Array of visual elements to reorder\n         * @param indices Target indices for the visual elements\n         */\n        toIndex(visuals, indices) {\n            this._reorderChildren(visuals, indices);\n        }\n        /** @hidden */\n        _reorderChildren(visuals, indices) {\n            const group = this.drawingElement;\n            const drawingChildren = group.children.slice(0);\n            const children = this.children;\n            const fixedPosition = isNumber(indices);\n            let i, index, toIndex, drawingElement, visual;\n            for (i = 0; i < visuals.length; i++) {\n                visual = visuals[i];\n                drawingElement = visual.drawingContainer();\n                index = children.indexOf(visual);\n                if (index >= 0) {\n                    drawingChildren.splice(index, 1);\n                    children.splice(index, 1);\n                    toIndex = fixedPosition ? indices : indices[i];\n                    drawingChildren.splice(toIndex, 0, drawingElement);\n                    children.splice(toIndex, 0, visual);\n                }\n            }\n            group.clear();\n            group.append(...drawingChildren);\n        }\n        /**\n         * Redraws the group with updated options.\n         * @param options New options to apply to the group\n         */\n        redraw(options) {\n            if (options) {\n                if (this._childrenChange) {\n                    this._childrenChange = false;\n                    if (!this._updateSize(options)) {\n                        this._initSize();\n                    }\n                }\n                else {\n                    this._updateSize(options);\n                }\n                super.redraw(options);\n            }\n        }\n        /** @hidden */\n        _boundingBox() {\n            const children = this.children;\n            let boundingBox;\n            let visual, childBoundingBox;\n            for (let i = 0; i < children.length; i++) {\n                visual = children[i];\n                if (visual.visible() && visual._includeInBBox !== false) {\n                    childBoundingBox = visual.drawingContainer().clippedBBox(null);\n                    if (childBoundingBox) {\n                        if (boundingBox) {\n                            boundingBox = kendo_drawing_cmn_chunk_js.R.union(boundingBox, childBoundingBox);\n                        }\n                        else {\n                            boundingBox = childBoundingBox;\n                        }\n                    }\n                }\n            }\n            return boundingBox;\n        }\n    }\n\n    /**\n     * Represents an Image element for displaying images in SVG.\n     * Extends the Element class to provide image-specific functionality.\n     */\n    class Image extends Element {\n        /**\n         * Creates a new Image instance.\n         * @param options - Configuration options for the image including source, position, and size\n         */\n        constructor(options) {\n            super(options);\n            this._initImage();\n        }\n        /**\n         * Redraws the image with updated options.\n         * @param options - Updated configuration options\n         */\n        redraw(options) {\n            if (options) {\n                if (options.source) {\n                    this.drawingElement.src(options.source);\n                }\n                if (this._diffNumericOptions(options, [WIDTH, HEIGHT, X, Y])) {\n                    this.drawingElement.rect(this._rect());\n                }\n                super.redraw(options);\n            }\n        }\n        /**\n         * @hidden\n         * Initializes the image drawing element.\n         */\n        _initImage() {\n            const options = this.options;\n            const rect = this._rect();\n            this.drawingElement = new kendo_drawing_cmn_chunk_js.I(options.source, rect);\n        }\n        /** @hidden */\n        _rect() {\n            const sizeOptions = sizeOptionsOrDefault(this.options);\n            const origin = new kendo_drawing_cmn_chunk_js.P(sizeOptions.x, sizeOptions.y);\n            const size = new kendo_drawing_cmn_chunk_js.o(sizeOptions.width, sizeOptions.height);\n            return new kendo_drawing_cmn_chunk_js.R(origin, size);\n        }\n    }\n\n    const defaultOptions$c = {\n        leftLineOffsetRatio: 0.13,\n        topLineOffsetRatio: 0.23,\n    };\n    /**\n     * Represents an Internal Storage shape, a flowchart element used to indicate\n     * internal storage or memory operations. Extends MultiPathShape with a rectangle\n     * containing internal dividing lines.\n     */\n    class InternalStorage extends MultiPathShape {\n        /**\n         * Creates a new InternalStorage instance.\n         * @param options - Configuration options for the internal storage shape\n         */\n        constructor(options) {\n            super({ ...defaultOptions$c, ...options });\n        }\n        /**\n         * @hidden\n         * Draws the internal storage shape path as a rectangle with internal lines.\n         */\n        _drawPath() {\n            const drawingElement = this.drawingElement;\n            const { width, height } = sizeOptionsOrDefault(this.options);\n            const { leftLineOffsetRatio, topLineOffsetRatio } = this.options;\n            const leftLineX = width * leftLineOffsetRatio;\n            const topLineOffset = height * topLineOffsetRatio;\n            const points = [\n                { x: 0, y: 0 },\n                { x: width, y: 0 },\n                { x: width, y: height },\n                { x: 0, y: height }\n            ];\n            drawRoundedPolygon(drawingElement, points, this.options.cornerRadius);\n            drawingElement\n                .moveTo(leftLineX, 0)\n                .lineTo(leftLineX, height)\n                .moveTo(0, topLineOffset)\n                .lineTo(width, topLineOffset);\n        }\n    }\n\n    /**\n     * Represents a layout container that automatically arranges child elements.\n     * Extends Group to provide automatic layout and positioning capabilities.\n     */\n    class Layout extends Group {\n        /**\n         * Creates a new Layout instance.\n         * @param rect The rectangle bounds for the layout\n         * @param options Configuration options for the layout\n         */\n        constructor(rect, options) {\n            super(options);\n            this.drawingElement = new kendo_drawing_cmn_chunk_js.j(toDrawingRect(rect), options);\n            this._initSize();\n        }\n        /**\n         * Gets or sets the rectangle bounds of the layout.\n         * @param rect The rectangle bounds to set, or undefined to get current bounds\n         * @returns The current rectangle bounds when called as getter\n         */\n        rect(rect) {\n            if (rect) {\n                this.drawingElement.rect(toDrawingRect(rect));\n            }\n            else {\n                const drawingRect = this.drawingElement.rect();\n                if (drawingRect) {\n                    return new Rect(drawingRect.origin.x, drawingRect.origin.y, drawingRect.size.width, drawingRect.size.height);\n                }\n            }\n        }\n        /**\n         * Triggers a reflow of the layout, recalculating positions and sizes.\n         */\n        reflow() {\n            this.drawingElement.reflow();\n        }\n        /**\n         * Redraws the layout with updated options.\n         * @param options New options to apply to the layout\n         */\n        redraw(options) {\n            deepExtend(this.drawingElement.options, options);\n            super.redraw.call(this, options);\n        }\n    }\n\n    /**\n     * Mixin that provides marker functionality for path-based elements.\n     * Can be mixed into classes to add start and end marker capabilities.\n     */\n    const MarkerPathMixin = {\n        /**\n         * @hidden\n         * Gets the path element for marker positioning.\n         * @param position - The marker position (start or end)\n         * @returns The path element or undefined\n         */\n        _getPath: function (position) {\n            let path = this.drawingElement;\n            if (path instanceof kendo_drawing_cmn_chunk_js.g) {\n                if (position === START$1) {\n                    path = path.paths[0];\n                }\n                else {\n                    path = path.paths[path.paths.length - 1];\n                }\n            }\n            if (path && path.segments.length) {\n                return path;\n            }\n        },\n        /**\n         * @hidden\n         * Normalizes marker options by converting string values to objects.\n         * @param options - The options to normalize\n         */\n        _normalizeMarkerOptions: function (options) {\n            const startCap = options.startCap;\n            const endCap = options.endCap;\n            if (isString$1(startCap)) {\n                options.startCap = {\n                    type: startCap\n                };\n            }\n            if (isString$1(endCap)) {\n                options.endCap = {\n                    type: endCap\n                };\n            }\n        },\n        /**\n         * @hidden\n         * Removes a marker from the specified position.\n         * @param position - The marker position (start or end)\n         */\n        _removeMarker: function (position) {\n            const marker = this._markers[position];\n            if (marker) {\n                this.drawingContainer().remove(marker.drawingElement);\n                delete this._markers[position];\n            }\n        },\n        /**\n         * @hidden\n         * Creates markers for both start and end positions.\n         */\n        _createMarkers: function () {\n            const options = this.options;\n            this._normalizeMarkerOptions(options);\n            this._markers = {};\n            this._markers[START$1] = this._createMarker(options.startCap, START$1);\n            this._markers[END$1] = this._createMarker(options.endCap, END$1);\n        },\n        /**\n         * @hidden\n         * Creates a marker for the specified position.\n         * @param options - Marker configuration options\n         * @param position - The marker position (start or end)\n         * @returns The created marker instance\n         */\n        _createMarker: function (options, position) {\n            const type = (options || {}).type;\n            const path = this._getPath(position);\n            let markerType, marker;\n            if (!path) {\n                this._removeMarker(position);\n                return;\n            }\n            if (type === MarkerType.FilledCircle) {\n                markerType = CircleMarker;\n            }\n            else if (type === MarkerType.ArrowStart || type === MarkerType.ArrowEnd) {\n                markerType = ArrowMarker;\n            }\n            else {\n                this._removeMarker(position);\n            }\n            if (markerType) {\n                marker = new markerType(deepExtend({}, options, {\n                    position: position\n                }));\n                marker.positionMarker(path);\n                this.drawingContainer().append(marker.drawingElement);\n                return marker;\n            }\n        },\n        /**\n         * @hidden\n         * Positions a marker at the specified position along the path.\n         * @param position - The marker position (start or end)\n         */\n        _positionMarker: function (position) {\n            const marker = this._markers[position];\n            if (marker) {\n                const path = this._getPath(position);\n                if (path) {\n                    marker.positionMarker(path);\n                }\n                else {\n                    this._removeMarker(position);\n                }\n            }\n        },\n        /**\n         * @hidden\n         * Mapping of position names to cap option names.\n         */\n        _capMap: {\n            start: 'startCap',\n            end: 'endCap'\n        },\n        /**\n         * @hidden\n         * Redraws a marker at the specified position with updated options.\n         * @param pathChange - Whether the path has changed\n         * @param position - The marker position (start or end)\n         * @param options - Updated marker options\n         * @returns True if a new marker was created, false otherwise\n         */\n        _redrawMarker: function (pathChange, position, options) {\n            this._normalizeMarkerOptions(options);\n            const pathOptions = this.options;\n            const cap = this._capMap[position];\n            const pathCapType = (pathOptions[cap] || {}).type;\n            const optionsCap = options[cap];\n            let created = false;\n            if (optionsCap) {\n                pathOptions[cap] = deepExtend({}, pathOptions[cap], optionsCap);\n                if (optionsCap.type && pathCapType !== optionsCap.type) {\n                    this._removeMarker(position);\n                    this._markers[position] = this._createMarker(pathOptions[cap], position);\n                    created = true;\n                }\n                else if (this._markers[position]) {\n                    this._markers[position].redraw(optionsCap);\n                }\n            }\n            else if (pathChange && !this._markers[position] && pathOptions[cap]) {\n                this._markers[position] = this._createMarker(pathOptions[cap], position);\n                created = true;\n            }\n            return created;\n        },\n        /**\n         * @hidden\n         * Redraws all markers with updated options.\n         * @param pathChange - Whether the path has changed\n         * @param options - Updated marker options\n         */\n        _redrawMarkers: function (pathChange, options) {\n            if (!this._redrawMarker(pathChange, START$1, options) && pathChange) {\n                this._positionMarker(START$1);\n            }\n            if (!this._redrawMarker(pathChange, END$1, options) && pathChange) {\n                this._positionMarker(END$1);\n            }\n        }\n    };\n\n    /**\n     * Represents a line segment with marker capabilities.\n     * Extends VisualBase and incorporates MarkerPathMixin functionality.\n     */\n    class Line extends VisualBase {\n        /**\n         * Creates a new Line instance.\n         * @param options - Configuration options for the line including endpoints and styling\n         */\n        constructor(options) {\n            super(options);\n            /** @hidden */\n            this._capMap = MarkerPathMixin._capMap;\n            this.container = new kendo_drawing_cmn_chunk_js.G();\n            this._getPath = MarkerPathMixin._getPath.bind(this);\n            this._normalizeMarkerOptions = MarkerPathMixin._normalizeMarkerOptions.bind(this);\n            this._removeMarker = MarkerPathMixin._removeMarker.bind(this);\n            this._createMarkers = MarkerPathMixin._createMarkers.bind(this);\n            this._createMarker = MarkerPathMixin._createMarker.bind(this);\n            this._positionMarker = MarkerPathMixin._positionMarker.bind(this);\n            this._redrawMarker = MarkerPathMixin._redrawMarker.bind(this);\n            this._redrawMarkers = MarkerPathMixin._redrawMarkers.bind(this);\n            this._initPath();\n            this._createMarkers();\n        }\n        /**\n         * Returns the drawing container for this line.\n         * @returns The drawing container\n         */\n        drawingContainer() {\n            return this.container;\n        }\n        /**\n         * Redraws the line with updated options.\n         * @param options - Updated configuration options\n         */\n        redraw(options) {\n            if (options) {\n                options = options || {};\n                const from = options.from;\n                const to = options.to;\n                if (from) {\n                    this.options.from = from;\n                }\n                if (to) {\n                    this.options.to = to;\n                }\n                if (from || to) {\n                    this._drawPath();\n                    this._redrawMarkers(true, options);\n                }\n                else {\n                    this._redrawMarkers(false, options);\n                }\n                super.redraw(options);\n            }\n        }\n        /**\n         * @hidden\n         * Initializes the path drawing element.\n         */\n        _initPath() {\n            const options = this.options;\n            const drawingElement = this.drawingElement = new kendo_drawing_cmn_chunk_js.a({\n                stroke: options.stroke\n            });\n            this._fill();\n            this._drawPath();\n            this.container.append(drawingElement);\n        }\n        /**\n         * @hidden\n         * Draws the line path between from and to points.\n         */\n        _drawPath() {\n            const options = this.options;\n            const drawingElement = this.drawingElement;\n            const from = options.from || new Point();\n            const to = options.to || new Point();\n            drawingElement.segments.elements([\n                createSegment(from.x, from.y),\n                createSegment(to.x, to.y)\n            ]);\n        }\n    }\n\n    const defaultOptions$b = {\n        topSlantRatio: 0.2\n    };\n    /**\n     * Represents a Manual Input/Output shape, a flowchart element used to indicate\n     * manual input or output operations. Extends Rectangle with a slanted top edge.\n     */\n    class ManualInputOutput extends Rectangle {\n        /**\n         * Creates a new ManualInputOutput instance.\n         * @param options - Configuration options for the manual input/output shape\n         */\n        constructor(options) {\n            super({ ...defaultOptions$b, ...options });\n        }\n        /**\n         * @hidden\n         * Draws the manual input/output shape path as a quadrilateral with slanted top.\n         */\n        _drawPath() {\n            const drawingElement = this.drawingElement;\n            const { width, height } = sizeOptionsOrDefault(this.options);\n            const strokeWidth = this.options.stroke.width || 0;\n            const { topSlantRatio, cornerRadius } = this.options;\n            const topSlant = height * topSlantRatio;\n            const points = [\n                { x: 0, y: topSlant },\n                { x: width, y: 0 },\n                { x: width, y: height },\n                { x: 0, y: height }\n            ];\n            drawRoundedPolygon(drawingElement, points, cornerRadius);\n            fitToSize(drawingElement, width, height, strokeWidth);\n        }\n    }\n\n    const defaultOptions$a = {\n        baseShrinkRatio: 0.5\n    };\n    /**\n     * Represents a Manual Operation shape, a flowchart element used to indicate a manual process or operation.\n     * Extends the Rectangle class with a custom trapezoid path.\n     */\n    class ManualOperation extends Rectangle {\n        /**\n         * Creates a new ManualOperation instance.\n         * @param options - Configuration options for the manual operation shape\n         */\n        constructor(options) {\n            super({ ...defaultOptions$a, ...options });\n        }\n        /**\n         * @hidden\n         * Draws the manual operation shape path as a trapezoid.\n         */\n        _drawPath() {\n            const drawingElement = this.drawingElement;\n            const { width, height } = sizeOptionsOrDefault(this.options);\n            const strokeWidth = this.options.stroke.width || 0;\n            const baseShrink = width * this.options.baseShrinkRatio;\n            const points = [\n                { x: 0, y: 0 },\n                { x: width, y: 0 },\n                { x: width - baseShrink / 2, y: height },\n                { x: baseShrink / 2, y: height }\n            ];\n            drawRoundedPolygon(drawingElement, points, this.options.cornerRadius);\n            fitToSize(drawingElement, width, height, strokeWidth);\n        }\n    }\n\n    /**\n     * Represents a Merge shape, a flowchart element used to indicate the merging\n     * of multiple processes or data streams. Extends Rectangle with a triangular path.\n     */\n    class Merge extends Rectangle {\n        /**\n         * @hidden\n         * Draws the merge shape path as an inverted triangle.\n         */\n        _drawPath() {\n            const drawingElement = this.drawingElement;\n            const { width, height } = sizeOptionsOrDefault(this.options);\n            const strokeWidth = this.options.stroke.width || 0;\n            const points = [\n                { x: 0, y: 0 },\n                { x: width, y: 0 },\n                { x: width / 2, y: height }\n            ];\n            const inflated = inflatePolygon(points, this.options.cornerRadius);\n            drawRoundedPolygon(drawingElement, inflated, this.options.cornerRadius);\n            fitToSize(drawingElement, width, height, strokeWidth);\n        }\n    }\n\n    /**\n     * Represents a Logical OR shape, used in logic diagrams and circuit diagrams\n     * to indicate logical OR operations. Extends MultiPathShape with a circular path\n     * and intersecting lines.\n     */\n    class LogicalOr extends MultiPathShape {\n        /**\n         * @hidden\n         * Draws the logical OR shape path as a circle with horizontal and vertical lines.\n         */\n        _drawPath() {\n            const drawingElement = this.drawingElement;\n            const { width, height } = sizeOptionsOrDefault(this.options);\n            const centerX = width / 2;\n            const centerY = height / 2;\n            const radius = (Math.min(width, height) / 2) - this.options.stroke.width;\n            drawingElement\n                .moveTo(centerX, 0)\n                .arcTo([centerX, height], radius, radius, false, true)\n                .arcTo([centerX, 0], radius, radius, false, true)\n                .moveTo(0, centerY)\n                .lineTo(width, centerY)\n                .moveTo(centerX, 0)\n                .lineTo(centerX, height);\n        }\n    }\n\n    const defaultOptions$9 = {\n        ellipseRxRatio: 0.5,\n        ellipseRyRatio: 0.13,\n        bottomEdgeYRatio: 0.76\n    };\n    /**\n     * Represents an Off-Page Connector shape, a flowchart element used to indicate\n     * continuation of a flowchart on another page. Extends Rectangle with a custom\n     * pentagon-like path with rounded top edge.\n     */\n    class OffPageConnector extends Rectangle {\n        /**\n         * Creates a new OffPageConnector instance.\n         * @param options - Configuration options for the off-page connector shape\n         */\n        constructor(options) {\n            super({ ...defaultOptions$9, ...options });\n        }\n        /**\n         * @hidden\n         * Draws the off-page connector shape path as a pentagon with rounded top.\n         */\n        _drawPath() {\n            const drawingElement = this.drawingElement;\n            const { width, height } = sizeOptionsOrDefault(this.options);\n            const strokeWidth = this.options.stroke.width || 0;\n            const ellipseRX = width * this.options.ellipseRxRatio;\n            const ellipseRY = height * this.options.ellipseRyRatio;\n            const topY = ellipseRY;\n            const leftY = topY;\n            const rightY = topY;\n            const bottomY = height * this.options.bottomEdgeYRatio;\n            const bottomMiddleX = width / 2;\n            const bottomMiddleY = height;\n            drawingElement\n                .moveTo([0, topY])\n                .arcTo([width, rightY], ellipseRX, ellipseRY, false, false)\n                .lineTo([width, bottomY])\n                .lineTo([bottomMiddleX, bottomMiddleY])\n                .lineTo([0, bottomY])\n                .lineTo([0, leftY])\n                .close();\n            fitToSize(this.drawingElement, width, height, strokeWidth);\n        }\n    }\n\n    /**\n     * Represents an SVG path element with auto-sizing and marker capabilities.\n     * Combines VisualBase with AutoSizeableMixin and MarkerPathMixin functionality.\n     */\n    class Path extends VisualBase {\n        /**\n         * Creates a new Path instance.\n         * @param options - Configuration options for the path\n         */\n        constructor(options) {\n            options = deepExtend({ autoSize: true }, options);\n            super(options);\n            /** @hidden */\n            this._capMap = MarkerPathMixin._capMap;\n            this.container = new kendo_drawing_cmn_chunk_js.G();\n            this._setScale = AutoSizeableMixin._setScale.bind(this);\n            this._setTranslate = AutoSizeableMixin._setTranslate.bind(this);\n            this._initSize = AutoSizeableMixin._initSize.bind(this);\n            this._updateSize = AutoSizeableMixin._updateSize.bind(this);\n            this._getPath = MarkerPathMixin._getPath.bind(this);\n            this._normalizeMarkerOptions = MarkerPathMixin._normalizeMarkerOptions.bind(this);\n            this._removeMarker = MarkerPathMixin._removeMarker.bind(this);\n            this._createMarkers = MarkerPathMixin._createMarkers.bind(this);\n            this._createMarker = MarkerPathMixin._createMarker.bind(this);\n            this._positionMarker = MarkerPathMixin._positionMarker.bind(this);\n            this._redrawMarker = MarkerPathMixin._redrawMarker.bind(this);\n            this._redrawMarkers = MarkerPathMixin._redrawMarkers.bind(this);\n            this._createElements();\n            this._initSize();\n        }\n        /**\n         * Gets the drawing container that holds the path and its markers.\n         * @returns The drawing group container\n         */\n        drawingContainer() {\n            return this.container;\n        }\n        /**\n         * Gets or sets the path data string for the SVG path.\n         * @param value The SVG path data string to set, or undefined to get current data\n         * @returns The current path data string when called as getter\n         */\n        data(value) {\n            const options = this.options;\n            if (value) {\n                if (options.data !== value) {\n                    options.data = value;\n                    this._setData(value);\n                    this._initSize();\n                    this._redrawMarkers(true, {});\n                }\n            }\n            else {\n                return options.data;\n            }\n        }\n        /**\n         * Redraws the path with updated options.\n         * @param options - Updated configuration options\n         */\n        redraw(options) {\n            if (options) {\n                super.redraw(options);\n                const pathOptions = this.options;\n                const data = options.data;\n                if (defined(data) && pathOptions.data !== data) {\n                    pathOptions.data = data;\n                    this._setData(data);\n                    if (!this._updateSize(options)) {\n                        this._initSize();\n                    }\n                    this._redrawMarkers(true, options);\n                }\n                else {\n                    this._updateSize(options);\n                    this._redrawMarkers(false, options);\n                }\n            }\n        }\n        /**\n         * @hidden\n         * Creates the drawing elements for the path.\n         */\n        _createElements() {\n            const options = this.options;\n            this.drawingElement = kendo_drawing_cmn_chunk_js.a.parse(options.data || '', {\n                stroke: options.stroke\n            });\n            this._fill();\n            this.container.append(this.drawingElement);\n            this._createMarkers();\n        }\n        /**\n         * @hidden\n         * Sets the path data for the drawing element.\n         * @param data - The SVG path data string\n         */\n        _setData(data) {\n            const drawingElement = this.drawingElement;\n            const multipath = kendo_drawing_cmn_chunk_js.a.parse(data || '');\n            const paths = multipath.paths.slice(0);\n            multipath.paths.elements([]);\n            drawingElement.paths.elements(paths);\n        }\n    }\n\n    /**\n     * Represents a polyline (multi-segment line) with marker capabilities.\n     * Extends VisualBase and incorporates MarkerPathMixin functionality.\n     */\n    class Polyline extends VisualBase {\n        /**\n         * Creates a new Polyline instance.\n         * @param options - Configuration options for the polyline including points and styling\n         */\n        constructor(options) {\n            options = deepExtend({ points: [] }, options);\n            super(options);\n            /** @hidden */\n            this._capMap = MarkerPathMixin._capMap;\n            this.container = new kendo_drawing_cmn_chunk_js.G();\n            this._getPath = MarkerPathMixin._getPath.bind(this);\n            this._normalizeMarkerOptions = MarkerPathMixin._normalizeMarkerOptions.bind(this);\n            this._removeMarker = MarkerPathMixin._removeMarker.bind(this);\n            this._createMarkers = MarkerPathMixin._createMarkers.bind(this);\n            this._createMarker = MarkerPathMixin._createMarker.bind(this);\n            this._positionMarker = MarkerPathMixin._positionMarker.bind(this);\n            this._redrawMarker = MarkerPathMixin._redrawMarker.bind(this);\n            this._redrawMarkers = MarkerPathMixin._redrawMarkers.bind(this);\n            this._initPath();\n            this._createMarkers();\n        }\n        /**\n         * Gets the drawing container that holds the polyline and its markers.\n         * @returns The drawing group container\n         */\n        drawingContainer() {\n            return this.container;\n        }\n        /**\n         * Gets or sets the points that define the polyline path.\n         * @param points Array of points to set for the polyline, or undefined to get current points\n         * @returns The current points array when called as getter\n         */\n        points(points) {\n            const options = this.options;\n            if (points) {\n                options.points = points;\n                this._updatePath();\n            }\n            else {\n                return options.points;\n            }\n        }\n        /**\n         * Redraws the polyline with updated options.\n         * @param options - Updated configuration options\n         */\n        redraw(options) {\n            if (options) {\n                const points = options.points;\n                super.redraw.call(this, options);\n                if (points && this._pointsDiffer(points)) {\n                    this.points(points);\n                    this._redrawMarkers(true, options);\n                }\n                else {\n                    this._redrawMarkers(false, options);\n                }\n            }\n        }\n        /**\n         * @hidden\n         * Initializes the path drawing element.\n         */\n        _initPath() {\n            const options = this.options;\n            this.drawingElement = new kendo_drawing_cmn_chunk_js.a({\n                stroke: options.stroke\n            });\n            this._fill();\n            this.container.append(this.drawingElement);\n            if (options.points) {\n                this._updatePath();\n            }\n        }\n        /** @hidden */\n        _pointsDiffer(points) {\n            const currentPoints = this.options.points;\n            let differ = currentPoints.length !== points.length;\n            if (!differ) {\n                for (let i = 0; i < points.length; i++) {\n                    if (currentPoints[i].x !== points[i].x || currentPoints[i].y !== points[i].y) {\n                        differ = true;\n                        break;\n                    }\n                }\n            }\n            return differ;\n        }\n        /**\n         * @hidden\n         * Updates the path with current points.\n         */\n        _updatePath() {\n            const drawingElement = this.drawingElement;\n            const options = this.options;\n            const points = options.points;\n            if (options.cornerRadius > 0) {\n                createRoundedPolyline(drawingElement, points, options.cornerRadius);\n            }\n            else {\n                const segments = [];\n                let point;\n                for (let i = 0; i < points.length; i++) {\n                    point = points[i];\n                    segments.push(createSegment(point.x, point.y));\n                }\n                drawingElement.segments.elements(segments);\n            }\n        }\n    }\n    const EPS = 1e-6;\n    const KAPPA = 0.5522847498307936; // 4*(sqrt(2)-1)/3\n    const rightAngleTolerance = 0.05;\n    function dist(a, b) {\n        return Math.hypot(a.x - b.x, a.y - b.y);\n    }\n    function dedupe(points, eps = EPS) {\n        if (points.length === 0)\n            return points;\n        const out = [points[0]];\n        for (let i = 1; i < points.length; i++) {\n            if (dist(points[i], out[out.length - 1]) > eps) {\n                out.push(points[i]);\n            }\n        }\n        return out;\n    }\n    function createRoundedPolyline(path, points, cornerRadius) {\n        const pts = dedupe(points);\n        if (pts.length < 2) {\n            return path;\n        }\n        path.moveTo(pts[0].x, pts[0].y);\n        if (pts.length === 2) {\n            path.lineTo(pts[1].x, pts[1].y);\n            return path;\n        }\n        for (let i = 1; i < pts.length - 1; i++) {\n            const prev = pts[i - 1];\n            const curr = pts[i];\n            const next = pts[i + 1];\n            const v1 = { x: curr.x - prev.x, y: curr.y - prev.y };\n            const v2 = { x: next.x - curr.x, y: next.y - curr.y };\n            const len1 = Math.hypot(v1.x, v1.y);\n            const len2 = Math.hypot(v2.x, v2.y);\n            if (len1 < EPS || len2 < EPS) {\n                path.lineTo(curr.x, curr.y);\n                continue;\n            }\n            const cross = v1.x * v2.y - v1.y * v2.x;\n            const dot = (v1.x * v2.x + v1.y * v2.y) / (len1 * len2);\n            const isColinearSameDir = Math.abs(cross) < EPS && dot > 0.999;\n            if (isColinearSameDir) {\n                continue;\n            }\n            const r = Math.min(cornerRadius, len1 / 2, len2 / 2);\n            if (r <= EPS) {\n                path.lineTo(curr.x, curr.y);\n                continue;\n            }\n            const u1 = { x: v1.x / len1, y: v1.y / len1 };\n            const u2 = { x: v2.x / len2, y: v2.y / len2 };\n            const p1 = { x: curr.x - u1.x * r, y: curr.y - u1.y * r };\n            const p2 = { x: curr.x + u2.x * r, y: curr.y + u2.y * r };\n            const isRightAngle = Math.abs(dot) <= rightAngleTolerance;\n            path.lineTo(p1.x, p1.y);\n            if (isRightAngle) {\n                const k = KAPPA * r;\n                const c1 = { x: p1.x + u1.x * k, y: p1.y + u1.y * k };\n                const c2 = { x: p2.x - u2.x * k, y: p2.y - u2.y * k };\n                path.curveTo(new kendo_drawing_cmn_chunk_js.P(c1.x, c1.y), new kendo_drawing_cmn_chunk_js.P(c2.x, c2.y), new kendo_drawing_cmn_chunk_js.P(p2.x, p2.y));\n            }\n            else {\n                path.curveTo(new kendo_drawing_cmn_chunk_js.P(curr.x, curr.y), new kendo_drawing_cmn_chunk_js.P(curr.x, curr.y), new kendo_drawing_cmn_chunk_js.P(p2.x, p2.y));\n            }\n        }\n        const last = pts[pts.length - 1];\n        path.lineTo(last.x, last.y);\n        return path;\n    }\n\n    const defaultOptions$8 = {\n        sideLineOffsetRatio: 0.1\n    };\n    /**\n     * Represents a Predefined Process shape, a flowchart element used to indicate\n     * a process that is defined elsewhere. Extends MultiPathShape with a rectangle\n     * containing vertical side lines.\n     */\n    class PredefinedProcess extends MultiPathShape {\n        /**\n         * Creates a new PredefinedProcess instance.\n         * @param options - Configuration options for the predefined process shape\n         */\n        constructor(options) {\n            super({ ...defaultOptions$8, ...options });\n        }\n        /**\n         * @hidden\n         * Draws the predefined process shape path as a rectangle with vertical lines.\n         */\n        _drawPath() {\n            const drawingElement = this.drawingElement;\n            const { width, height } = sizeOptionsOrDefault(this.options);\n            const sideLineOffsetRatio = this.options.sideLineOffsetRatio;\n            const sideLineOffset = width * sideLineOffsetRatio;\n            const leftLineX = sideLineOffset;\n            const rightLineX = width - sideLineOffset;\n            const points = [\n                { x: 0, y: 0 },\n                { x: width, y: 0 },\n                { x: width, y: height },\n                { x: 0, y: height }\n            ];\n            drawRoundedPolygon(drawingElement, points, this.options.cornerRadius);\n            drawingElement\n                .moveTo(leftLineX, 0)\n                .lineTo(leftLineX, height)\n                .moveTo(rightLineX, 0)\n                .lineTo(rightLineX, height);\n        }\n    }\n\n    const defaultOptions$7 = {\n        horizontalInsetRatio: 1 / 6\n    };\n    /**\n     * A visual element that renders a preparation symbol with hexagonal shape.\n     * Extends Rectangle and provides functionality for creating preparation/setup process shapes.\n     */\n    class Preparation extends Rectangle {\n        /**\n         * Creates a new Preparation instance.\n         * @param options Configuration options for the preparation shape\n         */\n        constructor(options) {\n            super({ ...defaultOptions$7, ...options });\n        }\n        /** @hidden */\n        _drawPath() {\n            const drawingElement = this.drawingElement;\n            const { width, height } = sizeOptionsOrDefault(this.options);\n            const strokeWidth = this.options.stroke.width || 0;\n            const xOffset = width * this.options.horizontalInsetRatio;\n            const points = [\n                { x: xOffset, y: 0 },\n                { x: width - xOffset, y: 0 },\n                { x: width, y: height / 2 },\n                { x: width - xOffset, y: height },\n                { x: xOffset, y: height },\n                { x: 0, y: height / 2 }\n            ];\n            drawRoundedPolygon(drawingElement, points, this.options.cornerRadius);\n            fitToSize(drawingElement, width, height, strokeWidth);\n        }\n    }\n\n    /**\n     * A visual element that renders a rectangular process flowchart symbol.\n     */\n    class Process extends Rectangle {\n    }\n\n    const defaultOptions$6 = {\n        shapesOffsetRatio: 0.015,\n    };\n    /**\n     * Represents a Sort shape, a flowchart element used to indicate sorting operations.\n     * Extends MultiPathShape with two triangular shapes arranged vertically.\n     */\n    class Sort extends MultiPathShape {\n        /**\n         * Creates a new Sort instance.\n         * @param options - Configuration options for the sort shape\n         */\n        constructor(options) {\n            super({ ...defaultOptions$6, ...options });\n        }\n        /**\n         * @hidden\n         * Draws the sort shape path as two triangular shapes.\n         */\n        _drawPath() {\n            const drawingElement = this.drawingElement;\n            const { width, height } = sizeOptionsOrDefault(this.options);\n            const strokeWidth = this.options.stroke.width || 0;\n            const cornerRadius = this.options.cornerRadius;\n            const shapesOffset = this.options.shapesOffsetRatio * height;\n            const halfHeight = height / 2;\n            const firstShape = [\n                { x: width / 2, y: 0 },\n                { x: width, y: halfHeight - shapesOffset },\n                { x: 0, y: halfHeight - shapesOffset }\n            ];\n            drawRoundedPolygon(drawingElement, firstShape, [cornerRadius / 3, cornerRadius, cornerRadius]);\n            const secondShape = [\n                { x: width / 2, y: height },\n                { x: 0, y: halfHeight + shapesOffset },\n                { x: width, y: halfHeight + shapesOffset }\n            ];\n            drawRoundedPolygon(drawingElement, secondShape, [cornerRadius / 3, cornerRadius, cornerRadius]);\n            fitToSize(drawingElement, width, height, strokeWidth);\n        }\n    }\n\n    /**\n     * Represents a Summing Junction shape, used in control system diagrams to indicate\n     * mathematical operations like addition or subtraction. Extends MultiPathShape with\n     * a circular path containing cross lines.\n     */\n    class SummingJunction extends MultiPathShape {\n        /**\n         * @hidden\n         * Draws the summing junction shape path as a circle with intersecting lines.\n         */\n        _drawPath() {\n            const drawingElement = this.drawingElement;\n            const { width, height } = sizeOptionsOrDefault(this.options);\n            const cx = width / 2;\n            const cy = height / 2;\n            const radius = Math.min(width, height) * 0.5;\n            const topY = cy - radius;\n            const bottomY = cy + radius;\n            const x1 = cx - radius / Math.SQRT2;\n            const y1 = cy - radius / Math.SQRT2;\n            const x2 = cx + radius / Math.SQRT2;\n            const y2 = cy + radius / Math.SQRT2;\n            drawingElement\n                .moveTo(cx, topY)\n                .arcTo([cx, bottomY], radius, radius, false, true)\n                .arcTo([cx, topY], radius, radius, false, true)\n                .moveTo(x1, y1)\n                .lineTo(x2, y2)\n                .moveTo(x2, y1)\n                .lineTo(x1, y2);\n        }\n    }\n\n    const textColor = (options) => {\n        if (options && options.color) {\n            options = deepExtend({}, options, {\n                fill: {\n                    color: options.color\n                }\n            });\n        }\n        return options;\n    };\n    /** @hidden */\n    const defaultTextOptions = {\n        fontSize: 15,\n        fontFamily: 'sans-serif',\n        lineSpacing: 0,\n        textWrap: 'nowrap',\n        padding: getSpacing(0),\n        relativePadding: getSpacing(0),\n        stroke: {\n            width: 0\n        },\n        fill: {\n            color: 'black'\n        },\n        autoSize: true\n    };\n    /**\n     * A visual element that renders text content.\n     * Extends VisualBase and provides functionality for creating and managing text graphics with font styling.\n     */\n    class TextBlock extends VisualBase {\n        /**\n         * Creates a new TextBlock instance.\n         * @param options Configuration options for the text block\n         */\n        constructor(options) {\n            options = deepExtend({}, defaultTextOptions, options);\n            options = textColor(options);\n            super(options);\n            /** Array of text elements for multi-line text support. */\n            this.textElements = [];\n            /** Whether the text block can be aligned within its container. */\n            this.alignable = true;\n            /** @hidden */\n            this.name = 'TextBlock';\n            this._setScale = AutoSizeableMixin._setScale.bind(this);\n            this._setTranslate = AutoSizeableMixin._setTranslate.bind(this);\n            this._initSize = AutoSizeableMixin._initSize.bind(this);\n            this._updateSize = AutoSizeableMixin._updateSize.bind(this);\n            this._font();\n            this._initText();\n            this._initSize();\n        }\n        /** @hidden */\n        _initText() {\n            const options = this.options;\n            this.textElements.length = 0;\n            this.drawingElement = new kendo_drawing_cmn_chunk_js.T(defined(options.text) ? options.text : EMPTY, new kendo_drawing_cmn_chunk_js.P(), {\n                font: options.font\n            });\n            this.textElements.push(this.drawingElement);\n            this._fill();\n            this._stroke();\n        }\n        /** @hidden */\n        _fill(fillOptions) {\n            const fill = this._evalFillOptions(fillOptions);\n            if (fill.gradient) {\n                const gradient = fill.gradient;\n                const GradientClass = (gradient.type === 'radial' ? kendo_drawing_cmn_chunk_js.h : kendo_drawing_cmn_chunk_js.L);\n                this.textElements.forEach((el) => {\n                    el.fill(new GradientClass(gradient));\n                });\n            }\n            else {\n                this._setFill(fill);\n            }\n        }\n        /** @hidden */\n        _setFill(fill) {\n            this.textElements.forEach((el) => {\n                el.fill(fill.color, fill.opacity);\n            });\n        }\n        /** @hidden */\n        _stroke(strokeOptions) {\n            const stroke = this._evalStrokeOptions(strokeOptions);\n            this.textElements.forEach(el => el.options.set('stroke', stroke));\n        }\n        /** @hidden */\n        _font() {\n            const options = this.options;\n            if (options.fontFamily && defined(options.fontSize)) {\n                const fontOptions = [];\n                if (options.fontStyle) {\n                    fontOptions.push(options.fontStyle);\n                }\n                if (options.fontWeight) {\n                    fontOptions.push(options.fontWeight);\n                }\n                fontOptions.push(options.fontSize + (isNumber(options.fontSize) ? PX : EMPTY));\n                fontOptions.push(options.fontFamily);\n                options.font = fontOptions.join(SPACE);\n            }\n            else {\n                delete options.font;\n            }\n        }\n        /**\n         * Gets or sets the text content of the text block.\n         * @param text The text content to set, or undefined to get current content\n         * @returns The current text content when called as getter\n         */\n        content(text) {\n            return this.drawingElement.content(text);\n        }\n        /**\n         * Redraws the text block with updated options.\n         * @param options New options to apply to the text block\n         */\n        redraw(options) {\n            if (options) {\n                let sizeChanged = false;\n                const textOptions = this.options;\n                options = textColor(options);\n                super.redraw(options);\n                if (options.fontFamily || defined(options.fontSize) || options.fontStyle || options.fontWeight) {\n                    deepExtend(textOptions, {\n                        fontFamily: options.fontFamily,\n                        fontSize: options.fontSize,\n                        fontStyle: options.fontStyle,\n                        fontWeight: options.fontWeight\n                    });\n                    this._font();\n                    this.drawingElement.options.set('font', textOptions.font);\n                    sizeChanged = true;\n                }\n                if (options.text) {\n                    this.content(options.text);\n                    sizeChanged = true;\n                }\n                if (!this._updateSize(options) && sizeChanged) {\n                    this._initSize();\n                }\n            }\n        }\n    }\n\n    /**\n     * @hidden\n     */\n    class TextLayout extends kendo_drawing_cmn_chunk_js.j {\n        measure() {\n            if (!this._rect || this.children.length === 0) {\n                return new kendo_drawing_cmn_chunk_js.o(0, 0);\n            }\n            this._initMap();\n            const { groups, groupsSize } = this._initGroups();\n            if (groups.length === 0) {\n                return new kendo_drawing_cmn_chunk_js.o(0, 0);\n            }\n            const { sizeField, groupsSizeField } = this._fieldMap;\n            let maxSize = 0;\n            for (let i = 0; i < groups.length; i++) {\n                maxSize = Math.max(maxSize, groups[i].size);\n            }\n            const size = new kendo_drawing_cmn_chunk_js.o();\n            size[sizeField] = maxSize;\n            size[groupsSizeField] = groupsSize;\n            return size;\n        }\n        rawBBox() {\n            if (!this._rect || this.children.length === 0) {\n                return new kendo_drawing_cmn_chunk_js.R(this._rect.origin, new kendo_drawing_cmn_chunk_js.o());\n            }\n            const size = this.measure();\n            return new kendo_drawing_cmn_chunk_js.R(this._rect.origin, size);\n        }\n        bbox(transformation) {\n            if (!this._rect || this.children.length === 0) {\n                const emptyRect = new kendo_drawing_cmn_chunk_js.R(this._rect.origin, new kendo_drawing_cmn_chunk_js.o());\n                const transform = this.currentTransform(transformation);\n                return transform ? emptyRect.bbox(transform.matrix()) : emptyRect;\n            }\n            const rawBox = this.rawBBox();\n            const transform = this.currentTransform(transformation);\n            return transform ? rawBox.bbox(transform.matrix()) : rawBox;\n        }\n    }\n\n    class Box {\n        constructor(x1, y1, x2, y2) {\n            this.x1 = x1;\n            this.y1 = y1;\n            this.x2 = x2;\n            this.y2 = y2;\n        }\n        width() {\n            return this.x2 - this.x1;\n        }\n        height() {\n            return this.y2 - this.y1;\n        }\n        pad(padding) {\n            const spacing = { ...padding };\n            this.x1 -= spacing.left;\n            this.x2 += spacing.right;\n            this.y1 -= spacing.top;\n            this.y2 += spacing.bottom;\n            return this;\n        }\n        unpad(padding) {\n            const spacing = { ...padding };\n            spacing.left = (-spacing.left) || 0; // avoid -0 values\n            spacing.top = (-spacing.top) || 0;\n            spacing.right = (-spacing.right) || 0;\n            spacing.bottom = (-spacing.bottom) || 0;\n            return this.pad(spacing);\n        }\n        toRect() {\n            return new kendo_drawing_cmn_chunk_js.R([this.x1, this.y1], [this.width(), this.height()]);\n        }\n    }\n\n    const parseAlign = (align = '') => {\n        const result = {\n            justifyContent: CENTER,\n            alignContent: CENTER\n        };\n        if (align.includes('left')) {\n            result.justifyContent = START$1;\n        }\n        if (align.includes('right')) {\n            result.justifyContent = END$1;\n        }\n        if (align.includes('top')) {\n            result.alignContent = START$1;\n        }\n        if (align.includes('bottom')) {\n            result.alignContent = END$1;\n        }\n        return result;\n    };\n    function getContentSpacing(shape, relativePadding) {\n        const spacing = getSpacing(relativePadding || 0, 0);\n        const left = shape.width * spacing.left;\n        const top = shape.height * spacing.top;\n        const right = shape.width * spacing.right;\n        const bottom = shape.height * spacing.bottom;\n        return { left, top, right, bottom };\n    }\n    /** @hidden */\n    const textRect = (options) => {\n        let shapeSize = options.shapeSize;\n        const { padding, relativePadding } = options;\n        const userPadding = getSpacing(padding || 0, 0);\n        const curPadding = deepExtend({}, defaultTextOptions.padding, userPadding);\n        if (!shapeSize) {\n            const lines = (options.text || EMPTY).split(NEW_LINE_CHAR);\n            const style = getFont(options);\n            const measures = lines.map(line => kendo_drawing_cmn_chunk_js.m(line, style));\n            const maxWidth = measures.reduce((max, measured) => {\n                return Math.max(max, measured.width);\n            }, 0);\n            const totalHeight = measures.reduce((sum, measured) => {\n                return sum + measured.height;\n            }, 0) + (lines.length - 1) * (options.lineSpacing || 0);\n            shapeSize = {\n                width: maxWidth,\n                height: totalHeight\n            };\n        }\n        const userRelativePadding = getContentSpacing(shapeSize, relativePadding || 0);\n        const curRelativePadding = deepExtend({}, defaultTextOptions.relativePadding, userRelativePadding);\n        const box = new Box(0, 0, shapeSize.width, shapeSize.height);\n        box.unpad(curRelativePadding);\n        box.unpad(curPadding);\n        return box.toRect();\n    };\n    /** @hidden */\n    const getFont = (options) => {\n        const font = {\n            fontSize: defined(options.fontSize) ? options.fontSize : defaultTextOptions.fontSize,\n            fontFamily: options.fontFamily || defaultTextOptions.fontFamily\n        };\n        if (options.fontWeight || defaultTextOptions.fontWeight) {\n            font.fontWeight = options.fontWeight || defaultTextOptions.fontWeight;\n        }\n        if (options.fontStyle || defaultTextOptions.fontStyle) {\n            font.fontStyle = options.fontStyle || defaultTextOptions.fontStyle;\n        }\n        return font;\n    };\n    /**\n     * A text block that supports multi-line text with line wrapping and alignment.\n     * Extends TextBlock and provides functionality for rendering text across multiple lines with layout support.\n     */\n    class MultiLineTextBlock extends TextBlock {\n        constructor() {\n            super(...arguments);\n            /** Whether the text block can be aligned within its container. */\n            this.alignable = false;\n            /** @hidden */\n            this.name = 'MultiLineTextBlock';\n        }\n        /**\n         * Gets or sets the text content of the multi-line text block.\n         * @param text The text content to set, or undefined to get current content\n         * @returns The current text content when called as getter\n         */\n        content(text) {\n            if (text !== undefined) {\n                this.options.text = text;\n                this._initText();\n            }\n            return this.options.text;\n        }\n        /** @hidden */\n        _initText() {\n            this.textElements.length = 0;\n            this.alignable = false;\n            const drawingElement = this.drawingElement = this.drawingElement || new kendo_drawing_cmn_chunk_js.G();\n            if (drawingElement.children.length) {\n                drawingElement.clear();\n            }\n            const options = this.options;\n            const rect = textRect(options);\n            const layout = new TextLayout(rect, {\n                ...parseAlign(options.align),\n                lineSpacing: options.lineSpacing\n            });\n            this._textLines(rect ? rect.size.width : undefined).forEach((line) => {\n                const textElement = new kendo_drawing_cmn_chunk_js.T(line, new kendo_drawing_cmn_chunk_js.P(0, 0), {\n                    font: options.font\n                });\n                this.textElements.push(textElement);\n                layout.append(textElement);\n                layout.appendBreak();\n            });\n            layout.reflow();\n            const hasBackground = options.background !== undefined;\n            const hasBorder = options.border !== undefined;\n            if (hasBackground || hasBorder) {\n                // Store the text-only size BEFORE adding background (for proper centering)\n                const textBbox = layout.clippedBBox();\n                if (textBbox) {\n                    // Save text-only dimensions for positioning\n                    this._textOnlyRect = textBbox.clone();\n                    let padding = options.textPadding !== undefined ? options.textPadding : INLINE_PADDING;\n                    if (typeof padding === 'number') {\n                        padding = getSpacing(padding, 0);\n                    }\n                    else {\n                        padding = { ...INLINE_PADDING, ...padding };\n                    }\n                    // Create background rectangle\n                    // Note: stroke is centered on the path, so half will be inside, half outside\n                    const bgRect = new kendo_drawing_cmn_chunk_js.w(new kendo_drawing_cmn_chunk_js.R([\n                        textBbox.origin.x - padding.left,\n                        textBbox.origin.y - padding.top\n                    ], [\n                        textBbox.size.width + padding.left + padding.right,\n                        textBbox.size.height + padding.top + padding.bottom\n                    ]), {\n                        stroke: { color: TRANSPARENT, ...options.border },\n                        fill: { color: options.background }\n                    });\n                    // Insert background rectangle before text\n                    drawingElement.insert(0, bgRect);\n                }\n            }\n            drawingElement.append(layout);\n            // Apply text color (not fill/stroke from options)\n            if (options.color) {\n                this.textElements.forEach((el) => {\n                    el.fill(options.color);\n                });\n            }\n            else if (!hasBackground && !hasBorder) {\n                // Only apply default fill/stroke if no background rectangle\n                this._fill();\n                this._stroke();\n            }\n        }\n        /** @hidden */\n        _textLines(maxWidth) {\n            const { text = EMPTY } = this.options;\n            if (maxWidth === undefined) {\n                return text.split(NEW_LINE_CHAR);\n            }\n            const style = getFont(this.options);\n            const measureText$1 = kendo_drawing_cmn_chunk_js.m;\n            const lines = [];\n            // Split by newline characters first\n            const textLines = text.split(NEW_LINE_CHAR);\n            textLines.forEach((line) => {\n                const words = line.split(SPACE);\n                let currentLine = EMPTY;\n                words.forEach((word) => {\n                    while (measureText$1(word, style).width > maxWidth) {\n                        let part = EMPTY;\n                        for (let i = 1; i <= word.length; i++) {\n                            const testPart = word.substring(0, i);\n                            const width = measureText$1(testPart, style).width;\n                            if (width > maxWidth) {\n                                break;\n                            }\n                            part = testPart;\n                        }\n                        if (!part) {\n                            break;\n                        }\n                        if (currentLine) {\n                            lines.push(currentLine);\n                            currentLine = EMPTY;\n                        }\n                        lines.push(part);\n                        word = word.substring(part.length);\n                    }\n                    const testLine = currentLine ? `${currentLine} ${word}` : word;\n                    const width = measureText$1(testLine, style).width;\n                    if (width > maxWidth && currentLine) {\n                        lines.push(currentLine);\n                        currentLine = word;\n                    }\n                    else {\n                        currentLine = testLine;\n                    }\n                });\n                lines.push(currentLine || SPACE);\n            });\n            return lines;\n        }\n    }\n\n    /**\n     * The Sugiyama aka layered layout algorithm.\n     *\n     * @type {*}\n     */\n    class LayeredLayout extends LayoutBase {\n        constructor(diagram) {\n            super();\n            if (isUndefined(diagram)) {\n                throw new Error('Diagram is not specified.');\n            }\n            this.diagram = diagram;\n        }\n        layout(options) {\n            this.transferOptions(options);\n            const adapter = new DiagramToHyperTreeAdapter(this.diagram);\n            const graph = adapter.convert(options);\n            if (graph.isEmpty()) {\n                return;\n            }\n            // split into connected components\n            const components = graph.getConnectedComponents();\n            if (isEmpty(components)) {\n                return;\n            }\n            for (let i = 0; i < components.length; i++) {\n                const component = components[i];\n                this.layoutGraph(component, options);\n            }\n            const finalNodeSet = this.gridLayoutComponents(components);\n            return new LayoutState(this.diagram, finalNodeSet);\n        }\n        /**\n         * Initializes the runtime data properties of the layout.\n         *\n         * @private\n         */\n        _initRuntimeProperties() {\n            for (let k = 0; k < this.graph.nodes.length; k++) {\n                const node = this.graph.nodes[k];\n                node.layer = -1;\n                node.downstreamLinkCount = 0;\n                node.upstreamLinkCount = 0;\n                node.isVirtual = false;\n                node.uBaryCenter = 0.0;\n                node.dBaryCenter = 0.0;\n                node.upstreamPriority = 0;\n                node.downstreamPriority = 0;\n                node.gridPosition = 0;\n            }\n        }\n        _prepare(graph) {\n            const current = [];\n            let i, l, link;\n            // defines a mapping of a node to the layer index\n            const layerMap = new Dictionary();\n            let layerCount = 0;\n            let targetLayer, next, target;\n            forEach(graph.nodes, function (node) {\n                if (node.incoming.length === 0) {\n                    layerMap.set(node, 0);\n                    current.push(node);\n                }\n            });\n            while (current.length > 0) {\n                next = current.shift();\n                for (i = 0; i < next.outgoing.length; i++) {\n                    link = next.outgoing[i];\n                    target = link.target;\n                    if (layerMap.containsKey(target)) {\n                        targetLayer = Math.max(layerMap.get(next) + 1, layerMap.get(target));\n                    }\n                    else {\n                        targetLayer = layerMap.get(next) + 1;\n                    }\n                    layerMap.set(target, targetLayer);\n                    if (targetLayer > layerCount) {\n                        layerCount = targetLayer;\n                    }\n                    if (!contains(current, target)) {\n                        current.push(target);\n                    }\n                }\n            }\n            const sortedNodes = layerMap.keys();\n            sortedNodes.sort(function (o1, o2) {\n                const o1layer = layerMap.get(o1);\n                const o2layer = layerMap.get(o2);\n                return sign(o2layer - o1layer);\n            });\n            for (let n = 0; n < sortedNodes.length; ++n) {\n                const node = sortedNodes[n];\n                let minLayer = Number.MAX_VALUE;\n                if (node.outgoing.length === 0) {\n                    continue;\n                }\n                for (l = 0; l < node.outgoing.length; ++l) {\n                    link = node.outgoing[l];\n                    minLayer = Math.min(minLayer, layerMap.get(link.target));\n                }\n                if (minLayer > 1) {\n                    layerMap.set(node, minLayer - 1);\n                }\n            }\n            this.layers = [];\n            let layer;\n            for (i = 0; i < layerCount + 1; i++) {\n                layer = [];\n                layer.linksTo = {};\n                this.layers.push(layer);\n            }\n            layerMap.forEach(function (node, layerVal) {\n                node.layer = layerVal;\n                this.layers[layerVal].push(node);\n            }, this);\n            // set initial grid positions\n            for (l = 0; l < this.layers.length; l++) {\n                layer = this.layers[l];\n                for (i = 0; i < layer.length; i++) {\n                    layer[i].gridPosition = i;\n                }\n            }\n        }\n        /**\n         * Performs the layout of a single component.\n         */\n        layoutGraph(graph, options) {\n            if (isUndefined(graph)) {\n                throw new Error('No graph given or graph analysis of the diagram failed.');\n            }\n            if (isDefined(options)) {\n                this.transferOptions(options);\n            }\n            this.graph = graph;\n            // sets unique indices on the nodes\n            graph.setItemIndices();\n            // ensures no cycles present for this layout\n            const reversedEdges = graph.makeAcyclic();\n            // define the runtime props being used by the layout algorithm\n            this._initRuntimeProperties();\n            this._prepare(graph);\n            this._dummify();\n            this._optimizeCrossings();\n            this._swapPairs();\n            this.arrangeNodes();\n            this._moveThingsAround();\n            this._dedummify();\n            // re-reverse the links which were switched earlier\n            forEach(reversedEdges, function (e) {\n                if (e.points) {\n                    e.points.reverse();\n                }\n            });\n        }\n        setMinDist(m, _n, minDist) {\n            const l = m.layer;\n            const i = m.layerIndex;\n            // Validate indices to prevent prototype pollution\n            if (!Number.isInteger(l) || !Number.isInteger(i) || l < 0 || i < 0) {\n                throw new Error('Invalid layer or index value.');\n            }\n            this.minDistances[l][i] = minDist;\n        }\n        getMinDist(m, n) {\n            let dist = 0;\n            const i1 = m.layerIndex, i2 = n.layerIndex, l = m.layer, min = Math.min(i1, i2), max = Math.max(i1, i2);\n            // use Sum()?\n            for (let k = min; k < max; ++k) {\n                dist += this.minDistances[l][k];\n            }\n            return dist;\n        }\n        placeLeftToRight(leftClasses) {\n            const leftPos = new Dictionary();\n            let n, node;\n            for (let c = 0; c < this.layers.length; ++c) {\n                const classNodes = leftClasses[c];\n                if (!classNodes) {\n                    continue;\n                }\n                for (n = 0; n < classNodes.length; n++) {\n                    node = classNodes[n];\n                    if (!leftPos.containsKey(node)) {\n                        this.placeLeft(node, leftPos, c);\n                    }\n                }\n                // adjust class\n                let d = Number.POSITIVE_INFINITY;\n                for (n = 0; n < classNodes.length; n++) {\n                    node = classNodes[n];\n                    const rightSibling = this.rightSibling(node);\n                    if (rightSibling && this.nodeLeftClass.get(rightSibling) !== c) {\n                        d = Math.min(d, leftPos.get(rightSibling) - leftPos.get(node) - this.getMinDist(node, rightSibling));\n                    }\n                }\n                if (d === Number.POSITIVE_INFINITY) {\n                    const D = [];\n                    for (n = 0; n < classNodes.length; n++) {\n                        node = classNodes[n];\n                        const neighbors = [];\n                        addRange(neighbors, this.upNodes.get(node));\n                        addRange(neighbors, this.downNodes.get(node));\n                        for (let e = 0; e < neighbors.length; e++) {\n                            const neighbor = neighbors[e];\n                            if (this.nodeLeftClass.get(neighbor) < c) {\n                                D.push(leftPos.get(neighbor) - leftPos.get(node));\n                            }\n                        }\n                    }\n                    D.sort();\n                    if (D.length === 0) {\n                        d = 0;\n                    }\n                    else if (D.length % 2 === 1) {\n                        d = D[this.intDiv(D.length, 2)];\n                    }\n                    else {\n                        d = (D[this.intDiv(D.length, 2) - 1] + D[this.intDiv(D.length, 2)]) / 2;\n                    }\n                }\n                for (n = 0; n < classNodes.length; n++) {\n                    node = classNodes[n];\n                    leftPos.set(node, leftPos.get(node) + d);\n                }\n            }\n            return leftPos;\n        }\n        placeRightToLeft(rightClasses) {\n            const rightPos = new Dictionary();\n            let n, node;\n            for (let c = 0; c < this.layers.length; ++c) {\n                const classNodes = rightClasses[c];\n                if (!classNodes) {\n                    continue;\n                }\n                for (n = 0; n < classNodes.length; n++) {\n                    node = classNodes[n];\n                    if (!rightPos.containsKey(node)) {\n                        this.placeRight(node, rightPos, c);\n                    }\n                }\n                // adjust class\n                let d = Number.NEGATIVE_INFINITY;\n                for (n = 0; n < classNodes.length; n++) {\n                    node = classNodes[n];\n                    const leftSibling = this.leftSibling(node);\n                    if (leftSibling && this.nodeRightClass.get(leftSibling) !== c) {\n                        d = Math.max(d, rightPos.get(leftSibling) - rightPos.get(node) + this.getMinDist(leftSibling, node));\n                    }\n                }\n                if (d === Number.NEGATIVE_INFINITY) {\n                    const D = [];\n                    for (n = 0; n < classNodes.length; n++) {\n                        node = classNodes[n];\n                        const neighbors = [];\n                        addRange(neighbors, this.upNodes.get(node));\n                        addRange(neighbors, this.downNodes.get(node));\n                        for (let e = 0; e < neighbors.length; e++) {\n                            const neighbor = neighbors[e];\n                            if (this.nodeRightClass.get(neighbor) < c) {\n                                D.push(rightPos.get(node) - rightPos.get(neighbor));\n                            }\n                        }\n                    }\n                    D.sort();\n                    if (D.length === 0) {\n                        d = 0;\n                    }\n                    else if (D.length % 2 === 1) {\n                        d = D[this.intDiv(D.length, 2)];\n                    }\n                    else {\n                        d = (D[this.intDiv(D.length, 2) - 1] + D[this.intDiv(D.length, 2)]) / 2;\n                    }\n                }\n                for (n = 0; n < classNodes.length; n++) {\n                    node = classNodes[n];\n                    rightPos.set(node, rightPos.get(node) + d);\n                }\n            }\n            return rightPos;\n        }\n        _getLeftWing() {\n            const leftWing = { value: null };\n            const result = this.computeClasses(leftWing, 1);\n            this.nodeLeftClass = leftWing.value;\n            return result;\n        }\n        _getRightWing() {\n            const rightWing = { value: null };\n            const result = this.computeClasses(rightWing, -1);\n            this.nodeRightClass = rightWing.value;\n            return result;\n        }\n        computeClasses(wingPair, d) {\n            let currentWing = 0;\n            const wing = wingPair.value = new Dictionary();\n            for (let l = 0; l < this.layers.length; ++l) {\n                currentWing = l;\n                const layer = this.layers[l];\n                for (let n = d === 1 ? 0 : layer.length - 1; n >= 0 && n < layer.length; n += d) {\n                    const node = layer[n];\n                    if (!wing.containsKey(node)) {\n                        wing.set(node, currentWing);\n                        if (node.isVirtual) {\n                            const ndsinl = this._nodesInLink(node);\n                            for (let kk = 0; kk < ndsinl.length; kk++) {\n                                const vnode = ndsinl[kk];\n                                wing.set(vnode, currentWing);\n                            }\n                        }\n                    }\n                    else {\n                        currentWing = wing.get(node);\n                    }\n                }\n            }\n            const wings = [];\n            for (let i = 0; i < this.layers.length; i++) {\n                wings.push(null);\n            }\n            wing.forEach(function (node, classIndex) {\n                if (wings[classIndex] === null) {\n                    wings[classIndex] = [];\n                }\n                wings[classIndex].push(node);\n            });\n            return wings;\n        }\n        _isVerticalLayout() {\n            return this.options.subtype.toLowerCase() === 'up' || this.options.subtype.toLowerCase() === 'down' || this.options.subtype.toLowerCase() === 'vertical';\n        }\n        _isHorizontalLayout() {\n            return this.options.subtype.toLowerCase() === 'right' || this.options.subtype.toLowerCase() === 'left' || this.options.subtype.toLowerCase() === 'horizontal';\n        }\n        _isIncreasingLayout() {\n            // meaning that the visiting of the layers goes in the natural order of increasing layer index\n            return this.options.subtype.toLowerCase() === 'right' || this.options.subtype.toLowerCase() === 'down';\n        }\n        _moveThingsAround() {\n            let i, l, node, layer, n, w;\n            // sort the layers by their grid position\n            for (l = 0; l < this.layers.length; ++l) {\n                layer = this.layers[l];\n                layer.sort(this._gridPositionComparer.bind(this));\n            }\n            this.minDistances = [];\n            for (l = 0; l < this.layers.length; ++l) {\n                layer = this.layers[l];\n                this.minDistances[l] = [];\n                for (n = 0; n < layer.length; ++n) {\n                    node = layer[n];\n                    node.layerIndex = n;\n                    this.minDistances[l][n] = this.options.nodeDistance;\n                    if (n < layer.length - 1) {\n                        if (this._isVerticalLayout()) {\n                            this.minDistances[l][n] += (node.width + layer[n + 1].width) / 2;\n                        }\n                        else {\n                            this.minDistances[l][n] += (node.height + layer[n + 1].height) / 2;\n                        }\n                    }\n                }\n            }\n            this.downNodes = new Dictionary();\n            this.upNodes = new Dictionary();\n            forEach(this.graph.nodes, function (gNode) {\n                this.downNodes.set(gNode, []);\n                this.upNodes.set(gNode, []);\n            }, this);\n            forEach(this.graph.links, function (link) {\n                const origin = link.source;\n                const dest = link.target;\n                let down = null, up = null;\n                if (origin.layer > dest.layer) {\n                    down = link.source;\n                    up = link.target;\n                }\n                else {\n                    up = link.source;\n                    down = link.target;\n                }\n                this.downNodes.get(up).push(down);\n                this.upNodes.get(down).push(up);\n            }, this);\n            this.downNodes.forEachValue(function (list) {\n                list.sort(this._gridPositionComparer);\n            }, this);\n            this.upNodes.forEachValue(function (list) {\n                list.sort(this._gridPositionComparer);\n            }, this);\n            for (l = 0; l < this.layers.length - 1; ++l) {\n                layer = this.layers[l];\n                for (w = 0; w < layer.length - 1; w++) {\n                    const currentNode = layer[w];\n                    if (!currentNode.isVirtual) {\n                        continue;\n                    }\n                    const currDown = this.downNodes.get(currentNode)[0];\n                    if (!currDown.isVirtual) {\n                        continue;\n                    }\n                    for (n = w + 1; n < layer.length; ++n) {\n                        node = layer[n];\n                        if (!node.isVirtual) {\n                            continue;\n                        }\n                        const downNode = this.downNodes.get(node)[0];\n                        if (!downNode.isVirtual) {\n                            continue;\n                        }\n                        if (currDown.gridPosition > downNode.gridPosition) {\n                            const pos = currDown.gridPosition;\n                            currDown.gridPosition = downNode.gridPosition;\n                            downNode.gridPosition = pos;\n                            const i1 = currDown.layerIndex;\n                            const i2 = downNode.layerIndex;\n                            this.layers[l + 1][i1] = downNode;\n                            this.layers[l + 1][i2] = currDown;\n                            currDown.layerIndex = i2;\n                            downNode.layerIndex = i1;\n                        }\n                    }\n                }\n            }\n            const leftClasses = this._getLeftWing();\n            const rightClasses = this._getRightWing();\n            const leftPos = this.placeLeftToRight(leftClasses);\n            const rightPos = this.placeRightToLeft(rightClasses);\n            const x = new Dictionary();\n            forEach(this.graph.nodes, function (gNode) {\n                x.set(gNode, (leftPos.get(gNode) + rightPos.get(gNode)) / 2);\n            });\n            const order = new Dictionary();\n            const placed = new Dictionary();\n            for (l = 0; l < this.layers.length; ++l) {\n                layer = this.layers[l];\n                let sequenceStart = -1; // , sequenceEnd = -1;\n                for (n = 0; n < layer.length; ++n) {\n                    node = layer[n];\n                    order.set(node, 0);\n                    placed.set(node, false);\n                    if (node.isVirtual) {\n                        if (sequenceStart === -1) {\n                            sequenceStart = n;\n                        }\n                        else if (sequenceStart === n - 1) {\n                            sequenceStart = n;\n                        }\n                        else {\n                            // sequenceEnd = n;\n                            order.set(layer[sequenceStart], 0);\n                            if (x.get(node) - x.get(layer[sequenceStart]) === this.getMinDist(layer[sequenceStart], node)) {\n                                placed.set(layer[sequenceStart], true);\n                            }\n                            else {\n                                placed.set(layer[sequenceStart], false);\n                            }\n                            sequenceStart = n;\n                        }\n                    }\n                }\n            }\n            const directions = [1, -1];\n            forEach(directions, function (d) {\n                const start = d === 1 ? 0 : this.layers.length - 1;\n                for (let ll = start; ll >= 0 && ll < this.layers.length; ll += d) {\n                    const layer2 = this.layers[ll];\n                    let virtualStartIndex = this._firstVirtualNode(layer2);\n                    let virtualStart = null;\n                    let sequence = null;\n                    if (virtualStartIndex !== -1) {\n                        virtualStart = layer2[virtualStartIndex];\n                        sequence = [];\n                        for (i = 0; i < virtualStartIndex; i++) {\n                            sequence.push(layer2[i]);\n                        }\n                    }\n                    else {\n                        virtualStart = null;\n                        sequence = layer2;\n                    }\n                    if (sequence.length > 0) {\n                        this._sequencer(x, null, virtualStart, d, sequence);\n                        for (i = 0; i < sequence.length - 1; ++i) {\n                            this.setMinDist(sequence[i], sequence[i + 1], x.get(sequence[i + 1]) - x.get(sequence[i]));\n                        }\n                        if (virtualStart) {\n                            this.setMinDist(sequence[sequence.length - 1], virtualStart, x.get(virtualStart) - x.get(sequence[sequence.length - 1]));\n                        }\n                    }\n                    while (virtualStart) {\n                        const virtualEnd = this.nextVirtualNode(layer2, virtualStart);\n                        if (!virtualEnd) {\n                            virtualStartIndex = virtualStart.layerIndex;\n                            sequence = [];\n                            for (i = virtualStartIndex + 1; i < layer2.length; i++) {\n                                sequence.push(layer2[i]);\n                            }\n                            if (sequence.length > 0) {\n                                this._sequencer(x, virtualStart, null, d, sequence);\n                                for (i = 0; i < sequence.length - 1; ++i) {\n                                    this.setMinDist(sequence[i], sequence[i + 1], x.get(sequence[i + 1]) - x.get(sequence[i]));\n                                }\n                                this.setMinDist(virtualStart, sequence[0], x.get(sequence[0]) - x.get(virtualStart));\n                            }\n                        }\n                        else if (order.get(virtualStart) === d) {\n                            virtualStartIndex = virtualStart.layerIndex;\n                            const virtualEndIndex = virtualEnd.layerIndex;\n                            sequence = [];\n                            for (i = virtualStartIndex + 1; i < virtualEndIndex; i++) {\n                                sequence.push(layer2[i]);\n                            }\n                            if (sequence.length > 0) {\n                                this._sequencer(x, virtualStart, virtualEnd, d, sequence);\n                            }\n                            placed.set(virtualStart, true);\n                        }\n                        virtualStart = virtualEnd;\n                    }\n                    this.adjustDirections(ll, d, order, placed);\n                }\n            }, this);\n            const fromLayerIndex = this._isIncreasingLayout() ? 0 : this.layers.length - 1;\n            const reachedFinalLayerIndex = function (k, ctx) {\n                if (ctx._isIncreasingLayout()) {\n                    return k < ctx.layers.length;\n                }\n                else {\n                    return k >= 0;\n                }\n            };\n            const layerIncrement = this._isIncreasingLayout() ? +1 : -1;\n            let offset = 0;\n            /**\n             * Calcs the max height of the given layer.\n             */\n            function maximumHeight(layer2, ctx) {\n                let height = Number.MIN_VALUE;\n                for (let nn = 0; nn < layer2.length; ++nn) {\n                    const node2 = layer2[nn];\n                    if (ctx._isVerticalLayout()) {\n                        height = Math.max(height, node2.height);\n                    }\n                    else {\n                        height = Math.max(height, node2.width);\n                    }\n                }\n                return height;\n            }\n            for (i = fromLayerIndex; reachedFinalLayerIndex(i, this); i += layerIncrement) {\n                layer = this.layers[i];\n                const height = maximumHeight(layer, this);\n                for (n = 0; n < layer.length; ++n) {\n                    node = layer[n];\n                    if (this._isVerticalLayout()) {\n                        node.x = x.get(node);\n                        node.y = offset + height / 2;\n                    }\n                    else {\n                        node.x = offset + height / 2;\n                        node.y = x.get(node);\n                    }\n                }\n                offset += this.options.layerSeparation + height;\n            }\n        }\n        adjustDirections(l, d, order, placed) {\n            if (l + d < 0 || l + d >= this.layers.length) {\n                return;\n            }\n            let prevBridge = null, prevBridgeTarget = null;\n            const layer = this.layers[l + d];\n            for (let n = 0; n < layer.length; ++n) {\n                const nextBridge = layer[n];\n                if (nextBridge.isVirtual) {\n                    const nextBridgeTarget = this.getNeighborOnLayer(nextBridge, l);\n                    if (nextBridgeTarget.isVirtual) {\n                        if (prevBridge) {\n                            let p = placed.get(prevBridgeTarget);\n                            const clayer = this.layers[l];\n                            const i1 = prevBridgeTarget.layerIndex;\n                            const i2 = nextBridgeTarget.layerIndex;\n                            for (let i = i1 + 1; i < i2; ++i) {\n                                if (clayer[i].isVirtual) {\n                                    p = p && placed.get(clayer[i]);\n                                }\n                            }\n                            if (p) {\n                                order.set(prevBridge, d);\n                                const j1 = prevBridge.layerIndex;\n                                const j2 = nextBridge.layerIndex;\n                                for (let j = j1 + 1; j < j2; ++j) {\n                                    if (layer[j].isVirtual) {\n                                        order.set(layer[j], d);\n                                    }\n                                }\n                            }\n                        }\n                        prevBridge = nextBridge;\n                        prevBridgeTarget = nextBridgeTarget;\n                    }\n                }\n            }\n        }\n        getNeighborOnLayer(node, l) {\n            let neighbor = this.upNodes.get(node)[0];\n            if (neighbor.layer === l) {\n                return neighbor;\n            }\n            neighbor = this.downNodes.get(node)[0];\n            if (neighbor.layer === l) {\n                return neighbor;\n            }\n            return null;\n        }\n        _sequencer(x, virtualStart, virtualEnd, dir, sequence) {\n            if (sequence.length === 1) {\n                this._sequenceSingle(x, virtualStart, virtualEnd, dir, sequence[0]);\n            }\n            if (sequence.length > 1) {\n                const r = sequence.length, t = this.intDiv(r, 2);\n                this._sequencer(x, virtualStart, virtualEnd, dir, sequence.slice(0, t));\n                this._sequencer(x, virtualStart, virtualEnd, dir, sequence.slice(t));\n                this.combineSequences(x, virtualStart, virtualEnd, dir, sequence);\n            }\n        }\n        _sequenceSingle(x, virtualStart, virtualEnd, dir, node) {\n            const neighbors = dir === -1 ? this.downNodes.get(node) : this.upNodes.get(node);\n            const n = neighbors.length;\n            if (n !== 0) {\n                if (n % 2 === 1) {\n                    x.set(node, x.get(neighbors[this.intDiv(n, 2)]));\n                }\n                else {\n                    x.set(node, (x.get(neighbors[this.intDiv(n, 2) - 1]) + x.get(neighbors[this.intDiv(n, 2)])) / 2);\n                }\n                if (virtualStart) {\n                    x.set(node, Math.max(x.get(node), x.get(virtualStart) + this.getMinDist(virtualStart, node)));\n                }\n                if (virtualEnd) {\n                    x.set(node, Math.min(x.get(node), x.get(virtualEnd) - this.getMinDist(node, virtualEnd)));\n                }\n            }\n        }\n        combineSequences(x, virtualStart, virtualEnd, dir, sequence) {\n            const r = sequence.length, t = this.intDiv(r, 2);\n            // collect left changes\n            const leftHeap = [];\n            let i, c, n, neighbors, neighbor, pair;\n            for (i = 0; i < t; ++i) {\n                c = 0;\n                neighbors = dir === -1 ? this.downNodes.get(sequence[i]) : this.upNodes.get(sequence[i]);\n                for (n = 0; n < neighbors.length; ++n) {\n                    neighbor = neighbors[n];\n                    if (x.get(neighbor) >= x.get(sequence[i])) {\n                        c++;\n                    }\n                    else {\n                        c--;\n                        leftHeap.push({ k: x.get(neighbor) + this.getMinDist(sequence[i], sequence[t - 1]), v: 2 });\n                    }\n                }\n                leftHeap.push({ k: x.get(sequence[i]) + this.getMinDist(sequence[i], sequence[t - 1]), v: c });\n            }\n            if (virtualStart) {\n                leftHeap.push({ k: x.get(virtualStart) + this.getMinDist(virtualStart, sequence[t - 1]), v: Number.MAX_VALUE });\n            }\n            leftHeap.sort(this._positionDescendingComparer.bind(this));\n            // collect right changes\n            const rightHeap = [];\n            for (i = t; i < r; ++i) {\n                c = 0;\n                neighbors = dir === -1 ? this.downNodes.get(sequence[i]) : this.upNodes.get(sequence[i]);\n                for (n = 0; n < neighbors.length; ++n) {\n                    neighbor = neighbors[n];\n                    if (x.get(neighbor) <= x.get(sequence[i])) {\n                        c++;\n                    }\n                    else {\n                        c--;\n                        rightHeap.push({ k: x.get(neighbor) - this.getMinDist(sequence[i], sequence[t]), v: 2 });\n                    }\n                }\n                rightHeap.push({ k: x.get(sequence[i]) - this.getMinDist(sequence[i], sequence[t]), v: c });\n            }\n            if (virtualEnd) {\n                rightHeap.push({ k: x.get(virtualEnd) - this.getMinDist(virtualEnd, sequence[t]), v: Number.MAX_VALUE });\n            }\n            rightHeap.sort(this._positionAscendingComparer.bind(this));\n            let leftRes = 0, rightRes = 0;\n            const m = this.getMinDist(sequence[t - 1], sequence[t]);\n            while (x.get(sequence[t]) - x.get(sequence[t - 1]) < m) {\n                if (leftRes < rightRes) {\n                    if (leftHeap.length === 0) {\n                        x.set(sequence[t - 1], x.get(sequence[t]) - m);\n                        break;\n                    }\n                    else {\n                        pair = leftHeap.shift();\n                        leftRes = leftRes + pair.v;\n                        x.set(sequence[t - 1], pair.k);\n                        x.set(sequence[t - 1], Math.max(x.get(sequence[t - 1]), x.get(sequence[t]) - m));\n                    }\n                }\n                else {\n                    if (rightHeap.length === 0) {\n                        x.set(sequence[t], x.get(sequence[t - 1]) + m);\n                        break;\n                    }\n                    else {\n                        pair = rightHeap.shift();\n                        rightRes = rightRes + pair.v;\n                        x.set(sequence[t], pair.k);\n                        x.set(sequence[t], Math.min(x.get(sequence[t]), x.get(sequence[t - 1]) + m));\n                    }\n                }\n            }\n            for (i = t - 2; i >= 0; i--) {\n                x.set(sequence[i], Math.min(x.get(sequence[i]), x.get(sequence[t - 1]) - this.getMinDist(sequence[i], sequence[t - 1])));\n            }\n            for (i = t + 1; i < r; i++) {\n                x.set(sequence[i], Math.max(x.get(sequence[i]), x.get(sequence[t]) + this.getMinDist(sequence[i], sequence[t])));\n            }\n        }\n        placeLeft(node, leftPos, leftClass) {\n            let pos = Number.NEGATIVE_INFINITY;\n            forEach(this._getComposite(node), function (v) {\n                const leftSibling = this.leftSibling(v);\n                if (leftSibling && this.nodeLeftClass.get(leftSibling) === this.nodeLeftClass.get(v)) {\n                    if (!leftPos.containsKey(leftSibling)) {\n                        this.placeLeft(leftSibling, leftPos, leftClass);\n                    }\n                    pos = Math.max(pos, leftPos.get(leftSibling) + this.getMinDist(leftSibling, v));\n                }\n            }, this);\n            if (pos === Number.NEGATIVE_INFINITY) {\n                pos = 0;\n            }\n            forEach(this._getComposite(node), function (v) {\n                leftPos.set(v, pos);\n            });\n        }\n        placeRight(node, rightPos, rightClass) {\n            let pos = Number.POSITIVE_INFINITY;\n            forEach(this._getComposite(node), function (v) {\n                const rightSibling = this.rightSibling(v);\n                if (rightSibling && this.nodeRightClass.get(rightSibling) === this.nodeRightClass.get(v)) {\n                    if (!rightPos.containsKey(rightSibling)) {\n                        this.placeRight(rightSibling, rightPos, rightClass);\n                    }\n                    pos = Math.min(pos, rightPos.get(rightSibling) - this.getMinDist(v, rightSibling));\n                }\n            }, this);\n            if (pos === Number.POSITIVE_INFINITY) {\n                pos = 0;\n            }\n            forEach(this._getComposite(node), function (v) {\n                rightPos.set(v, pos);\n            });\n        }\n        leftSibling(node) {\n            const layer = this.layers[node.layer], layerIndex = node.layerIndex;\n            return layerIndex === 0 ? null : layer[layerIndex - 1];\n        }\n        rightSibling(node) {\n            const layer = this.layers[node.layer];\n            const layerIndex = node.layerIndex;\n            return layerIndex === layer.length - 1 ? null : layer[layerIndex + 1];\n        }\n        _getComposite(node) {\n            return node.isVirtual ? this._nodesInLink(node) : [node];\n        }\n        arrangeNodes() {\n            let i, l, ni, layer, node;\n            // Initialize node's base priority\n            for (l = 0; l < this.layers.length; l++) {\n                layer = this.layers[l];\n                for (ni = 0; ni < layer.length; ni++) {\n                    node = layer[ni];\n                    node.upstreamPriority = node.upstreamLinkCount;\n                    node.downstreamPriority = node.downstreamLinkCount;\n                }\n            }\n            // Layout is invoked after MinimizeCrossings\n            // so we may assume node's barycenters are initially correct\n            const maxLayoutIterations = 2;\n            for (let it = 0; it < maxLayoutIterations; it++) {\n                for (i = this.layers.length - 1; i >= 1; i--) {\n                    this.layoutLayer(false, i);\n                }\n                for (i = 0; i < this.layers.length - 1; i++) {\n                    this.layoutLayer(true, i);\n                }\n            }\n            // Offset the whole structure so that there are no gridPositions < 0\n            let gridPos = Number.MAX_VALUE;\n            for (l = 0; l < this.layers.length; l++) {\n                layer = this.layers[l];\n                for (ni = 0; ni < layer.length; ni++) {\n                    node = layer[ni];\n                    gridPos = Math.min(gridPos, node.gridPosition);\n                }\n            }\n            if (gridPos < 0) {\n                for (l = 0; l < this.layers.length; l++) {\n                    layer = this.layers[l];\n                    for (ni = 0; ni < layer.length; ni++) {\n                        node = layer[ni];\n                        node.gridPosition = node.gridPosition - gridPos;\n                    }\n                }\n            }\n        }\n        /// <summary>\n        /// Layout of a single layer.\n        /// </summary>\n        /// <param name=\"layerIndex\">The layer to organize.</param>\n        /// <param name=\"movingDownwards\">If set to <c>true</c> we move down in the layer stack.</param>\n        /// <seealso cref=\"OptimizeCrossings()\"/>\n        layoutLayer(down, layer) {\n            let iconsidered;\n            let considered;\n            if (down) {\n                considered = this.layers[iconsidered = layer + 1];\n            }\n            else {\n                considered = this.layers[iconsidered = layer - 1];\n            }\n            // list containing the nodes in the considered layer sorted by priority\n            const sorted = [];\n            for (let n = 0; n < considered.length; n++) {\n                sorted.push(considered[n]);\n            }\n            sorted.sort(function (n1, n2) {\n                const n1Priority = (n1.upstreamPriority + n1.downstreamPriority) / 2;\n                const n2Priority = (n2.upstreamPriority + n2.downstreamPriority) / 2;\n                if (Math.abs(n1Priority - n2Priority) < 0.0001) {\n                    return 0;\n                }\n                if (n1Priority < n2Priority) {\n                    return 1;\n                }\n                return -1;\n            });\n            // each node strives for its barycenter; high priority nodes start first\n            forEach(sorted, function (node) {\n                let nodeGridPos = node.gridPosition;\n                const nodeBaryCenter = this.calcBaryCenter(node);\n                const nodePriority = (node.upstreamPriority + node.downstreamPriority) / 2;\n                if (Math.abs(nodeGridPos - nodeBaryCenter) < 0.0001) {\n                    // This node is exactly at its barycenter -> perfect\n                    return;\n                }\n                if (Math.abs(nodeGridPos - nodeBaryCenter) < 0.25 + 0.0001) {\n                    // This node is close enough to the barycenter -> should work\n                    return;\n                }\n                if (nodeGridPos < nodeBaryCenter) {\n                    // Try to move the node to the right in an\n                    // attempt to reach its barycenter\n                    while (nodeGridPos < nodeBaryCenter) {\n                        if (!this.moveRight(node, considered, nodePriority)) {\n                            break;\n                        }\n                        nodeGridPos = node.gridPosition;\n                    }\n                }\n                else {\n                    // Try to move the node to the left in an\n                    // attempt to reach its barycenter\n                    while (nodeGridPos > nodeBaryCenter) {\n                        if (!this.moveLeft(node, considered, nodePriority)) {\n                            break;\n                        }\n                        nodeGridPos = node.gridPosition;\n                    }\n                }\n            }, this);\n            // after the layer has been rearranged we need to recalculate the barycenters\n            // of the nodes in the surrounding layers\n            if (iconsidered > 0) {\n                this.calcDownData(iconsidered - 1);\n            }\n            if (iconsidered < this.layers.length - 1) {\n                this.calcUpData(iconsidered + 1);\n            }\n        }\n        /// <summary>\n        /// Moves the node to the right and returns <c>true</c> if this was possible.\n        /// </summary>\n        /// <param name=\"node\">The node.</param>\n        /// <param name=\"layer\">The layer.</param>\n        /// <returns>Returns <c>true</c> if the shift was possible, otherwise <c>false</c>.</returns>\n        moveRight(node, layer, priority) {\n            const index = indexOf(layer, node);\n            if (index === layer.length - 1) {\n                // this is the last node in the layer, so we can move to the right without troubles\n                node.gridPosition = node.gridPosition + 0.5;\n                return true;\n            }\n            const rightNode = layer[index + 1];\n            const rightNodePriority = (rightNode.upstreamPriority + rightNode.downstreamPriority) / 2;\n            // check if there is space between the right and the current node\n            if (rightNode.gridPosition > node.gridPosition + 1) {\n                node.gridPosition = node.gridPosition + 0.5;\n                return true;\n            }\n            // we have reached a node with higher priority; no movement is allowed\n            if (rightNodePriority > priority ||\n                Math.abs(rightNodePriority - priority) < 0.0001) {\n                return false;\n            }\n            // the right node has lower priority - try to move it\n            if (this.moveRight(rightNode, layer, priority)) {\n                node.gridPosition = node.gridPosition + 0.5;\n                return true;\n            }\n            return false;\n        }\n        /// <summary>\n        /// Moves the node to the left and returns <c>true</c> if this was possible.\n        /// </summary>\n        /// <param name=\"node\">The node.</param>\n        /// <param name=\"layer\">The layer.</param>\n        /// <returns>Returns <c>true</c> if the shift was possible, otherwise <c>false</c>.</returns>\n        moveLeft(node, layer, priority) {\n            const index = indexOf(layer, node);\n            if (index === 0) {\n                // this is the last node in the layer, so we can move to the left without troubles\n                node.gridPosition = node.gridPosition - 0.5;\n                return true;\n            }\n            const leftNode = layer[index - 1];\n            const leftNodePriority = (leftNode.upstreamPriority + leftNode.downstreamPriority) / 2;\n            // check if there is space between the left and the current node\n            if (leftNode.gridPosition < node.gridPosition - 1) {\n                node.gridPosition = node.gridPosition - 0.5;\n                return true;\n            }\n            // we have reached a node with higher priority; no movement is allowed\n            if (leftNodePriority > priority ||\n                Math.abs(leftNodePriority - priority) < 0.0001) {\n                return false;\n            }\n            // The left node has lower priority - try to move it\n            if (this.moveLeft(leftNode, layer, priority)) {\n                node.gridPosition = node.gridPosition - 0.5;\n                return true;\n            }\n            return false;\n        }\n        mapVirtualNode(node, link) {\n            this.nodeToLinkMap.set(node, link);\n            if (!this.linkToNodeMap.containsKey(link)) {\n                this.linkToNodeMap.set(link, []);\n            }\n            this.linkToNodeMap.get(link).push(node);\n        }\n        _nodesInLink(node) {\n            return this.linkToNodeMap.get(this.nodeToLinkMap.get(node));\n        }\n        /// <summary>\n        /// Inserts dummy nodes to break long links.\n        /// </summary>\n        _dummify() {\n            this.linkToNodeMap = new Dictionary();\n            this.nodeToLinkMap = new Dictionary();\n            const links = this.graph.links.slice(0);\n            const layers = this.layers;\n            let layer, pos, newNode, node, r, newLink, i, l;\n            const addLinkBetweenLayers = function (upLayer, downLayer, link) {\n                layers[upLayer].linksTo[downLayer] = layers[upLayer].linksTo[downLayer] || [];\n                layers[upLayer].linksTo[downLayer].push(link);\n            };\n            for (l = 0; l < links.length; l++) {\n                const link = links[l];\n                const o = link.source;\n                const d = link.target;\n                const oLayer = o.layer;\n                const dLayer = d.layer;\n                const oPos = o.gridPosition;\n                const dPos = d.gridPosition;\n                const step = (dPos - oPos) / Math.abs(dLayer - oLayer);\n                let p = o;\n                if (oLayer - dLayer > 1) {\n                    for (i = oLayer - 1; i > dLayer; i--) {\n                        newNode = new Node();\n                        newNode.x = o.x;\n                        newNode.y = o.y;\n                        newNode.width = o.width / 100;\n                        newNode.height = o.height / 100;\n                        layer = layers[i];\n                        pos = (i - dLayer) * step + oPos;\n                        if (pos > layer.length) {\n                            pos = layer.length;\n                        }\n                        // check if origin and dest are both last\n                        if (oPos >= layers[oLayer].length - 1 &&\n                            dPos >= layers[dLayer].length - 1) {\n                            pos = layer.length;\n                        }\n                        else if (oPos === 0 && dPos === 0) { // check if origin and destination are both first\n                            pos = 0;\n                        }\n                        newNode.layer = i;\n                        newNode.uBaryCenter = 0.0;\n                        newNode.dBaryCenter = 0.0;\n                        newNode.upstreamLinkCount = 0;\n                        newNode.downstreamLinkCount = 0;\n                        newNode.gridPosition = pos;\n                        newNode.isVirtual = true;\n                        insert(layer, newNode, pos);\n                        // translate rightwards nodes' positions\n                        for (r = pos + 1; r < layer.length; r++) {\n                            node = layer[r];\n                            node.gridPosition = node.gridPosition + 1;\n                        }\n                        newLink = new Link(p, newNode);\n                        newLink.depthOfDumminess = 0;\n                        addLinkBetweenLayers(i - 1, i, newLink);\n                        p = newNode;\n                        // add the new node and the new link to the graph\n                        this.graph._addNode(newNode);\n                        this.graph.addLink(newLink);\n                        newNode.index = this.graph.nodes.length - 1;\n                        this.mapVirtualNode(newNode, link);\n                    }\n                    // set the origin of the real arrow to the last dummy\n                    addLinkBetweenLayers(dLayer - 1, dLayer, newLink);\n                    link.changeSource(p);\n                    link.depthOfDumminess = oLayer - dLayer - 1;\n                }\n                else if (oLayer - dLayer < -1) {\n                    for (i = oLayer + 1; i < dLayer; i++) {\n                        newNode = new Node();\n                        newNode.x = o.x;\n                        newNode.y = o.y;\n                        newNode.width = o.width / 100;\n                        newNode.height = o.height / 100;\n                        layer = layers[i];\n                        pos = (i - oLayer) * step + oPos;\n                        if (pos > layer.length) {\n                            pos = layer.length;\n                        }\n                        // check if origin and dest are both last\n                        if (oPos >= layers[oLayer].length - 1 &&\n                            dPos >= layers[dLayer].length - 1) {\n                            pos = layer.length;\n                        }\n                        else if (oPos === 0 && dPos === 0) { // check if origin and destination are both first\n                            pos = 0;\n                        }\n                        newNode.layer = i;\n                        newNode.uBaryCenter = 0.0;\n                        newNode.dBaryCenter = 0.0;\n                        newNode.upstreamLinkCount = 0;\n                        newNode.downstreamLinkCount = 0;\n                        newNode.gridPosition = pos;\n                        newNode.isVirtual = true;\n                        pos = Math.floor(pos); // truncates to int\n                        insert(layer, newNode, pos);\n                        // translate rightwards nodes' positions\n                        for (r = pos + 1; r < layer.length; r++) {\n                            node = layer[r];\n                            node.gridPosition = node.gridPosition + 1;\n                        }\n                        newLink = new Link(p, newNode);\n                        newLink.depthOfDumminess = 0;\n                        addLinkBetweenLayers(i - 1, i, newLink);\n                        p = newNode;\n                        // add the new node and the new link to the graph\n                        this.graph._addNode(newNode);\n                        this.graph.addLink(newLink);\n                        newNode.index = this.graph.nodes.length - 1;\n                        this.mapVirtualNode(newNode, link);\n                    }\n                    addLinkBetweenLayers(dLayer - 1, dLayer, link);\n                    // Set the origin of the real arrow to the last dummy\n                    link.changeSource(p);\n                    link.depthOfDumminess = dLayer - oLayer - 1;\n                }\n                else {\n                    addLinkBetweenLayers(oLayer, dLayer, link);\n                }\n            }\n        }\n        /// <summary>\n        /// Removes the dummy nodes inserted earlier to break long links.\n        /// </summary>\n        /// <remarks>The virtual nodes are effectively turned into intermediate connection points.</remarks>\n        _dedummify() {\n            let dedum = true;\n            while (dedum) {\n                dedum = false;\n                for (let l = 0; l < this.graph.links.length; l++) {\n                    const link = this.graph.links[l];\n                    if (!link.depthOfDumminess) {\n                        continue;\n                    }\n                    const points = [];\n                    // add points in reverse order\n                    points.unshift({ x: link.target.x, y: link.target.y });\n                    points.unshift({ x: link.source.x, y: link.source.y });\n                    // _dedummify the link\n                    let temp = link;\n                    const depthOfDumminess = link.depthOfDumminess;\n                    for (let d = 0; d < depthOfDumminess; d++) {\n                        const node = temp.source;\n                        const prevLink = node.incoming[0];\n                        points.unshift({ x: prevLink.source.x, y: prevLink.source.y });\n                        temp = prevLink;\n                    }\n                    // restore the original link origin\n                    link.changeSource(temp.source);\n                    // reset dummification flag\n                    link.depthOfDumminess = 0;\n                    // note that we only need the intermediate points, floating links have been dropped in the analysis\n                    if (points.length > 2) {\n                        // first and last are the endpoints\n                        points.splice(0, 1);\n                        points.splice(points.length - 1);\n                        link.points = points;\n                    }\n                    else {\n                        link.points = [];\n                    }\n                    // we are not going to delete the dummy elements;\n                    // they won't be needed anymore anyway.\n                    dedum = true;\n                    break;\n                }\n            }\n        }\n        /// <summary>\n        /// Optimizes/reduces the crossings between the layers by turning the crossing problem into a (combinatorial) number ordering problem.\n        /// </summary>\n        _optimizeCrossings() {\n            let moves = -1, i;\n            const maxIterations = 3;\n            let iter = 0;\n            while (moves !== 0) {\n                if (iter++ > maxIterations) {\n                    break;\n                }\n                moves = 0;\n                for (i = this.layers.length - 1; i >= 1; i--) {\n                    moves += this.optimizeLayerCrossings(false, i);\n                }\n                for (i = 0; i < this.layers.length - 1; i++) {\n                    moves += this.optimizeLayerCrossings(true, i);\n                }\n            }\n        }\n        calcUpData(layer) {\n            if (layer === 0) {\n                return;\n            }\n            const considered = this.layers[layer];\n            let i, l, link;\n            const upLayer = new Set();\n            const temp = this.layers[layer - 1];\n            for (i = 0; i < temp.length; i++) {\n                upLayer.add(temp[i]);\n            }\n            for (i = 0; i < considered.length; i++) {\n                const node = considered[i];\n                // calculate barycenter\n                let sum = 0;\n                let total = 0;\n                for (l = 0; l < node.incoming.length; l++) {\n                    link = node.incoming[l];\n                    if (upLayer.contains(link.source)) {\n                        total++;\n                        sum += link.source.gridPosition;\n                    }\n                }\n                for (l = 0; l < node.outgoing.length; l++) {\n                    link = node.outgoing[l];\n                    if (upLayer.contains(link.target)) {\n                        total++;\n                        sum += link.target.gridPosition;\n                    }\n                }\n                if (total > 0) {\n                    node.uBaryCenter = sum / total;\n                    node.upstreamLinkCount = total;\n                }\n                else {\n                    node.uBaryCenter = i;\n                    node.upstreamLinkCount = 0;\n                }\n            }\n        }\n        calcDownData(layer) {\n            if (layer === this.layers.length - 1) {\n                return;\n            }\n            const considered = this.layers[layer];\n            let i, l, link;\n            const downLayer = new Set();\n            const temp = this.layers[layer + 1];\n            for (i = 0; i < temp.length; i++) {\n                downLayer.add(temp[i]);\n            }\n            for (i = 0; i < considered.length; i++) {\n                const node = considered[i];\n                // calculate barycenter\n                let sum = 0;\n                let total = 0;\n                for (l = 0; l < node.incoming.length; l++) {\n                    link = node.incoming[l];\n                    if (downLayer.contains(link.source)) {\n                        total++;\n                        sum += link.source.gridPosition;\n                    }\n                }\n                for (l = 0; l < node.outgoing.length; l++) {\n                    link = node.outgoing[l];\n                    if (downLayer.contains(link.target)) {\n                        total++;\n                        sum += link.target.gridPosition;\n                    }\n                }\n                if (total > 0) {\n                    node.dBaryCenter = sum / total;\n                    node.downstreamLinkCount = total;\n                }\n                else {\n                    node.dBaryCenter = i;\n                    node.downstreamLinkCount = 0;\n                }\n            }\n        }\n        /// <summary>\n        /// Optimizes the crossings.\n        /// </summary>\n        /// <remarks>The big trick here is the usage of weights or values attached to connected nodes which turn a problem of crossing links\n        /// to an a problem of ordering numbers.</remarks>\n        /// <param name=\"layerIndex\">The layer index.</param>\n        /// <param name=\"movingDownwards\">If set to <c>true</c> we move down in the layer stack.</param>\n        /// <returns>The number of nodes having moved, i.e. the number of crossings reduced.</returns>\n        optimizeLayerCrossings(down, layer) {\n            let iconsidered;\n            let considered;\n            if (down) {\n                considered = this.layers[iconsidered = layer + 1];\n            }\n            else {\n                considered = this.layers[iconsidered = layer - 1];\n            }\n            // remember what it was\n            const presorted = considered.slice(0);\n            // calculate barycenters for all nodes in the considered layer\n            if (down) {\n                this.calcUpData(iconsidered);\n            }\n            else {\n                this.calcDownData(iconsidered);\n            }\n            // sort nodes within this layer according to the barycenters\n            considered.sort((n1, n2) => {\n                const n1BaryCenter = this.calcBaryCenter(n1), n2BaryCenter = this.calcBaryCenter(n2);\n                if (Math.abs(n1BaryCenter - n2BaryCenter) < 0.0001) {\n                    // in case of coinciding barycenters compare by the count of in/out links\n                    if (n1.degree() === n2.degree()) {\n                        return this.compareByIndex(n1, n2);\n                    }\n                    else if (n1.degree() < n2.degree()) {\n                        return 1;\n                    }\n                    return -1;\n                }\n                const compareValue = (n2BaryCenter - n1BaryCenter) * 1000;\n                if (compareValue > 0) {\n                    return -1;\n                }\n                else if (compareValue < 0) {\n                    return 1;\n                }\n                return this.compareByIndex(n1, n2);\n            });\n            // count relocations\n            let i, moves = 0;\n            for (i = 0; i < considered.length; i++) {\n                if (considered[i] !== presorted[i]) {\n                    moves++;\n                }\n            }\n            if (moves > 0) {\n                // now that the boxes have been arranged, update their grid positions\n                let inode = 0;\n                for (i = 0; i < considered.length; i++) {\n                    const node = considered[i];\n                    node.gridPosition = inode++;\n                }\n            }\n            return moves;\n        }\n        /// <summary>\n        /// Swaps a pair of nodes in a layer.\n        /// </summary>\n        /// <param name=\"layerIndex\">Index of the layer.</param>\n        /// <param name=\"n\">The Nth node in the layer.</param>\n        _swapPairs() {\n            const maxIterations = this.options.layeredIterations;\n            let iter = 0;\n            while (true) {\n                if (iter++ > maxIterations) {\n                    break;\n                }\n                const downwards = (iter % 4 <= 1);\n                const secondPass = (iter % 4 === 1);\n                for (let l = (downwards ? 0 : this.layers.length - 1); downwards ? l <= this.layers.length - 1 : l >= 0; l += (downwards ? 1 : -1)) {\n                    const layer = this.layers[l];\n                    let hasSwapped = false;\n                    // there is no need to recalculate crossings if they were calculated\n                    // on the previous step and nothing has changed\n                    let calcCrossings = true;\n                    let memCrossings = 0;\n                    for (let n = 0; n < layer.length - 1; n++) {\n                        // count crossings\n                        let up = 0;\n                        let down = 0;\n                        let crossBefore = 0;\n                        if (calcCrossings) {\n                            if (l !== 0) {\n                                up = this.countLinksCrossingBetweenTwoLayers(l - 1, l);\n                            }\n                            if (l !== this.layers.length - 1) {\n                                down = this.countLinksCrossingBetweenTwoLayers(l, l + 1);\n                            }\n                            if (downwards) {\n                                up *= 2;\n                            }\n                            else {\n                                down *= 2;\n                            }\n                            crossBefore = up + down;\n                        }\n                        else {\n                            crossBefore = memCrossings;\n                        }\n                        if (crossBefore === 0) {\n                            continue;\n                        }\n                        // Swap nodes\n                        let node1 = layer[n];\n                        let node2 = layer[n + 1];\n                        let node1GridPos = node1.gridPosition;\n                        let node2GridPos = node2.gridPosition;\n                        layer[n] = node2;\n                        layer[n + 1] = node1;\n                        node1.gridPosition = node2GridPos;\n                        node2.gridPosition = node1GridPos;\n                        // count crossings again and if worse than before, restore swapping\n                        up = 0;\n                        if (l !== 0) {\n                            up = this.countLinksCrossingBetweenTwoLayers(l - 1, l);\n                        }\n                        down = 0;\n                        if (l !== this.layers.length - 1) {\n                            down = this.countLinksCrossingBetweenTwoLayers(l, l + 1);\n                        }\n                        if (downwards) {\n                            up *= 2;\n                        }\n                        else {\n                            down *= 2;\n                        }\n                        const crossAfter = up + down;\n                        let revert = false;\n                        if (secondPass) {\n                            revert = crossAfter >= crossBefore;\n                        }\n                        else {\n                            revert = crossAfter > crossBefore;\n                        }\n                        if (revert) {\n                            node1 = layer[n];\n                            node2 = layer[n + 1];\n                            node1GridPos = node1.gridPosition;\n                            node2GridPos = node2.gridPosition;\n                            layer[n] = node2;\n                            layer[n + 1] = node1;\n                            node1.gridPosition = node2GridPos;\n                            node2.gridPosition = node1GridPos;\n                            // nothing has changed, remember the crossings so that\n                            // they are not calculated again on the next step\n                            memCrossings = crossBefore;\n                            calcCrossings = false;\n                        }\n                        else {\n                            hasSwapped = true;\n                            calcCrossings = true;\n                        }\n                    }\n                    if (hasSwapped) {\n                        if (l !== this.layers.length - 1) {\n                            this.calcUpData(l + 1);\n                        }\n                        if (l !== 0) {\n                            this.calcDownData(l - 1);\n                        }\n                    }\n                }\n            }\n        }\n        /// <summary>\n        /// Counts the number of links crossing between two layers.\n        /// </summary>\n        /// <param name=\"layerIndex1\">The layer index.</param>\n        /// <param name=\"layerIndex2\">Another layer index.</param>\n        /// <returns></returns>\n        countLinksCrossingBetweenTwoLayers(ulayer, dlayer) {\n            const links = this.layers[ulayer].linksTo[dlayer];\n            let link1, link2, n11, n12, n21, n22, l1, l2;\n            let crossings = 0;\n            const length = links.length;\n            for (l1 = 0; l1 < length; l1++) {\n                link1 = links[l1];\n                for (l2 = l1 + 1; l2 < length; l2++) {\n                    link2 = links[l2];\n                    if (link1.target.layer === dlayer) {\n                        n11 = link1.source;\n                        n12 = link1.target;\n                    }\n                    else {\n                        n11 = link1.target;\n                        n12 = link1.source;\n                    }\n                    if (link2.target.layer === dlayer) {\n                        n21 = link2.source;\n                        n22 = link2.target;\n                    }\n                    else {\n                        n21 = link2.target;\n                        n22 = link2.source;\n                    }\n                    const n11gp = n11.gridPosition;\n                    const n12gp = n12.gridPosition;\n                    const n21gp = n21.gridPosition;\n                    const n22gp = n22.gridPosition;\n                    if ((n11gp - n21gp) * (n12gp - n22gp) < 0) {\n                        crossings++;\n                    }\n                }\n            }\n            return crossings;\n        }\n        calcBaryCenter(node) {\n            const upstreamLinkCount = node.upstreamLinkCount;\n            const downstreamLinkCount = node.downstreamLinkCount;\n            const uBaryCenter = node.uBaryCenter;\n            const dBaryCenter = node.dBaryCenter;\n            if (upstreamLinkCount > 0 && downstreamLinkCount > 0) {\n                return (uBaryCenter + dBaryCenter) / 2;\n            }\n            if (upstreamLinkCount > 0) {\n                return uBaryCenter;\n            }\n            if (downstreamLinkCount > 0) {\n                return dBaryCenter;\n            }\n            return 0;\n        }\n        _gridPositionComparer(x, y) {\n            if (x.gridPosition < y.gridPosition) {\n                return -1;\n            }\n            if (x.gridPosition > y.gridPosition) {\n                return 1;\n            }\n            return 0;\n        }\n        _positionAscendingComparer(x, y) {\n            return x.k < y.k ? -1 : x.k > y.k ? 1 : 0;\n        }\n        _positionDescendingComparer(x, y) {\n            return x.k < y.k ? 1 : x.k > y.k ? -1 : 0;\n        }\n        _firstVirtualNode(layer) {\n            for (let c = 0; c < layer.length; c++) {\n                if (layer[c].isVirtual) {\n                    return c;\n                }\n            }\n            return -1;\n        }\n        compareByIndex(o1, o2) {\n            const i1 = o1.index;\n            const i2 = o2.index;\n            if (i1 < i2) {\n                return 1;\n            }\n            if (i1 > i2) {\n                return -1;\n            }\n            return 0;\n        }\n        intDiv(numerator, denominator) {\n            return (numerator - numerator % denominator) / denominator;\n        }\n        nextVirtualNode(layer, node) {\n            const nodeIndex = node.layerIndex;\n            for (let i = nodeIndex + 1; i < layer.length; ++i) {\n                if (layer[i].isVirtual) {\n                    return layer[i];\n                }\n            }\n            return null;\n        }\n    }\n\n    class TreeLayoutProcessor {\n        constructor(options) {\n            this.center = null;\n            this.options = options;\n        }\n        layout(treeGraph, root) {\n            this.graph = treeGraph;\n            if (!this.graph.nodes || this.graph.nodes.length === 0) {\n                return;\n            }\n            if (!contains(this.graph.nodes, root)) {\n                throw new Error('The given root is not in the graph.');\n            }\n            this.center = root;\n            this.graph.cacheRelationships();\n            /* var nonull = this.graph.nodes.where(function (n) {\n             return n.associatedShape != null;\n             });*/\n            // transfer the rects\n            /* nonull.forEach(function (n) {\n             n.Location = n.associatedShape.Position;\n             n.NodeSize = n.associatedShape.ActualBounds.ToSize();\n             }\n\n             );*/\n            // caching the children\n            /* nonull.forEach(function (n) {\n             n.children = n.getChildren();\n             });*/\n            this.layoutSwitch();\n            // apply the layout to the actual visuals\n            // nonull.ForEach(n => n.associatedShape.Position = n.Location);\n        }\n        layoutLeft(left) {\n            this.setChildrenDirection(this.center, 'Left', false);\n            this.setChildrenLayout(this.center, 'Default', false);\n            let h = 0, w = 0, y, i, node;\n            for (i = 0; i < left.length; i++) {\n                node = left[i];\n                node.TreeDirection = 'Left';\n                const s = this.measure(node, Size.Empty.bind(this));\n                w = Math.max(w, s.width);\n                h += s.height + this.options.verticalSeparation;\n            }\n            h -= this.options.verticalSeparation;\n            const x = this.center.x - this.options.horizontalSeparation;\n            y = this.center.y + ((this.center.height - h) / 2);\n            for (i = 0; i < left.length; i++) {\n                node = left[i];\n                const p = new Point(x - node.Size.width, y);\n                this.arrange(node, p);\n                y += node.Size.height + this.options.verticalSeparation;\n            }\n        }\n        layoutRight(right) {\n            this.setChildrenDirection(this.center, 'Right', false);\n            this.setChildrenLayout(this.center, 'Default', false);\n            let h = 0, w = 0, y, i, node;\n            for (i = 0; i < right.length; i++) {\n                node = right[i];\n                node.TreeDirection = 'Right';\n                const s = this.measure(node, Size.Empty.bind(this));\n                w = Math.max(w, s.width);\n                h += s.height + this.options.verticalSeparation;\n            }\n            h -= this.options.verticalSeparation;\n            const x = this.center.x + this.options.horizontalSeparation + this.center.width;\n            y = this.center.y + ((this.center.height - h) / 2);\n            for (i = 0; i < right.length; i++) {\n                node = right[i];\n                const p = new Point(x, y);\n                this.arrange(node, p);\n                y += node.Size.height + this.options.verticalSeparation;\n            }\n        }\n        layoutUp(up) {\n            this.setChildrenDirection(this.center, 'Up', false);\n            this.setChildrenLayout(this.center, 'Default', false);\n            let w = 0, y, node, i;\n            for (i = 0; i < up.length; i++) {\n                node = up[i];\n                node.TreeDirection = 'Up';\n                const s = this.measure(node, Size.Empty.bind(this));\n                w += s.width + this.options.horizontalSeparation;\n            }\n            w -= this.options.horizontalSeparation;\n            let x = this.center.x + (this.center.width / 2) - (w / 2);\n            // y = this.center.y -verticalSeparation -this.center.height/2 - h;\n            for (i = 0; i < up.length; i++) {\n                node = up[i];\n                y = this.center.y - this.options.verticalSeparation - node.Size.height;\n                const p = new Point(x, y);\n                this.arrange(node, p);\n                x += node.Size.width + this.options.horizontalSeparation;\n            }\n        }\n        layoutDown(down) {\n            let node, i;\n            this.setChildrenDirection(this.center, 'Down', false);\n            this.setChildrenLayout(this.center, 'Default', false);\n            let w = 0;\n            for (i = 0; i < down.length; i++) {\n                node = down[i];\n                node.treeDirection = 'Down';\n                const s = this.measure(node, Size.Empty.bind(this));\n                w += s.width + this.options.horizontalSeparation;\n            }\n            w -= this.options.horizontalSeparation;\n            let x = this.center.x + (this.center.width / 2) - (w / 2);\n            const y = this.center.y + this.options.verticalSeparation + this.center.height;\n            for (i = 0; i < down.length; i++) {\n                node = down[i];\n                const p = new Point(x, y);\n                this.arrange(node, p);\n                x += node.Size.width + this.options.horizontalSeparation;\n            }\n        }\n        layoutRadialTree() {\n            // var rmax = children.Aggregate(0D, (current, node) => Math.max(node.SectorAngle, current));\n            this.setChildrenDirection(this.center, 'Radial', false);\n            this.setChildrenLayout(this.center, 'Default', false);\n            this.previousRoot = null;\n            const startAngle = this.options.startRadialAngle * DEG_TO_RAD;\n            const endAngle = this.options.endRadialAngle * DEG_TO_RAD;\n            if (endAngle <= startAngle) {\n                throw new Error('Final angle should not be less than the start angle.');\n            }\n            this.maxDepth = 0;\n            this.origin = new Point(this.center.x, this.center.y);\n            this.calculateAngularWidth(this.center, 0);\n            // perform the layout\n            if (this.maxDepth > 0) {\n                this.radialLayout(this.center, this.options.radialFirstLevelSeparation, startAngle, endAngle);\n            }\n            // update properties of the root node\n            this.center.Angle = endAngle - startAngle;\n        }\n        tipOverTree(down, startFromLevel) {\n            if (isUndefined(startFromLevel)) {\n                startFromLevel = 0;\n            }\n            this.setChildrenDirection(this.center, 'Down', false);\n            this.setChildrenLayout(this.center, 'Default', false);\n            this.setChildrenLayout(this.center, 'Underneath', false, startFromLevel);\n            let w = 0, node, i;\n            for (i = 0; i < down.length; i++) {\n                node = down[i];\n                // if (node.IsSpecial) continue;\n                node.TreeDirection = 'Down';\n                const s = this.measure(node, Size.Empty.bind(this));\n                w += s.width + this.options.horizontalSeparation;\n            }\n            w -= this.options.horizontalSeparation;\n            // putting the root in the center with respect to the whole diagram is not a nice result, let's put it with respect to the first level only\n            w -= down[down.length - 1].width;\n            w += down[down.length - 1].associatedShape.bounds().width;\n            let x = this.center.x + (this.center.width / 2) - (w / 2);\n            const y = this.center.y + this.options.verticalSeparation + this.center.height;\n            for (i = 0; i < down.length; i++) {\n                node = down[i];\n                // if (node.IsSpecial) continue;\n                const p = new Point(x, y);\n                this.arrange(node, p);\n                x += node.Size.width + this.options.horizontalSeparation;\n            }\n            /*/ /let's place the special node, assuming there is only one\n             if (down.Count(n => n.IsSpecial) > 0)\n             {\n             var special = (from n in down where n.IsSpecial select n).First();\n             if (special.Children.Count > 0)\n             throw new DiagramException(\"The 'special' element should not have children.\");\n             special.Data.Location = new Point(Center.Data.Location.X + Center.AssociatedShape.BoundingRectangle.Width + this.options.HorizontalSeparation, Center.Data.Location.Y);\n             }*/\n        }\n        calculateAngularWidth(n, d) {\n            if (d > this.maxDepth) {\n                this.maxDepth = d;\n            }\n            const w = 1000, h = 1000, diameter = d === 0 ? 0 : Math.sqrt((w * w) + (h * h)) / d;\n            let aw = 0;\n            if (n.children.length > 0) {\n                // eventually with n.IsExpanded\n                for (let i = 0, len = n.children.length; i < len; i++) {\n                    const child = n.children[i];\n                    aw += this.calculateAngularWidth(child, d + 1);\n                }\n                aw = Math.max(diameter, aw);\n            }\n            else {\n                aw = diameter;\n            }\n            n.sectorAngle = aw;\n            return aw;\n        }\n        sortChildren(n) {\n            let basevalue = 0, i;\n            // update basevalue angle for node ordering\n            if (n.parents.length > 1) {\n                throw new Error('Node is not part of a tree.');\n            }\n            const p = n.parents[0];\n            if (p) {\n                const pl = new Point(p.x, p.y);\n                const nl = new Point(n.x, n.y);\n                basevalue = this.normalizeAngle(Math.atan2(pl.y - nl.y, pl.x - nl.x));\n            }\n            const count = n.children.length;\n            if (count === 0) {\n                return null;\n            }\n            const angle = [];\n            const idx = [];\n            for (i = 0; i < count; ++i) {\n                const c = n.children[i];\n                const l = new Point(c.x, c.y);\n                idx[i] = i;\n                angle[i] = this.normalizeAngle(-basevalue + Math.atan2(l.y - l.y, l.x - l.x));\n            }\n            bisort(angle, idx);\n            const col = []; // list of nodes\n            const children = n.children;\n            for (i = 0; i < count; ++i) {\n                col.push(children[idx[i]]);\n            }\n            return col;\n        }\n        normalizeAngle(angle) {\n            while (angle > Math.PI * 2) {\n                angle -= 2 * Math.PI;\n            }\n            while (angle < 0) {\n                angle += Math.PI * 2;\n            }\n            return angle;\n        }\n        radialLayout(node, radius, startAngle, endAngle) {\n            const deltaTheta = endAngle - startAngle;\n            const deltaThetaHalf = deltaTheta / 2.0;\n            const parentSector = node.sectorAngle;\n            let fraction = 0;\n            const sorted = this.sortChildren(node);\n            for (let i = 0, len = sorted.length; i < len; i++) {\n                const childNode = sorted[i];\n                const cp = childNode;\n                const childAngleFraction = cp.sectorAngle / parentSector;\n                if (childNode.children.length > 0) {\n                    this.radialLayout(childNode, radius + this.options.radialSeparation, startAngle + (fraction * deltaTheta), startAngle + ((fraction + childAngleFraction) * deltaTheta));\n                }\n                this.setPolarLocation(childNode, radius, startAngle + (fraction * deltaTheta) + (childAngleFraction * deltaThetaHalf));\n                cp.angle = childAngleFraction * deltaTheta;\n                fraction += childAngleFraction;\n            }\n        }\n        setPolarLocation(node, radius, angle) {\n            node.x = this.origin.x + (radius * Math.cos(angle));\n            node.y = this.origin.y + (radius * Math.sin(angle));\n            node.BoundingRectangle = new Rect(node.x, node.y, node.width, node.height);\n        }\n        /**\n         * Sets the children direction recursively.\n         *\n         * @param node\n         * @param direction\n         * @param includeStart\n         */\n        setChildrenDirection(node, direction, includeStart) {\n            const rootDirection = node.treeDirection;\n            this.graph.depthFirstTraversal(node, (n) => {\n                n.treeDirection = direction;\n            });\n            if (!includeStart) {\n                node.treeDirection = rootDirection;\n            }\n        }\n        /**\n         * Sets the children layout recursively.\n         *\n         * @param node\n         * @param layout\n         * @param includeStart\n         * @param startFromLevel\n         */\n        setChildrenLayout(node, layout, includeStart, startFromLevel) {\n            if (isUndefined(startFromLevel)) {\n                startFromLevel = 0;\n            }\n            const rootLayout = node.childrenLayout;\n            if (startFromLevel > 0) {\n                // assign levels to the Node.Level property\n                this.graph.assignLevels(node);\n                // assign the layout on the condition that the level is at least the 'startFromLevel'\n                this.graph.depthFirstTraversal(node, (s) => {\n                    if (s.level >= startFromLevel + 1) {\n                        s.childrenLayout = layout;\n                    }\n                });\n            }\n            else {\n                this.graph.depthFirstTraversal(node, (s) => {\n                    s.childrenLayout = layout;\n                });\n                // if the start should not be affected we put the state back\n                if (!includeStart) {\n                    node.childrenLayout = rootLayout;\n                }\n            }\n        }\n        /**\n         * Returns the actual size of the node. The given size is the allowed space wherein the node can lay out itself.\n         *\n         * @param node\n         * @param givenSize\n         * @returns {Size}\n         */\n        measure(node, givenSize) {\n            let w = 0, h = 0, s;\n            let result = new Size(0, 0);\n            if (!node) {\n                throw new Error('Node is not defined.');\n            }\n            const b = node.associatedShape.bounds();\n            const shapeWidth = b.width;\n            const shapeHeight = b.height;\n            if (node.parents.length !== 1) {\n                throw new Error('Node not in a spanning tree.');\n            }\n            const parent = node.parents[0];\n            if (node.treeDirection === 'Undefined') {\n                node.treeDirection = parent.treeDirection;\n            }\n            if (isEmpty(node.children)) {\n                result = new Size(Math.abs(shapeWidth) < EPSILON ? 50 : shapeWidth, Math.abs(shapeHeight) < EPSILON ? 25 : shapeHeight);\n            }\n            else if (node.children.length === 1) {\n                switch (node.treeDirection) {\n                    case 'Radial':\n                        s = this.measure(node.children[0], givenSize); // child size\n                        w = shapeWidth + (this.options.radialSeparation * Math.cos(node.AngleToParent)) + s.width;\n                        h = shapeHeight + Math.abs(this.options.radialSeparation * Math.sin(node.AngleToParent)) + s.height;\n                        break;\n                    case 'Left':\n                    case 'Right':\n                        switch (node.childrenLayout) {\n                            case 'TopAlignedWithParent':\n                                break;\n                            case 'BottomAlignedWithParent':\n                                break;\n                            case 'Underneath':\n                                s = this.measure(node.children[0], givenSize);\n                                w = shapeWidth + s.width + this.options.underneathHorizontalOffset;\n                                h = shapeHeight + this.options.underneathVerticalTopOffset + s.height;\n                                break;\n                            case 'Default':\n                                s = this.measure(node.children[0], givenSize);\n                                w = shapeWidth + this.options.horizontalSeparation + s.width;\n                                h = Math.max(shapeHeight, s.height);\n                                break;\n                            default:\n                                throw new Error('Unhandled TreeDirection in the Radial layout measuring.');\n                        }\n                        break;\n                    case 'Up':\n                    case 'Down':\n                        switch (node.childrenLayout) {\n                            case 'TopAlignedWithParent':\n                            case 'BottomAlignedWithParent':\n                                break;\n                            case 'Underneath':\n                                s = this.measure(node.children[0], givenSize);\n                                w = Math.max(shapeWidth, s.width + this.options.underneathHorizontalOffset);\n                                h = shapeHeight + this.options.underneathVerticalTopOffset + s.height;\n                                break;\n                            case 'Default':\n                                s = this.measure(node.children[0], givenSize);\n                                h = shapeHeight + this.options.verticalSeparation + s.height;\n                                w = Math.max(shapeWidth, s.width);\n                                break;\n                            default:\n                                throw new Error('Unhandled TreeDirection in the Down layout measuring.');\n                        }\n                        break;\n                    default:\n                        throw new Error('Unhandled TreeDirection in the layout measuring.');\n                }\n                result = new Size(w, h);\n            }\n            else {\n                let i, childNode;\n                switch (node.treeDirection) {\n                    case 'Left':\n                    case 'Right':\n                        switch (node.childrenLayout) {\n                            case 'TopAlignedWithParent':\n                            case 'BottomAlignedWithParent':\n                                break;\n                            case 'Underneath':\n                                w = shapeWidth;\n                                h = shapeHeight + this.options.underneathVerticalTopOffset;\n                                for (i = 0; i < node.children.length; i++) {\n                                    childNode = node.children[i];\n                                    s = this.measure(childNode, givenSize);\n                                    w = Math.max(w, s.width + this.options.underneathHorizontalOffset);\n                                    h += s.height + this.options.underneathVerticalSeparation;\n                                }\n                                h -= this.options.underneathVerticalSeparation;\n                                break;\n                            case 'Default':\n                                w = shapeWidth;\n                                h = 0;\n                                for (i = 0; i < node.children.length; i++) {\n                                    childNode = node.children[i];\n                                    s = this.measure(childNode, givenSize);\n                                    w = Math.max(w, shapeWidth + this.options.horizontalSeparation + s.width);\n                                    h += s.height + this.options.verticalSeparation;\n                                }\n                                h -= this.options.verticalSeparation;\n                                break;\n                            default:\n                                throw new Error('Unhandled TreeDirection in the Right layout measuring.');\n                        }\n                        break;\n                    case 'Up':\n                    case 'Down':\n                        switch (node.childrenLayout) {\n                            case 'TopAlignedWithParent':\n                            case 'BottomAlignedWithParent':\n                                break;\n                            case 'Underneath':\n                                w = shapeWidth;\n                                h = shapeHeight + this.options.underneathVerticalTopOffset;\n                                for (i = 0; i < node.children.length; i++) {\n                                    childNode = node.children[i];\n                                    s = this.measure(childNode, givenSize);\n                                    w = Math.max(w, s.width + this.options.underneathHorizontalOffset);\n                                    h += s.height + this.options.underneathVerticalSeparation;\n                                }\n                                h -= this.options.underneathVerticalSeparation;\n                                break;\n                            case 'Default':\n                                w = 0;\n                                h = 0;\n                                for (i = 0; i < node.children.length; i++) {\n                                    childNode = node.children[i];\n                                    s = this.measure(childNode, givenSize);\n                                    w += s.width + this.options.horizontalSeparation;\n                                    h = Math.max(h, s.height + this.options.verticalSeparation + shapeHeight);\n                                }\n                                w -= this.options.horizontalSeparation;\n                                break;\n                            default:\n                                throw new Error('Unhandled TreeDirection in the Down layout measuring.');\n                        }\n                        break;\n                    default:\n                        throw new Error('Unhandled TreeDirection in the layout measuring.');\n                }\n                result = new Size(w, h);\n            }\n            node.SectorAngle = Math.sqrt((w * w / 4) + (h * h / 4));\n            node.Size = result;\n            return result;\n        }\n        arrange(n, p) {\n            const b = n.associatedShape.bounds();\n            let i, pp, child, node, childrenwidth;\n            const shapeWidth = b.width;\n            const shapeHeight = b.height;\n            if (isEmpty(n.children)) {\n                n.x = p.x;\n                n.y = p.y;\n                n.BoundingRectangle = new Rect(p.x, p.y, shapeWidth, shapeHeight);\n            }\n            else {\n                let x, y;\n                let selfLocation;\n                switch (n.treeDirection) {\n                    case 'Left':\n                        switch (n.childrenLayout) {\n                            case 'TopAlignedWithParent':\n                            case 'BottomAlignedWithParent':\n                                break;\n                            case 'Underneath':\n                                selfLocation = p;\n                                n.x = selfLocation.x;\n                                n.y = selfLocation.y;\n                                n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                                y = p.y + shapeHeight + this.options.underneathVerticalTopOffset;\n                                for (i = 0; i < node.children.length; i++) {\n                                    node = node.children[i];\n                                    x = selfLocation.x - node.associatedShape.width - this.options.underneathHorizontalOffset;\n                                    pp = new Point(x, y);\n                                    this.arrange(node, pp);\n                                    y += node.Size.height + this.options.underneathVerticalSeparation;\n                                }\n                                break;\n                            case 'Default':\n                                selfLocation = new Point(p.x + n.Size.width - shapeWidth, p.y + ((n.Size.height - shapeHeight) / 2));\n                                n.x = selfLocation.x;\n                                n.y = selfLocation.y;\n                                n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                                x = selfLocation.x - this.options.horizontalSeparation; // alignment of children\n                                y = p.y;\n                                for (i = 0; i < n.children.length; i++) {\n                                    node = n.children[i];\n                                    pp = new Point(x - node.Size.width, y);\n                                    this.arrange(node, pp);\n                                    y += node.Size.height + this.options.verticalSeparation;\n                                }\n                                break;\n                            default:\n                                throw new Error('Unsupported TreeDirection');\n                        }\n                        break;\n                    case 'Right':\n                        switch (n.childrenLayout) {\n                            case 'TopAlignedWithParent':\n                            case 'BottomAlignedWithParent':\n                                break;\n                            case 'Underneath':\n                                selfLocation = p;\n                                n.x = selfLocation.x;\n                                n.y = selfLocation.y;\n                                n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                                x = p.x + shapeWidth + this.options.underneathHorizontalOffset;\n                                // alignment of children left-underneath the parent\n                                y = p.y + shapeHeight + this.options.underneathVerticalTopOffset;\n                                for (i = 0; i < n.children.length; i++) {\n                                    node = n.children[i];\n                                    pp = new Point(x, y);\n                                    this.arrange(node, pp);\n                                    y += node.Size.height + this.options.underneathVerticalSeparation;\n                                }\n                                break;\n                            case 'Default':\n                                selfLocation = new Point(p.x, p.y + ((n.Size.height - shapeHeight) / 2));\n                                n.x = selfLocation.x;\n                                n.y = selfLocation.y;\n                                n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                                x = p.x + shapeWidth + this.options.horizontalSeparation; // alignment of children\n                                y = p.y;\n                                for (i = 0; i < n.children.length; i++) {\n                                    node = n.children[i];\n                                    pp = new Point(x, y);\n                                    this.arrange(node, pp);\n                                    y += node.Size.height + this.options.verticalSeparation;\n                                }\n                                break;\n                            default:\n                                throw new Error('Unsupported TreeDirection');\n                        }\n                        break;\n                    case 'Up':\n                        selfLocation = new Point(p.x + ((n.Size.width - shapeWidth) / 2), p.y + n.Size.height - shapeHeight);\n                        n.x = selfLocation.x;\n                        n.y = selfLocation.y;\n                        n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                        if (Math.abs(selfLocation.x - p.x) < EPSILON) {\n                            childrenwidth = 0;\n                            // means there is an aberration due to the oversized Element with respect to the children\n                            for (i = 0; i < n.children.length; i++) {\n                                child = n.children[i];\n                                childrenwidth += child.Size.width + this.options.horizontalSeparation;\n                            }\n                            childrenwidth -= this.options.horizontalSeparation;\n                            x = p.x + ((shapeWidth - childrenwidth) / 2);\n                        }\n                        else {\n                            x = p.x;\n                        }\n                        for (i = 0; i < n.children.length; i++) {\n                            node = n.children[i];\n                            y = selfLocation.y - this.options.verticalSeparation - node.Size.height;\n                            pp = new Point(x, y);\n                            this.arrange(node, pp);\n                            x += node.Size.width + this.options.horizontalSeparation;\n                        }\n                        break;\n                    case 'Down':\n                        switch (n.childrenLayout) {\n                            case 'TopAlignedWithParent':\n                            case 'BottomAlignedWithParent':\n                                break;\n                            case 'Underneath':\n                                selfLocation = p;\n                                n.x = selfLocation.x;\n                                n.y = selfLocation.y;\n                                n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                                x = p.x + this.options.underneathHorizontalOffset; // alignment of children left-underneath the parent\n                                y = p.y + shapeHeight + this.options.underneathVerticalTopOffset;\n                                for (i = 0; i < n.children.length; i++) {\n                                    node = n.children[i];\n                                    pp = new Point(x, y);\n                                    this.arrange(node, pp);\n                                    y += node.Size.height + this.options.underneathVerticalSeparation;\n                                }\n                                break;\n                            case 'Default':\n                                selfLocation = new Point(p.x + ((n.Size.width - shapeWidth) / 2), p.y);\n                                n.x = selfLocation.x;\n                                n.y = selfLocation.y;\n                                n.BoundingRectangle = new Rect(n.x, n.y, n.width, n.height);\n                                if (Math.abs(selfLocation.x - p.x) < EPSILON) {\n                                    childrenwidth = 0;\n                                    // means there is an aberration due to the oversized Element with respect to the children\n                                    for (i = 0; i < n.children.length; i++) {\n                                        child = n.children[i];\n                                        childrenwidth += child.Size.width + this.options.horizontalSeparation;\n                                    }\n                                    childrenwidth -= this.options.horizontalSeparation;\n                                    x = p.x + ((shapeWidth - childrenwidth) / 2);\n                                }\n                                else {\n                                    x = p.x;\n                                }\n                                for (i = 0; i < n.children.length; i++) {\n                                    node = n.children[i];\n                                    y = selfLocation.y + this.options.verticalSeparation + shapeHeight;\n                                    pp = new Point(x, y);\n                                    this.arrange(node, pp);\n                                    x += node.Size.width + this.options.horizontalSeparation;\n                                }\n                                break;\n                            default:\n                                throw new Error('Unsupported TreeDirection');\n                        }\n                        break;\n                    case 'None':\n                        break;\n                    default:\n                        throw new Error('Unsupported TreeDirection');\n                }\n            }\n        }\n        layoutSwitch() {\n            if (!this.center) {\n                return;\n            }\n            if (isEmpty(this.center.children)) {\n                return;\n            }\n            let type = this.options.subtype;\n            if (isUndefined(type)) {\n                type = 'Down';\n            }\n            let single, male, female, leftcount;\n            const children = this.center.children;\n            switch (type.toLowerCase()) {\n                case 'radial':\n                case 'radialtree':\n                    this.layoutRadialTree();\n                    break;\n                case 'mindmaphorizontal':\n                case 'mindmap':\n                    single = this.center.children;\n                    if (this.center.children.length === 1) {\n                        this.layoutRight(single);\n                    }\n                    else {\n                        // odd number will give one more at the right\n                        leftcount = children.length / 2;\n                        male = grep$1(this.center.children, function (n) {\n                            return indexOf(children, n) < leftcount;\n                        });\n                        female = grep$1(this.center.children, function (n) {\n                            return indexOf(children, n) >= leftcount;\n                        });\n                        this.layoutLeft(male);\n                        this.layoutRight(female);\n                    }\n                    break;\n                case 'mindmapvertical':\n                    single = this.center.children;\n                    if (this.center.children.length === 1) {\n                        this.layoutDown(single);\n                    }\n                    else {\n                        // odd number will give one more at the right\n                        leftcount = children.length / 2;\n                        male = grep$1(this.center.children, function (n) {\n                            return indexOf(children, n) < leftcount;\n                        });\n                        female = grep$1(this.center.children, function (n) {\n                            return indexOf(children, n) >= leftcount;\n                        });\n                        this.layoutUp(male);\n                        this.layoutDown(female);\n                    }\n                    break;\n                case 'right':\n                    this.layoutRight(this.center.children);\n                    break;\n                case 'left':\n                    this.layoutLeft(this.center.children);\n                    break;\n                case 'up':\n                case 'bottom':\n                    this.layoutUp(this.center.children);\n                    break;\n                case 'down':\n                case 'top':\n                    this.layoutDown(this.center.children);\n                    break;\n                case 'tipover':\n                case 'tipovertree':\n                    if (this.options.tipOverTreeStartLevel < 0) {\n                        throw new Error('The tip-over level should be a positive integer.');\n                    }\n                    this.tipOverTree(this.center.children, this.options.tipOverTreeStartLevel);\n                    break;\n                case 'undefined':\n                case 'none':\n                    break;\n                default:\n                    break;\n            }\n        }\n    }\n\n    /**\n     * The various tree layout algorithms.\n     *\n     * @type {*}\n     */\n    class TreeLayout extends LayoutBase {\n        constructor(diagram) {\n            super();\n            if (isUndefined(diagram)) {\n                throw new Error('No diagram specified.');\n            }\n            this.diagram = diagram;\n        }\n        /**\n         * Arranges the diagram in a tree-layout with the specified options and tree subtype.\n         */\n        layout(options) {\n            this.transferOptions(options);\n            // transform the diagram into a Graph\n            const adapter = new DiagramToHyperTreeAdapter(this.diagram);\n            /**\n             * The Graph reduction from the given diagram.\n             *\n             * @type {*}\n             */\n            this.graph = adapter.convert();\n            const finalNodeSet = this.layoutComponents();\n            // note that the graph contains the original data and\n            // the components are another instance of nodes referring to the same set of shapes\n            return new LayoutState(this.diagram, finalNodeSet);\n        }\n        layoutComponents() {\n            if (this.graph.isEmpty()) {\n                return;\n            }\n            // split into connected components\n            const components = this.graph.getConnectedComponents();\n            if (isEmpty(components)) {\n                return;\n            }\n            const layout = new TreeLayoutProcessor(this.options);\n            const trees = [];\n            // find a spanning tree for each component\n            for (let i = 0; i < components.length; i++) {\n                const component = components[i];\n                const treeGraph = this.getTree(component);\n                if (!treeGraph) {\n                    throw new Error('Failed to find a spanning tree for the component.');\n                }\n                const root = treeGraph.root;\n                const tree = treeGraph.tree;\n                layout.layout(tree, root);\n                trees.push(tree);\n            }\n            return this.gridLayoutComponents(trees);\n        }\n        /**\n         * Gets a spanning tree (and root) for the given graph.\n         * Ensure that the given graph is connected!\n         *\n         * @param graph\n         * @returns {*} A literal object consisting of the found root and the spanning tree.\n         */\n        getTree(graph) {\n            let root = null;\n            if (this.options.roots && this.options.roots.length > 0) {\n                for (let i = 0, len = graph.nodes.length; i < len; i++) {\n                    const node = graph.nodes[i];\n                    for (let j = 0; j < this.options.roots.length; j++) {\n                        const givenRootShape = this.options.roots[j];\n                        if (givenRootShape === node.associatedShape) {\n                            root = node;\n                            break;\n                        }\n                    }\n                }\n            }\n            if (!root) {\n                // finds the most probable root on the basis of the longest path in the component\n                root = graph.root();\n                // should not happen really\n                if (!root) {\n                    throw new Error('Unable to find a root for the tree.');\n                }\n            }\n            return this.getTreeForRoot(graph, root);\n        }\n        getTreeForRoot(graph, root) {\n            const tree = graph.getSpanningTree(root);\n            if (isUndefined(tree) || tree.isEmpty()) {\n                return null;\n            }\n            return {\n                tree: tree,\n                root: tree.root()\n            };\n        }\n    }\n\n    class AdornerBase {\n        constructor(diagram, options) {\n            this.diagram = diagram;\n            this.options = deepExtend({}, this.options, options);\n            this.visual = new Group();\n            this.diagram._adorners.push(this);\n        }\n        refresh() { }\n    }\n\n    class ConnectionEditUndoUnit {\n        constructor(item, undoSource, undoTarget) {\n            this.item = item;\n            this._undoSource = undoSource;\n            this._undoTarget = undoTarget;\n            this._redoSource = item.source();\n            this._redoTarget = item.target();\n            this.title = ConnectionEditing;\n        }\n        undo() {\n            this.item._updateConnector(this._undoSource, SOURCE);\n            this.item._updateConnector(this._undoTarget, TARGET);\n            this.item.updateModel();\n        }\n        redo() {\n            this.item._updateConnector(this._redoSource, SOURCE);\n            this.item._updateConnector(this._redoTarget, TARGET);\n            this.item.updateModel();\n        }\n    }\n\n    function mwDelta(e) {\n        let delta = 0;\n        if (e.wheelDelta) {\n            delta = -e.wheelDelta / 40;\n            delta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);\n        }\n        else if (e.detail) {\n            delta = e.detail;\n        }\n        return delta;\n    }\n    function isAutoConnector(connector) {\n        return connector.options.name.toLowerCase() === AUTO.toLowerCase();\n    }\n    function closestConnector(point, connectors) {\n        let minimumDistance = MAXINT, resCtr, connector;\n        for (let i = 0; i < connectors.length; i++) {\n            connector = connectors[i];\n            if (!isAutoConnector(connector)) {\n                const dist = point.distanceTo(connector.position());\n                if (dist < minimumDistance) {\n                    minimumDistance = dist;\n                    resCtr = connector;\n                }\n            }\n        }\n        return resCtr;\n    }\n    function indicesOfItems(group, visuals) {\n        const indices = [];\n        let i, visual;\n        const children = group.drawingContainer().children;\n        const length = children.length;\n        for (i = 0; i < visuals.length; i++) {\n            visual = visuals[i];\n            for (let j = 0; j < length; j++) {\n                if (children[j] === visual.drawingContainer()) {\n                    indices.push(j);\n                    break;\n                }\n            }\n        }\n        return indices;\n    }\n    function translateToOrigin(visual) {\n        const bbox = visual.drawingContainer().clippedBBox(null);\n        if (bbox.origin.x !== 0 || bbox.origin.y !== 0) {\n            visual.position(-bbox.origin.x, -bbox.origin.y);\n        }\n    }\n    function filterShapeDataItem(dataItem) {\n        const result = {};\n        dataItem = dataItem || {};\n        if (defined(dataItem.text) && dataItem.text !== null) {\n            result.text = dataItem.text;\n        }\n        if (defined(dataItem.x) && dataItem.x !== null) {\n            result.x = dataItem.x;\n        }\n        if (defined(dataItem.y) && dataItem.y !== null) {\n            result.y = dataItem.y;\n        }\n        if (defined(dataItem.width) && dataItem.width !== null) {\n            result.width = dataItem.width;\n        }\n        if (defined(dataItem.height) && dataItem.height !== null) {\n            result.height = dataItem.height;\n        }\n        if (defined(dataItem.type) && dataItem.type !== null) {\n            result.type = dataItem.type;\n        }\n        return result;\n    }\n    function filterConnectionDataItem(dataItem) {\n        const result = {};\n        dataItem = dataItem || {};\n        if (defined(dataItem.text) && dataItem.text !== null) {\n            result.content = dataItem.text;\n        }\n        if (defined(dataItem.type) && dataItem.type !== null) {\n            result.type = dataItem.type;\n        }\n        if (defined(dataItem.from) && dataItem.from !== null) {\n            result.from = dataItem.from;\n        }\n        if (defined(dataItem.fromConnector) && dataItem.fromConnector !== null) {\n            result.fromConnector = dataItem.fromConnector;\n        }\n        if (defined(dataItem.fromX) && dataItem.fromX !== null) {\n            result.fromX = dataItem.fromX;\n        }\n        if (defined(dataItem.fromY) && dataItem.fromY !== null) {\n            result.fromY = dataItem.fromY;\n        }\n        if (defined(dataItem.to) && dataItem.to !== null) {\n            result.to = dataItem.to;\n        }\n        if (defined(dataItem.toConnector) && dataItem.toConnector !== null) {\n            result.toConnector = dataItem.toConnector;\n        }\n        if (defined(dataItem.toX) && dataItem.toX !== null) {\n            result.toX = dataItem.toX;\n        }\n        if (defined(dataItem.toY) && dataItem.toY !== null) {\n            result.toY = dataItem.toY;\n        }\n        return result;\n    }\n    var FlowchartShapeType;\n    (function (FlowchartShapeType) {\n        FlowchartShapeType[\"Terminator\"] = \"Terminator\";\n        FlowchartShapeType[\"Process\"] = \"Process\";\n        FlowchartShapeType[\"Decision\"] = \"Decision\";\n        FlowchartShapeType[\"PredefinedProcess\"] = \"PredefinedProcess\";\n        FlowchartShapeType[\"Document\"] = \"Document\";\n        FlowchartShapeType[\"MultipleDocuments\"] = \"MultipleDocuments\";\n        FlowchartShapeType[\"ManualInputOutput\"] = \"ManualInputOutput\";\n        FlowchartShapeType[\"Preparation\"] = \"Preparation\";\n        FlowchartShapeType[\"ManualOperation\"] = \"ManualOperation\";\n        FlowchartShapeType[\"InternalStorage\"] = \"InternalStorage\";\n        FlowchartShapeType[\"Display\"] = \"Display\";\n        FlowchartShapeType[\"DirectAccessStorage\"] = \"DirectAccessStorage\";\n        FlowchartShapeType[\"Database\"] = \"Database\";\n        FlowchartShapeType[\"OnPageConnector\"] = \"OnPageConnector\";\n        FlowchartShapeType[\"OffPageConnector\"] = \"OffPageConnector\";\n        FlowchartShapeType[\"DataInputOutput\"] = \"DataInputOutput\";\n        FlowchartShapeType[\"SummingJunction\"] = \"SummingJunction\";\n        FlowchartShapeType[\"LogicalOr\"] = \"LogicalOr\";\n        FlowchartShapeType[\"Merge\"] = \"Merge\";\n        FlowchartShapeType[\"Extract\"] = \"Extract\";\n        FlowchartShapeType[\"DataStorage\"] = \"DataStorage\";\n        FlowchartShapeType[\"Delay\"] = \"Delay\";\n        FlowchartShapeType[\"Sort\"] = \"Sort\";\n        FlowchartShapeType[\"Collate\"] = \"Collate\";\n    })(FlowchartShapeType || (FlowchartShapeType = {}));\n    const documentConnectors = [\n        { name: \"top\" },\n        {\n            name: \"bottom\",\n            position: function (shape) {\n                const height = shape.bounds().height;\n                const amplitude = height * shape.shapeVisual.options.waveRatio;\n                const position = shape.getPosition('top');\n                position.y += height - (amplitude * 0.4);\n                return position;\n            }\n        },\n        { name: \"left\" },\n        { name: \"right\" },\n        { name: \"auto\" }\n    ];\n    const triangleConnectors = [\n        { name: \"top\" },\n        { name: \"bottom\" },\n        {\n            name: \"left\",\n            position: function (shape) {\n                const position = shape.getPosition('left');\n                const bounds = shape.bounds();\n                position.x += (bounds.width / 4) - shape.shapeVisual.options.cornerRadius * 0.6 * (bounds.width / bounds.height);\n                return position;\n            }\n        },\n        {\n            name: \"right\",\n            position: function (shape) {\n                const position = shape.getPosition('right');\n                const bounds = shape.bounds();\n                position.x -= bounds.width / 4 - shape.shapeVisual.options.cornerRadius * 0.6 * (bounds.width / bounds.height);\n                return position;\n            }\n        },\n        { name: \"auto\" }\n    ];\n    const connectors = {\n        [FlowchartShapeType.Extract]: triangleConnectors,\n        [FlowchartShapeType.Merge]: triangleConnectors,\n        [FlowchartShapeType.Document]: documentConnectors,\n        [FlowchartShapeType.MultipleDocuments]: documentConnectors,\n        [FlowchartShapeType.DataInputOutput]: [\n            { name: \"top\" },\n            { name: \"bottom\" },\n            {\n                name: \"left\",\n                position: function (shape) {\n                    const position = shape.getPosition('left');\n                    position.x += (shape.bounds().width * shape.shapeVisual.options.slantRatio / 2) - shape.shapeVisual.options.cornerRadius / 5;\n                    return position;\n                }\n            },\n            {\n                name: \"right\",\n                position: function (shape) {\n                    const position = shape.getPosition('right');\n                    position.x -= (shape.bounds().width * shape.shapeVisual.options.slantRatio / 2) - shape.shapeVisual.options.cornerRadius / 5;\n                    return position;\n                }\n            },\n            { name: \"auto\" }\n        ],\n        [FlowchartShapeType.ManualOperation]: [\n            { name: \"top\" },\n            { name: \"bottom\" },\n            {\n                name: \"left\",\n                position: function (shape) {\n                    const position = shape.getPosition('left');\n                    position.x += (shape.bounds().width * shape.shapeVisual.options.baseShrinkRatio / (4 + shape.shapeVisual.options.cornerRadius / 10));\n                    return position;\n                }\n            },\n            {\n                name: \"right\",\n                position: function (shape) {\n                    const position = shape.getPosition('right');\n                    position.x -= (shape.bounds().width * shape.shapeVisual.options.baseShrinkRatio / (4 + shape.shapeVisual.options.cornerRadius / 10));\n                    return position;\n                }\n            },\n            { name: \"auto\" }\n        ],\n        [FlowchartShapeType.ManualInputOutput]: [\n            {\n                name: \"top\",\n                position: function (shape) {\n                    const position = shape.getPosition('top');\n                    position.y += shape.bounds().height * shape.shapeVisual.options.topSlantRatio / 2;\n                    return position;\n                }\n            },\n            { name: \"bottom\" },\n            { name: \"left\" },\n            { name: \"right\" },\n            { name: \"auto\" }\n        ],\n        [FlowchartShapeType.DataStorage]: [\n            { name: \"top\" },\n            { name: \"bottom\" },\n            { name: \"left\" },\n            {\n                name: \"right\",\n                position: function (shape) {\n                    const width = shape.bounds().width;\n                    const position = shape.getPosition('right');\n                    position.x -= width * shape.shapeVisual.options.ellipseRadiusXRatio;\n                    return position;\n                }\n            },\n            { name: \"auto\" }\n        ]\n    };\n\n    class RotateUnit {\n        constructor(adorner, shapes, undoRotates) {\n            this.shapes = shapes;\n            this.undoRotates = undoRotates;\n            this.title = 'Rotation';\n            this.redoRotates = [];\n            this.redoAngle = adorner._angle;\n            this.adorner = adorner;\n            this.center = adorner._innerBounds.center();\n            for (let i = 0; i < this.shapes.length; i++) {\n                this.redoRotates.push(this.redoAngle);\n            }\n        }\n        undo() {\n            let i, shape;\n            for (i = 0; i < this.shapes.length; i++) {\n                shape = this.shapes[i];\n                shape.rotate(this.undoRotates[i], this.center, false);\n                if ('layout' in shape) {\n                    shape.layout(shape);\n                }\n                shape.updateModel();\n            }\n            if (this.adorner) {\n                this.adorner._initialize();\n                this.adorner.refresh();\n            }\n        }\n        redo() {\n            let i, shape;\n            for (i = 0; i < this.shapes.length; i++) {\n                shape = this.shapes[i];\n                shape.rotate(this.redoRotates[i], this.center, false);\n                if ('layout' in shape) {\n                    shape.layout(shape);\n                }\n                shape.updateModel();\n            }\n            if (this.adorner) {\n                this.adorner._initialize();\n                this.adorner.refresh();\n            }\n        }\n    }\n\n    const defaultOptions$5 = {\n        width: 7,\n        height: 7,\n        fill: {\n            color: DEFAULT_CONNECTION_BACKGROUND\n        },\n        hover: {}\n    };\n    class Connector {\n        /**\n         * Creates a new Connector instance.\n         * @param shape The shape that owns this connector\n         * @param options Configuration options for the connector\n         */\n        constructor(shape, options) {\n            this.options = deepExtend({}, defaultOptions$5, options);\n            this.connections = [];\n            this.shape = shape;\n        }\n        /**\n         * Gets the position of this connector.\n         * Uses either a custom position function from options or the shape's getPosition method.\n         * @returns The Point representing the connector's position\n         */\n        position() {\n            if (this.options.position) {\n                return this.options.position(this.shape);\n            }\n            else {\n                return this.shape.getPosition(this.options.name);\n            }\n        }\n        /**\n         * Converts the connector to a JSON representation for serialization.\n         * @returns Object containing the shape ID and connector name\n         */\n        toJSON() {\n            return {\n                shapeId: this.shape.toString(),\n                connector: this.options.name\n            };\n        }\n        /**\n         * @hidden\n         * Parses a string representation to find and return a connector from the diagram.\n         * @param diagram The diagram to search for the connector\n         * @param str String representation in format \"shapeId:connectorName\"\n         * @returns The matching Connector or undefined if not found\n         */\n        static parse(diagram, str) {\n            const tempStr = str.split(':'), id = tempStr[0], name = tempStr[1] || AUTO;\n            for (let i = 0; i < diagram.shapes.length; i++) {\n                const shape = diagram.shapes[i];\n                if (shape.options.id === id) {\n                    return shape.getConnector(name.trim());\n                }\n            }\n        }\n        ;\n    }\n\n    const DefaultConnectors = [{\n            name: TOP\n        }, {\n            name: BOTTOM\n        }, {\n            name: LEFT\n        }, {\n            name: RIGHT\n        }, {\n            name: AUTO,\n            position: function (shape) {\n                return shape.getPosition('center');\n            }\n        }];\n    const shapeDefaults = function (extra) {\n        const defaults = {\n            type: DEFAULT_SHAPE_TYPE,\n            path: '',\n            autoSize: true,\n            visual: null,\n            x: DEFAULT_SHAPE_POSITION,\n            y: DEFAULT_SHAPE_POSITION,\n            minWidth: DEFAULT_SHAPE_MINWIDTH,\n            minHeight: DEFAULT_SHAPE_MINHEIGHT,\n            width: DEFAULT_SHAPE_WIDTH,\n            height: DEFAULT_SHAPE_HEIGHT,\n            cornerRadius: 0,\n            tooltip: {\n                visible: true\n            },\n            hover: {},\n            editable: {\n                connect: true,\n                tools: []\n            },\n            connectors: DefaultConnectors,\n            rotation: {\n                angle: 0\n            }\n        };\n        simpleExtend(defaults, extra);\n        return defaults;\n    };\n\n    let current = {\n        compile: function (template, _options) {\n            return template;\n        }\n    };\n    class TemplateService {\n        static register(userImplementation) {\n            current = userImplementation;\n        }\n        static compile(template, options = {}) {\n            return current.compile(template, options);\n        }\n    }\n\n    function getTemplate(options = {}) {\n        let template;\n        if (options.visual) {\n            options.visual = template = TemplateService.compile(options.visual, options);\n        }\n        else if (options.template) {\n            options.template = template = TemplateService.compile(options.template, options);\n        }\n        else if (isFunction$1(options.content)) {\n            template = options.content;\n        }\n        return template;\n    }\n\n    function getSupportedFeatures() {\n        const os = detectOS(navigator.userAgent);\n        const support = {};\n        support.mobileOS = os;\n        return support;\n    }\n    function detectOS(ua) {\n        let os = false;\n        const agentRxs = {\n            wp: /(Windows Phone(?: OS)?)\\s(\\d+)\\.(\\d+(\\.\\d+)?)/,\n            fire: /(Silk)\\/(\\d+)\\.(\\d+(\\.\\d+)?)/,\n            android: /(Android|Android.*(?:Opera|Firefox).*?\\/)\\s*(\\d+)\\.?(\\d+(\\.\\d+)?)?/,\n            iphone: /(iPhone|iPod).*OS\\s+(\\d+)[._]([\\d._]+)/,\n            ipad: /(iPad).*OS\\s+(\\d+)[._]([\\d_]+)/,\n            playbook: /(PlayBook).*?Tablet\\s*OS\\s*(\\d+)\\.(\\d+(\\.\\d+)?)/,\n            windows: /(MSIE)\\s+(\\d+)\\.(\\d+(\\.\\d+)?)/,\n            tizen: /(tizen).*?Version\\/(\\d+)\\.(\\d+(\\.\\d+)?)/i,\n            sailfish: /(sailfish).*rv:(\\d+)\\.(\\d+(\\.\\d+)?).*firefox/i\n        }, osRxs = {\n            ios: /^i(phone|pad|pod)$/i,\n            android: /^android|fire$/i,\n            windows: /windows/,\n            wp: /wp/,\n            flat: /sailfish|ffos|tizen/i\n        };\n        for (const agent in agentRxs) {\n            if (!Object.prototype.hasOwnProperty.call(agentRxs, agent)) {\n                continue;\n            }\n            const match = ua.match(agentRxs[agent]);\n            if (match) {\n                if (agent === 'windows' && 'plugins' in navigator) {\n                    return false;\n                } // Break if not Metro/Mobile Windows\n                os = {};\n                os.device = agent;\n                os.name = testRegex(agent, osRxs);\n                os[os.name] = true;\n                break;\n            }\n        }\n        return os;\n    }\n    function testRegex(agent, regexes, dflt) {\n        for (const regex in regexes) {\n            if (regexes[regex].test(agent)) {\n                return regex;\n            }\n        }\n        return dflt !== undefined ? dflt : agent;\n    }\n\n    const extend$1 = Object.assign;\n    const now = () => {\n        return new Date().getTime();\n    };\n    const addClass = (element, className) => {\n        element.classList.add(className);\n    };\n    const convertToHtml = (html) => {\n        const div = document.createElement('div');\n        div.innerHTML = html;\n        return div.firstChild;\n    };\n    const appendHtml = (html, element) => {\n        const div = document.createElement('div');\n        div.innerHTML = html;\n        // use childNodes instead of children\n        // to cover text nodes as well\n        while (div.childNodes.length > 0) {\n            element.appendChild(div.childNodes[0]);\n        }\n    };\n    const removeChildren = (element) => {\n        while (element.firstChild) {\n            element.removeChild(element.firstChild);\n        }\n    };\n    const prepend = (element, originElement) => {\n        originElement.insertBefore(element, originElement.firstChild);\n    };\n    const wrapInner = (parent, wrapper) => {\n        parent.appendChild(wrapper);\n        while (parent.firstChild !== wrapper) {\n            wrapper.appendChild(parent.firstChild);\n        }\n    };\n    const toHyphens = (str) => {\n        const result = str.replace(/([a-z][A-Z])/g, function (g) {\n            return g.charAt(0) + '-' + g.charAt(1).toLowerCase();\n        });\n        return result;\n    };\n    const toPixels = (value) => {\n        let result;\n        if (value && String(value).endsWith('px')) {\n            result = value;\n        }\n        else {\n            result = String(value) + 'px';\n        }\n        return result;\n    };\n    const hasNativeScrolling = () => {\n        const { mobileOS } = getSupportedFeatures();\n        return mobileOS.ios || mobileOS.android;\n    };\n    const wheelDeltaY = (e) => {\n        const deltaY = e.wheelDeltaY;\n        let delta;\n        if (e.wheelDelta) { // Webkit and IE\n            if (deltaY === undefined || deltaY) { // IE does not have deltaY, thus always scroll (horizontal scrolling is treated as vertical)\n                delta = e.wheelDelta;\n            }\n        }\n        else if (e.detail && e.axis === e.VERTICAL_AXIS) { // Firefox and Opera\n            delta = (-e.detail) * 10;\n        }\n        return delta;\n    };\n    const renderPos = (pos) => {\n        const result = [];\n        if (pos) {\n            const parts = toHyphens(pos).split('-');\n            for (let i = 0; i < parts.length; i++) {\n                result.push('k-pos-' + parts[i]);\n            }\n        }\n        return result.join(' ');\n    };\n\n    /** @hidden */\n    const getTextElementType = (options) => {\n        let textWrap = options.textWrap;\n        if (textWrap === undefined && (options.text.includes(NEW_LINE_CHAR) || !linesFit(options, textRect(options).size.width))) {\n            textWrap = WRAP;\n        }\n        if (options.border || options.position === INLINE) {\n            textWrap = WRAP;\n        }\n        return textWrap !== WRAP ? TextBlock : MultiLineTextBlock;\n    };\n    const linesFit = (options, maxWidth) => {\n        const text = options.text || '';\n        const styles = getFont(options);\n        return !text.split(NEW_LINE_CHAR).find(line => kendo_drawing_cmn_chunk_js.m(line, styles).width > maxWidth);\n    };\n    const defaultOptions$4 = {\n        hover: {},\n        cursor: Cursors.grip,\n        content: {\n            align: 'center middle'\n        },\n        selectable: true,\n        serializable: true,\n        enable: true\n    };\n    /** @hidden */\n    class DiagramElement extends Observable {\n        /**\n         * Creates a new DiagramElement instance.\n         * @param options Configuration options for the diagram element\n         */\n        constructor(options) {\n            super();\n            this.dataItem = (options || {}).dataItem;\n            this.options = deepExtend({ id: randomId() }, defaultOptions$4, options);\n            this.isSelected = false;\n            this.visual = new Group({\n                id: this.options.id,\n                autoSize: this.options.autoSize\n            });\n            this.id = this.options.id;\n            this._template();\n        }\n        /** @hidden */\n        _getCursor(point) {\n            if (this.adorner) {\n                return this.adorner._getCursor(point);\n            }\n            return this.options.cursor;\n        }\n        /**\n         * Gets or sets the visibility of the diagram element.\n         * @param value If provided, sets the visibility. If undefined, returns the current visibility.\n         * @returns The current visibility when used as a getter\n         */\n        visible(value) {\n            if (isUndefined(value)) {\n                return this.visual.visible();\n            }\n            else {\n                this.visual.visible(value);\n            }\n        }\n        /**\n         * Gets or sets the bounds of the diagram element.\n         * Base implementation returns null - should be overridden by subclasses.\n         * @param value The bounds to set. If not provided, returns the current bounds.\n         * @returns The bounds of the element or null\n         */\n        bounds(value) {\n            if (isUndefined(value)) {\n                return null;\n            }\n            return null;\n        }\n        /**\n         * Refreshes the visual representation of the diagram element.\n         * Triggers a redraw of the visual component.\n         */\n        refresh() {\n            this.visual.redraw();\n        }\n        /**\n         * Sets the position of the diagram element.\n         * @param point The new position point with x and y coordinates\n         */\n        position(point) {\n            this.options.x = point.x;\n            this.options.y = point.y;\n            this.visual.position(point);\n        }\n        /**\n         * Returns a string representation of the diagram element.\n         * @returns The ID of the element as a string\n         */\n        toString() {\n            return this.options.id;\n        }\n        /**\n         * Serializes the diagram element to a JSON object.\n         * @returns An object containing the element's options and data item information\n         */\n        serialize() {\n            // the options json object describes the shape perfectly. So this object can serve as shape serialization.\n            const json = deepExtend({}, { options: this.options });\n            if (this.dataItem) {\n                json.dataItem = this.dataItem.toString();\n            }\n            return json;\n        }\n        /** @hidden */\n        _content(content) {\n            if (content !== undefined) {\n                const options = this.options;\n                if (isString$1(content)) {\n                    options.content.text = content;\n                }\n                else {\n                    deepExtend(options.content, content);\n                }\n                const contentOptions = options.content;\n                let contentVisual = this._contentVisual;\n                if (contentVisual && getTextElementType(contentOptions).name !== contentVisual.name) {\n                    const drawingElement = contentVisual.drawingContainer();\n                    drawingElement.parent.remove(drawingElement);\n                    this._contentVisual = contentVisual = null;\n                }\n                if (!contentVisual) {\n                    this._createContentVisual(contentOptions);\n                }\n                else {\n                    this._updateContentVisual(contentOptions);\n                }\n            }\n            return this.options.content.text;\n        }\n        /** @hidden */\n        _createContentVisual(options) {\n            if (options.text) {\n                options.shapeSize = this.bounds();\n                const Type = getTextElementType(options);\n                this._contentVisual = new Type(options);\n                this._contentVisual._includeInBBox = false;\n                this.visual.append(this._contentVisual);\n            }\n        }\n        /** @hidden */\n        _updateContentVisual(options) {\n            this._contentVisual.redraw(options);\n        }\n        /** @hidden */\n        _hitTest(point) {\n            const bounds = this.bounds();\n            return this.visible() && bounds.contains(point) && this.options.enable;\n        }\n        /** @hidden */\n        _template() {\n            if (this.options.content.template) {\n                const data = this.dataItem || {};\n                const templateOptions = extend$1({}, this.options.content, {\n                    dataItem: this.dataItem || this.options.dataItem,\n                });\n                const elementTemplate = getTemplate(templateOptions);\n                if (isFunction$1(elementTemplate)) {\n                    this.options.content.text = elementTemplate(data);\n                }\n                else if (isString$1(elementTemplate)) {\n                    this.options.content.text = elementTemplate;\n                }\n            }\n        }\n        /** @hidden */\n        _canSelect() {\n            return this.options.selectable !== false;\n        }\n        /**\n         * Converts the diagram element to a JSON representation.\n         * @returns Object containing the element's ID\n         */\n        toJSON() {\n            return {\n                id: this.options.id\n            };\n        }\n    }\n\n    const shapes = {\n        Terminator: Terminator,\n        Process: Process,\n        Decision: Decision,\n        PredefinedProcess: PredefinedProcess,\n        Document: Document,\n        MultipleDocuments: MultipleDocuments,\n        ManualInputOutput: ManualInputOutput,\n        Preparation: Preparation,\n        ManualOperation: ManualOperation,\n        InternalStorage: InternalStorage,\n        Display: Display,\n        DirectAccessStorage: DirectAccessStorage,\n        Database: Database,\n        OnPageConnector: OnPageConnector,\n        OffPageConnector: OffPageConnector,\n        DataInputOutput: DataInputOutput,\n        SummingJunction: SummingJunction,\n        LogicalOr: LogicalOr,\n        Merge: Merge,\n        Extract: Extract,\n        DataStorage: DataStorage,\n        Delay: Delay,\n        Sort: Sort,\n        Collate: Collate\n    };\n    class Shape extends DiagramElement {\n        /**\n         * Creates a new Shape instance.\n         * @param options Configuration options for the shape\n         * @param diagram The diagram that will contain this shape\n         */\n        constructor(options, diagram) {\n            super(options);\n            /** @hidden */\n            this.name = 'Shape';\n            // Store original width/height if explicitly provided to preserve them during save\n            this._originalWidth = options === null || options === void 0 ? void 0 : options.width;\n            this._originalHeight = options === null || options === void 0 ? void 0 : options.height;\n            this.options = deepExtend({}, this.options, shapeDefaults({ connectors: undefined }), options);\n            if (this.options.type === 'text') {\n                this.options.content.textWrap = NO_WRAP;\n            }\n            this.diagram = diagram;\n            this.updateOptionsFromModel();\n            this.connectors = [];\n            this.type = this.options.type;\n            this.createShapeVisual();\n            this.updateBounds();\n            this.content(this.content());\n            this._createConnectors();\n        }\n        /** @hidden */\n        _setOptionsFromModel(model) {\n            const modelOptions = filterShapeDataItem(model || this.dataItem);\n            this.options = deepExtend({}, this.options, modelOptions);\n            this.redrawVisual();\n        }\n        /**\n         * Updates the shape options from the model data.\n         * @param model The model data to extract options from\n         * @param field Specific field to update, if any\n         */\n        updateOptionsFromModel(model, field) {\n            if (this.diagram && this.diagram._isEditable) {\n                const modelOptions = filterShapeDataItem(model || this.dataItem);\n                if (model && field) {\n                    if (!contains(['x', 'y', 'width', 'height'], field)) {\n                        if (this.options.visual) {\n                            this._redrawVisual();\n                        }\n                        else if (modelOptions.type) {\n                            this.options = deepExtend({}, this.options, modelOptions);\n                            this._redrawVisual();\n                        }\n                        if (this.options.content) {\n                            this._template();\n                            this.content(this.options.content);\n                        }\n                    }\n                    else {\n                        const bounds = this.bounds();\n                        bounds[field] = model[field];\n                        this.bounds(bounds);\n                    }\n                }\n                else {\n                    this.options = deepExtend({}, this.options, modelOptions);\n                }\n            }\n        }\n        /** @hidden */\n        _redrawVisual() {\n            this.visual.clear();\n            this._contentVisual = null;\n            this.options.dataItem = this.dataItem;\n            this.createShapeVisual();\n            this.updateBounds();\n        }\n        /**\n         * Redraws the shape's visual representation.\n         * Updates both the visual and content if present.\n         */\n        redrawVisual() {\n            this._redrawVisual();\n            if (this.options.content) {\n                this._template();\n                this.content(this.options.content);\n            }\n        }\n        /**\n         * Updates the shape's model data and optionally synchronizes changes.\n         * @param syncChanges Whether to synchronize changes immediately\n         */\n        updateModel(syncChanges) {\n            const diagram = this.diagram;\n            if (diagram && diagram._isEditable) {\n                diagram.updateShapeModel(this, syncChanges);\n            }\n        }\n        /**\n         * Updates the shape's bounds based on its visual representation and handles rotation and content alignment.\n         */\n        updateBounds() {\n            const bounds = this.visual._measure(true);\n            const options = this.options;\n            // Use measured dimensions for internal bounds (includes stroke width for correct rendering)\n            this.bounds(new Rect(options.x, options.y, bounds.width, bounds.height));\n            this._rotate();\n            this._alignContent();\n        }\n        /**\n         * Gets or sets the content of the shape.\n         * @param content The content to set. If not provided, returns the current content.\n         * @returns The current content when used as a getter\n         */\n        content(content) {\n            const result = this._content(content);\n            this._alignContent();\n            return result;\n        }\n        /** @hidden */\n        _alignContent() {\n            const contentOptions = this.options.content || {};\n            const contentVisual = this._contentVisual;\n            if (contentVisual && contentOptions.align && contentVisual.alignable !== false) {\n                const containerRect = this.visual._measure();\n                const aligner = new RectAlign(containerRect);\n                const contentBounds = contentVisual.drawingElement.bbox(null);\n                const contentRect = new Rect(0, 0, contentBounds.width(), contentBounds.height());\n                const alignedBounds = aligner.align(contentRect, contentOptions.align);\n                contentVisual.position(alignedBounds.topLeft());\n            }\n        }\n        /** @hidden */\n        _createConnectors() {\n            const options = this.options, currentConnectors = options.connectors || connectors[options.type] || DefaultConnectors, length = currentConnectors.length, connectorDefaults = options.connectorDefaults;\n            let connector, i;\n            for (i = 0; i < length; i++) {\n                connector = new Connector(this, deepExtend({}, connectorDefaults, currentConnectors[i]));\n                this.connectors.push(connector);\n            }\n        }\n        /**\n         * Gets or sets the bounds of the shape.\n         * @param value The bounds to set, or a string constant for different bound types ('TRANSFORMED', 'ABSOLUTE', 'ROTATED'). If not provided, returns the current bounds.\n         * @returns The bounds of the shape\n         */\n        bounds(value) {\n            let bounds;\n            if (value) {\n                if (isString$1(value)) {\n                    switch (value) {\n                        case TRANSFORMED: {\n                            bounds = this._transformedBounds();\n                            break;\n                        }\n                        case ABSOLUTE: {\n                            bounds = this._transformedBounds();\n                            const pan = this.diagram._pan;\n                            bounds.x += pan.x;\n                            bounds.y += pan.y;\n                            break;\n                        }\n                        case ROTATED: {\n                            bounds = this._rotatedBounds();\n                            break;\n                        }\n                        default: {\n                            bounds = this._bounds;\n                            break;\n                        }\n                    }\n                }\n                else {\n                    this._setBounds(value);\n                    this._triggerBoundsChange();\n                    if (!(this.diagram && this.diagram._layouting)) {\n                        this.refreshConnections();\n                    }\n                }\n            }\n            else {\n                bounds = this._bounds;\n            }\n            return bounds;\n        }\n        /** @hidden */\n        _setBounds(rect) {\n            const options = this.options;\n            const topLeft = rect.topLeft();\n            const x = options.x = topLeft.x;\n            const y = options.y = topLeft.y;\n            const width = options.width = Math.max(rect.width, options.minWidth);\n            const height = options.height = Math.max(rect.height, options.minHeight);\n            this._bounds = new Rect(x, y, width, height);\n            this.visual.redraw({\n                x: x,\n                y: y,\n                width: width,\n                height: height\n            });\n        }\n        /**\n         * Gets or sets the position of the shape.\n         * @param point The position to set. If not provided, returns the current position.\n         * @returns The current position when used as a getter\n         */\n        position(point) {\n            if (point) {\n                this.bounds(new Rect(point.x, point.y, this._bounds.width, this._bounds.height));\n            }\n            else {\n                return this._bounds.topLeft();\n            }\n        }\n        /**\n         * Returns a clone of this shape.\n         * @returns {Shape} A new Shape instance that is a copy of this shape\n         */\n        clone() {\n            const json = this.serialize();\n            json.options.id = randomId();\n            if (this.diagram && this.diagram._isEditable && defined(this.dataItem)) {\n                json.options.dataItem = this.diagram.options.cloneDataItem(this.dataItem);\n            }\n            return new Shape(json.options, undefined);\n        }\n        /**\n         * Selects or deselects the shape.\n         * @param value Whether to select (true) or deselect (false) the shape. If not provided, defaults to true.\n         * @returns True if the selection state changed, false otherwise\n         */\n        select(value) {\n            const diagram = this.diagram;\n            let selected, deselected;\n            if (isUndefined(value)) {\n                value = true;\n            }\n            if (this._canSelect()) {\n                if (this.isSelected !== value) {\n                    selected = [];\n                    deselected = [];\n                    this.isSelected = value;\n                    if (this.isSelected) {\n                        diagram._selectedItems.push(this);\n                        selected.push(this);\n                    }\n                    else {\n                        remove(diagram._selectedItems, this);\n                        deselected.push(this);\n                    }\n                    if (!diagram._internalSelection) {\n                        diagram._selectionChanged(selected, deselected);\n                    }\n                    return true;\n                }\n            }\n        }\n        /**\n         * Rotates the shape by the specified angle.\n         * @param angle The rotation angle in degrees. If not provided, returns the current rotation.\n         * @param center The center point for rotation. If not provided, uses the shape's center.\n         * @param undoable Whether the rotation should be undoable. Defaults to true.\n         * @returns The current rotation when used as a getter\n         */\n        rotate(angle, center, undoable) {\n            const rotate = this.visual.rotate();\n            if (angle !== undefined) {\n                if (undoable !== false && this.diagram && this.diagram.undoRedoService && angle !== rotate.angle) {\n                    this.diagram.undoRedoService.add(new RotateUnit(this.diagram._resizingAdorner, [this], [rotate.angle]), false);\n                }\n                const b = this.bounds(), sc = new Point(b.width / 2, b.height / 2);\n                let deltaAngle, newPosition;\n                if (center) {\n                    deltaAngle = angle - rotate.angle;\n                    newPosition = b.center().rotate(deltaAngle, center).minus(sc);\n                    this._rotationOffset = this._rotationOffset.plus(newPosition.minus(b.topLeft()));\n                    this.position(newPosition);\n                }\n                this.visual.rotate(angle, sc);\n                this.options.rotation.angle = angle;\n                if (this.diagram && this.diagram._connectorsAdorner) {\n                    this.diagram._connectorsAdorner.refresh();\n                }\n                this.refreshConnections();\n                if (this.diagram) {\n                    this.diagram.trigger(ITEMROTATE, { item: this });\n                }\n            }\n            return rotate;\n        }\n        /**\n         * Gets connections of this shape based on type.\n         * @param type The type of connections to retrieve: 'in' for incoming, 'out' for outgoing, or undefined for all connections.\n         * @returns Array of connections\n         */\n        connections(type) {\n            const result = [];\n            let i, j, con, cons, ctr;\n            for (i = 0; i < this.connectors.length; i++) {\n                ctr = this.connectors[i];\n                cons = ctr.connections;\n                for (j = 0, cons; j < cons.length; j++) {\n                    con = cons[j];\n                    if (type === 'out') {\n                        const source = con.source();\n                        if (source.shape && source.shape === this) {\n                            result.push(con);\n                        }\n                    }\n                    else if (type === 'in') {\n                        const target = con.target();\n                        if (target.shape && target.shape === this) {\n                            result.push(con);\n                        }\n                    }\n                    else {\n                        result.push(con);\n                    }\n                }\n            }\n            return result;\n        }\n        /**\n         * Refreshes all connections attached to this shape.\n         * Updates the visual representation of all connected connections.\n         */\n        refreshConnections() {\n            this.connections().forEach(function (connection) {\n                connection.refresh();\n            });\n        }\n        /**\n         * Gets a connector of this shape either by the connector's supposed name or\n         * via a Point in which case the closest connector will be returned.\n         *\n         * @param nameOrPoint The name of a Connector or a Point.\n         * @returns {Connector} The connector matching the name or closest to the point\n         */\n        getConnector(nameOrPoint) {\n            let i, ctr;\n            if (isString$1(nameOrPoint)) {\n                nameOrPoint = nameOrPoint.toLocaleLowerCase();\n                for (i = 0; i < this.connectors.length; i++) {\n                    ctr = this.connectors[i];\n                    if (ctr.options.name.toLocaleLowerCase() === nameOrPoint) {\n                        return ctr;\n                    }\n                }\n            }\n            else if (nameOrPoint instanceof Point) {\n                return closestConnector(nameOrPoint, this.connectors);\n            }\n            else {\n                return this.connectors.length ? this.connectors[0] : null;\n            }\n        }\n        /**\n         * Gets the position of the shape at a specific side.\n         * @param side The side to get position for (e.g., 'top', 'bottom', 'left', 'right', 'center')\n         * @returns The position point at the specified side\n         */\n        getPosition(side) {\n            const b = this.bounds(), fnName = side.charAt(0).toLowerCase() + side.slice(1);\n            if (isFunction$1(b[fnName])) {\n                return this._transformPoint(b[fnName]());\n            }\n            return b.center();\n        }\n        /**\n         * Redraws the shape with new options.\n         * @param options The options to apply when redrawing the shape\n         */\n        redraw(options) {\n            if (options) {\n                let shapeOptions = this.options;\n                let boundsChange;\n                this.shapeVisual.redraw(this._visualOptions(options));\n                if (this._diffNumericOptions(options, [WIDTH, HEIGHT, X, Y])) {\n                    this.bounds(new Rect(shapeOptions.x, shapeOptions.y, shapeOptions.width, shapeOptions.height));\n                    boundsChange = true;\n                }\n                if (options.connectors) {\n                    shapeOptions.connectors = options.connectors;\n                    this._updateConnectors();\n                }\n                shapeOptions = deepExtend(shapeOptions, options);\n                if (options.rotation || boundsChange) {\n                    this._rotate();\n                }\n                if (shapeOptions.content) {\n                    this.content(shapeOptions.content);\n                }\n            }\n        }\n        /** @hidden */\n        _updateConnectors() {\n            const connections = this.connections();\n            this.connectors = [];\n            this._createConnectors();\n            let connection;\n            let source;\n            let target;\n            for (let idx = 0; idx < connections.length; idx++) {\n                connection = connections[idx];\n                source = connection.source();\n                target = connection.target();\n                if (source.shape && source.shape === this) {\n                    connection.source(this.getConnector(source.options.name) || null);\n                }\n                else if (target.shape && target.shape === this) {\n                    connection.target(this.getConnector(target.options.name) || null);\n                }\n                connection.updateModel();\n            }\n        }\n        /** @hidden */\n        _diffNumericOptions(options, fields) {\n            return diffNumericOptions.call(this, options, fields);\n        }\n        /** @hidden */\n        _visualOptions(options) {\n            return {\n                cornerRadius: options.cornerRadius,\n                data: options.path,\n                source: options.source,\n                hover: options.hover,\n                fill: options.fill,\n                stroke: options.stroke,\n                dataItem: this.dataItem || (options === null || options === void 0 ? void 0 : options.dataItem),\n                autoSize: options.autoSize\n            };\n        }\n        /** @hidden */\n        _triggerBoundsChange() {\n            if (this.diagram) {\n                this.diagram.trigger(ITEMBOUNDSCHANGE, { item: this, bounds: this._bounds.clone() }); // the trigger modifies the arguments internally.\n            }\n        }\n        /** @hidden */\n        _transformPoint(point) {\n            const rotate = this.rotate(), bounds = this.bounds(), tl = bounds.topLeft();\n            if (rotate.angle) {\n                point.rotate(rotate.angle, rotate.center().plus(tl));\n            }\n            return point;\n        }\n        /** @hidden */\n        _transformedBounds() {\n            const bounds = this.bounds(), tl = bounds.topLeft(), br = bounds.bottomRight();\n            return Rect.fromPoints(this.diagram.modelToView(tl), this.diagram.modelToView(br));\n        }\n        /** @hidden */\n        _rotatedBounds() {\n            const bounds = this.bounds().rotatedBounds(this.rotate().angle), tl = bounds.topLeft(), br = bounds.bottomRight();\n            return Rect.fromPoints(tl, br);\n        }\n        /** @hidden */\n        _rotate() {\n            const rotation = this.options.rotation;\n            if (rotation && rotation.angle) {\n                this.rotate(rotation.angle);\n            }\n            this._rotationOffset = new Point();\n        }\n        /** @hidden */\n        _hover(value) {\n            const options = this.options, hover = options.hover;\n            let stroke = options.stroke, fill = options.fill;\n            if (value && isDefined(hover.stroke)) {\n                stroke = deepExtend({}, stroke, hover.stroke);\n            }\n            if (value && isDefined(hover.fill)) {\n                fill = hover.fill;\n            }\n            this.shapeVisual.redraw({\n                stroke: stroke,\n                fill: fill\n            });\n            if (options.editable && options.editable.connect) {\n                this.diagram._showConnectors(this, value);\n            }\n        }\n        /** @hidden */\n        _hitTest(value) {\n            if (this.visible()) {\n                const bounds = this.bounds(), angle = this.rotate().angle;\n                let rotatedPoint;\n                if (value.isEmpty && !value.isEmpty()) { // rect selection\n                    return Intersect.rects(value, bounds, angle ? angle : 0);\n                }\n                else { // point\n                    rotatedPoint = value.clone().rotate(angle, bounds.center()); // cloning is important because rotate modifies the point inline.\n                    if (bounds.contains(rotatedPoint)) {\n                        return this;\n                    }\n                }\n            }\n        }\n        /**\n         * Converts the shape to a JSON representation for serialization.\n         * @returns Object containing the shape's ID\n         */\n        toJSON() {\n            return {\n                shapeId: this.options.id\n            };\n        }\n        /**\n         * Creates the visual representation of the shape based on its type and options.\n         * Supports custom templates, predefined shapes (rectangle, circle, text, image), and custom paths.\n         */\n        createShapeVisual() {\n            const options = this.options;\n            const visualOptions = this._visualOptions(options);\n            const visualTemplate = options.visual ? TemplateService.compile(options.visual, options) : options.visual;\n            const type = (options.type + '').toLocaleLowerCase();\n            let shapeVisual;\n            visualOptions.width = options.width;\n            visualOptions.height = options.height;\n            if (isFunction$1(visualTemplate)) { // custom template\n                shapeVisual = visualTemplate.call(this, options);\n            }\n            else if (visualOptions.data) {\n                shapeVisual = new Path(visualOptions);\n                translateToOrigin(shapeVisual);\n            }\n            else if (type === 'rectangle') {\n                shapeVisual = new Rectangle(visualOptions);\n            }\n            else if (type === 'circle') {\n                shapeVisual = new Circle(visualOptions);\n            }\n            else if (type === 'text') {\n                shapeVisual = new TextBlock(visualOptions);\n            }\n            else if (type === 'image') {\n                shapeVisual = new Image(visualOptions);\n            }\n            else if (shapes[options.type]) {\n                shapeVisual = new shapes[options.type](visualOptions);\n            }\n            else {\n                shapeVisual = new Path(visualOptions);\n            }\n            this.shapeVisual = shapeVisual;\n            this.visual.append(this.shapeVisual);\n        }\n    }\n\n    class ConnectionEditAdorner extends AdornerBase {\n        constructor(connection, options) {\n            options = deepExtend({ handles: {} }, options);\n            super(connection.diagram, options);\n            this.connection = connection;\n            const diagram = this.connection.diagram;\n            this._ts = diagram.toolService;\n            const sp = this.connection.sourcePoint();\n            const tp = this.connection.targetPoint();\n            this.spVisual = new Circle(deepExtend(this.options.handles, { center: sp }));\n            this.epVisual = new Circle(deepExtend(this.options.handles, { center: tp }));\n            this.visual.append(this.spVisual);\n            this.visual.append(this.epVisual);\n        }\n        _getCursor() {\n            return Cursors.move;\n        }\n        start(p) {\n            this.handle = this._hitTest(p);\n            this.startPoint = p;\n            this._initialSource = this.connection.source();\n            this._initialTarget = this.connection.target();\n            switch (this.handle) {\n                case -1:\n                    if (this.connection.targetConnector) {\n                        this._ts._connectionManipulation(this.connection, this.connection.targetConnector.shape);\n                    }\n                    break;\n                case 1:\n                    if (this.connection.sourceConnector) {\n                        this._ts._connectionManipulation(this.connection, this.connection.sourceConnector.shape);\n                    }\n                    break;\n                default:\n                    break;\n            }\n        }\n        move(handle, p) {\n            switch (handle) {\n                case -1:\n                    this.connection.source(p);\n                    break;\n                case 1:\n                    this.connection.target(p);\n                    break;\n                default: {\n                    const delta = p.minus(this.startPoint);\n                    this.startPoint = p;\n                    if (!this.connection.sourceConnector) {\n                        this.connection.source(this.connection.sourcePoint().plus(delta));\n                    }\n                    if (!this.connection.targetConnector) {\n                        this.connection.target(this.connection.targetPoint().plus(delta));\n                    }\n                    break;\n                }\n            }\n            this.refresh();\n            return true;\n        }\n        stop(p) {\n            const ts = this.diagram.toolService, item = ts.hoveredItem;\n            let target;\n            if (ts._hoveredConnector) {\n                target = ts._hoveredConnector._c;\n            }\n            else if (item && item instanceof Shape) {\n                target = item.getConnector(AUTO) || item.getConnector(p);\n            }\n            else {\n                target = p;\n            }\n            if (this.handle === -1) {\n                this.connection.source(target);\n            }\n            else if (this.handle === 1) {\n                this.connection.target(target);\n            }\n            this.handle = undefined;\n            this._ts._connectionManipulation();\n            return new ConnectionEditUndoUnit(this.connection, this._initialSource, this._initialTarget);\n        }\n        _hitTest(point) {\n            const sourcePoint = this.connection.sourcePoint();\n            const targetPoint = this.connection.targetPoint();\n            const radiusX = this.options.handles.width / 2 + HIT_TEST_DISTANCE;\n            const radiusY = this.options.handles.height / 2 + HIT_TEST_DISTANCE;\n            const sourcePointDistance = sourcePoint.distanceTo(point);\n            const targetPointDistance = targetPoint.distanceTo(point);\n            const sourceHandle = new Rect(sourcePoint.x, sourcePoint.y).inflate(radiusX, radiusY).contains(point);\n            const targetHandle = new Rect(targetPoint.x, targetPoint.y).inflate(radiusX, radiusY).contains(point);\n            let handle = 0;\n            if (sourceHandle && (!targetHandle || sourcePointDistance < targetPointDistance)) {\n                handle = -1;\n            }\n            else if (targetHandle && (!sourceHandle || targetPointDistance < sourcePointDistance)) {\n                handle = 1;\n            }\n            return handle;\n        }\n        refresh() {\n            this.spVisual.redraw({ center: this.diagram.modelToLayer(this.connection.sourcePoint()) });\n            this.epVisual.redraw({ center: this.diagram.modelToLayer(this.connection.targetPoint()) });\n        }\n    }\n\n    class ConnectorVisual {\n        constructor(connector) {\n            this.options = deepExtend({}, connector.options);\n            this._c = connector;\n            this.visual = new Circle(this.options);\n            this.refresh();\n        }\n        _hover(value) {\n            const options = this.options, hover = options.hover;\n            let stroke = options.stroke, fill = options.fill;\n            if (value && isDefined(hover.stroke)) {\n                stroke = deepExtend({}, stroke, hover.stroke);\n            }\n            if (value && isDefined(hover.fill)) {\n                fill = hover.fill;\n            }\n            this.visual.redraw({\n                stroke: stroke,\n                fill: fill\n            });\n        }\n        refresh() {\n            const p = this._c.shape.diagram.modelToView(this._c.position()), relative = p.minus(this._c.shape.bounds('transformed').topLeft()), value = new Rect(p.x, p.y, 0, 0);\n            value.inflate(this.options.width / 2, this.options.height / 2);\n            this._visualBounds = value;\n            this.visual.redraw({ center: new Point(relative.x, relative.y) });\n        }\n        _hitTest(p) {\n            const tp = this._c.shape.diagram.modelToView(p);\n            return this._visualBounds.contains(tp);\n        }\n    }\n\n    class ConnectorsAdorner extends AdornerBase {\n        constructor(diagram, options) {\n            super(diagram, options);\n            this._refreshHandler = (e) => {\n                if (e.item === this.shape) {\n                    this.refresh();\n                }\n            };\n        }\n        show(shape) {\n            this._visible = true;\n            this.shape = shape;\n            this.diagram.bind(ITEMBOUNDSCHANGE, this._refreshHandler);\n            this.connectors = [];\n            this._clearVisual();\n            const len = shape.connectors.length;\n            for (let i = 0; i < len; i++) {\n                const ctr = new ConnectorVisual(shape.connectors[i]);\n                this.connectors.push(ctr);\n                this.visual.append(ctr.visual);\n            }\n            this.visual.visible(true);\n            this.refresh();\n        }\n        _clearVisual() {\n            if (this.diagram._cachedTouchTarget) {\n                this._keepCachedTouchTarget();\n            }\n            else {\n                this.visual.clear();\n            }\n        }\n        _keepCachedTouchTarget() {\n            const visualChildren = this.visual.children;\n            const childrenCount = visualChildren.length;\n            const index = inArray(this.diagram._cachedTouchTarget, visualChildren);\n            for (let i = childrenCount - 1; i >= 0; i--) {\n                if (i === index) {\n                    continue;\n                }\n                this.visual.remove(visualChildren[i]);\n            }\n        }\n        destroy() {\n            this.diagram.unbind(ITEMBOUNDSCHANGE, this._refreshHandler);\n            this.shape = undefined;\n            this._visible = undefined;\n            this.visual.visible(false);\n        }\n        _hitTest(p) {\n            let ctr, i;\n            for (i = 0; i < this.connectors.length; i++) {\n                ctr = this.connectors[i];\n                if (ctr._hitTest(p)) {\n                    ctr._hover(true);\n                    this.diagram.toolService._hoveredConnector = ctr;\n                    break;\n                }\n            }\n        }\n        refresh() {\n            if (this.shape) {\n                let bounds = this.shape.bounds();\n                bounds = this.diagram.modelToLayer(bounds);\n                this.visual.position(bounds.topLeft());\n                this.connectors.forEach(function (ctr) {\n                    ctr.refresh();\n                });\n            }\n        }\n    }\n\n    function canDrag(element) {\n        const editable = element.options.editable;\n        return editable && editable.drag !== false;\n    }\n\n    /**\n     * Holds the undoredo state when performing a rotation, translation or scaling. The adorner is optional.\n     *\n     * @type {*}\n     */\n    class TransformUnit {\n        constructor(shapes, undoStates, adorner) {\n            this.shapes = shapes;\n            this.undoStates = undoStates;\n            this.title = 'Transformation';\n            this.redoStates = [];\n            this.adorner = adorner;\n            for (let i = 0; i < this.shapes.length; i++) {\n                const shape = this.shapes[i];\n                this.redoStates.push(shape.bounds());\n            }\n        }\n        undo() {\n            for (let i = 0; i < this.shapes.length; i++) {\n                const shape = this.shapes[i];\n                shape.bounds(this.undoStates[i]);\n                if ('layout' in shape) {\n                    shape.layout(shape, this.redoStates[i], this.undoStates[i]);\n                }\n                shape.updateModel();\n            }\n            if (this.adorner) {\n                this.adorner.refreshBounds();\n                this.adorner.refresh();\n            }\n        }\n        redo() {\n            for (let i = 0; i < this.shapes.length; i++) {\n                const shape = this.shapes[i];\n                shape.bounds(this.redoStates[i]);\n                // the 'layout' property, if implemented, lets the shape itself work out what to do with the new bounds\n                if ('layout' in shape) {\n                    shape.layout(shape, this.undoStates[i], this.redoStates[i]);\n                }\n                shape.updateModel();\n            }\n            if (this.adorner) {\n                this.adorner.refreshBounds();\n                this.adorner.refresh();\n            }\n        }\n    }\n\n    function hitToOppositeSide(hit, bounds) {\n        let result;\n        if (hit.x === -1 && hit.y === -1) {\n            result = bounds.bottomRight();\n        }\n        else if (hit.x === 1 && hit.y === 1) {\n            result = bounds.topLeft();\n        }\n        else if (hit.x === -1 && hit.y === 1) {\n            result = bounds.topRight();\n        }\n        else if (hit.x === 1 && hit.y === -1) {\n            result = bounds.bottomLeft();\n        }\n        else if (hit.x === 0 && hit.y === -1) {\n            result = bounds.bottom();\n        }\n        else if (hit.x === 0 && hit.y === 1) {\n            result = bounds.top();\n        }\n        else if (hit.x === 1 && hit.y === 0) {\n            result = bounds.left();\n        }\n        else if (hit.x === -1 && hit.y === 0) {\n            result = bounds.right();\n        }\n        return result;\n    }\n    const defaultOptions$3 = {\n        handles: {\n            fill: {\n                color: '#fff'\n            },\n            stroke: {\n                color: '#282828'\n            },\n            height: 7,\n            width: 7,\n            hover: {\n                fill: {\n                    color: '#282828'\n                },\n                stroke: {\n                    color: '#282828'\n                }\n            }\n        },\n        selectable: {\n            stroke: {\n                color: '#778899',\n                width: 1,\n                dashType: 'dash'\n            },\n            fill: {\n                color: TRANSPARENT\n            }\n        },\n        offset: 10\n    };\n    class ResizingAdorner extends AdornerBase {\n        constructor(diagram, options) {\n            options = deepExtend({}, defaultOptions$3, options);\n            super(diagram, options);\n            this._manipulating = false;\n            this.map = [];\n            this.shapes = [];\n            this.shapeStates = [];\n            this._initSelection();\n            this._createHandles();\n            this.redraw();\n            this.diagram.bind('select', () => {\n                this._initialize();\n            });\n            this._refreshHandler = () => {\n                if (!this._internalChange) {\n                    this.refreshBounds();\n                    this.refresh();\n                }\n            };\n            this._rotatedHandler = () => {\n                if (this.shapes.length === 1) {\n                    this._angle = this.shapes[0].rotate().angle;\n                }\n                this._refreshHandler();\n            };\n            this.diagram.bind(ITEMBOUNDSCHANGE, this._refreshHandler).bind(ITEMROTATE, this._rotatedHandler);\n            this.refreshBounds();\n            this.refresh();\n        }\n        _initSelection() {\n            const diagram = this.diagram;\n            const selectable = diagram.options.selectable;\n            const options = deepExtend({}, this.options.selectable, selectable);\n            this.rect = new Rectangle(options);\n            this.visual.append(this.rect);\n        }\n        _resizable() {\n            return this.options.editable && this.options.editable.resize !== false;\n        }\n        _handleOptions() {\n            return (this.options.editable.resize || {}).handles || this.options.handles;\n        }\n        _createHandles() {\n            let handles, item, y, x;\n            if (this._resizable()) {\n                handles = this._handleOptions();\n                for (x = -1; x <= 1; x++) {\n                    for (y = -1; y <= 1; y++) {\n                        if ((x !== 0) || (y !== 0)) { // (0, 0) element, (-1, -1) top-left, (+1, +1) bottom-right\n                            item = new Rectangle(handles);\n                            item.drawingElement._hover = this._hover.bind(this);\n                            this.map.push({ x: x, y: y, visual: item });\n                            this.visual.append(item);\n                        }\n                    }\n                }\n            }\n        }\n        bounds(value) {\n            if (value) {\n                this._innerBounds = value.clone();\n                this._bounds = this.diagram.modelToLayer(value).inflate(this.options.offset, this.options.offset);\n            }\n            else {\n                return this._bounds;\n            }\n        }\n        _hitTest(p) {\n            const handlesCount = this.map.length;\n            let tp = this.diagram.modelToLayer(p), i, hit, handleBounds, handle;\n            if (this._angle) {\n                tp = tp.clone().rotate(this._angle, this._bounds.center());\n            }\n            if (this._resizable()) {\n                for (i = 0; i < handlesCount; i++) {\n                    handle = this.map[i];\n                    hit = new Point(handle.x, handle.y);\n                    handleBounds = this._getHandleBounds(hit); // local coordinates\n                    handleBounds.offset(this._bounds.x, this._bounds.y);\n                    if (handleBounds.contains(tp)) {\n                        return hit;\n                    }\n                }\n            }\n            if (this._bounds.contains(tp)) {\n                return new Point(0, 0);\n            }\n        }\n        _getHandleBounds(p) {\n            if (this._resizable()) {\n                const handles = this._handleOptions(), w = handles.width, h = handles.height, r = new Rect(0, 0, w, h);\n                if (p.x < 0) {\n                    r.x = -w / 2;\n                }\n                else if (p.x === 0) {\n                    r.x = Math.floor(this._bounds.width / 2) - w / 2;\n                }\n                else if (p.x > 0) {\n                    r.x = this._bounds.width + 1.0 - w / 2;\n                }\n                if (p.y < 0) {\n                    r.y = -h / 2;\n                }\n                else if (p.y === 0) {\n                    r.y = Math.floor(this._bounds.height / 2) - h / 2;\n                }\n                else if (p.y > 0) {\n                    r.y = this._bounds.height + 1.0 - h / 2;\n                }\n                return r;\n            }\n        }\n        _getCursor(point) {\n            let hit = this._hitTest(point);\n            if (hit && (hit.x >= -1) && (hit.x <= 1) && (hit.y >= -1) && (hit.y <= 1) && this._resizable()) {\n                const angle = this._angle;\n                if (angle) {\n                    hit.rotate(angle, new Point(0, 0));\n                    hit = new Point(Math.round(hit.x), Math.round(hit.y));\n                }\n                if (hit.x === -1 && hit.y === -1) {\n                    return 'nw-resize';\n                }\n                if (hit.x === 1 && hit.y === 1) {\n                    return 'se-resize';\n                }\n                if (hit.x === -1 && hit.y === 1) {\n                    return 'sw-resize';\n                }\n                if (hit.x === 1 && hit.y === -1) {\n                    return 'ne-resize';\n                }\n                if (hit.x === 0 && hit.y === -1) {\n                    return 'n-resize';\n                }\n                if (hit.x === 0 && hit.y === 1) {\n                    return 's-resize';\n                }\n                if (hit.x === 1 && hit.y === 0) {\n                    return 'e-resize';\n                }\n                if (hit.x === -1 && hit.y === 0) {\n                    return 'w-resize';\n                }\n            }\n            return this._manipulating ? Cursors.move : Cursors.select;\n        }\n        _initialize() {\n            let i, item;\n            const items = this.diagram.select();\n            this.shapes = [];\n            for (i = 0; i < items.length; i++) {\n                item = items[i];\n                if (item instanceof Shape) {\n                    this.shapes.push(item);\n                    item._rotationOffset = new Point();\n                }\n            }\n            this._angle = this.shapes.length === 1 ? this.shapes[0].rotate().angle : 0;\n            this._startAngle = this._angle;\n            this._rotates();\n            this._positions();\n            this.refreshBounds();\n            this.refresh();\n            this.redraw();\n        }\n        _rotates() {\n            let i, shape;\n            this.initialRotates = [];\n            for (i = 0; i < this.shapes.length; i++) {\n                shape = this.shapes[i];\n                this.initialRotates.push(shape.rotate().angle);\n            }\n        }\n        _positions() {\n            let i, shape;\n            this.initialStates = [];\n            for (i = 0; i < this.shapes.length; i++) {\n                shape = this.shapes[i];\n                this.initialStates.push(shape.bounds());\n            }\n        }\n        _hover(value, element) {\n            if (this._resizable()) {\n                const handleOptions = this._handleOptions(), hover = handleOptions.hover;\n                let stroke = handleOptions.stroke, fill = handleOptions.fill;\n                if (value && isDefined(hover.stroke)) {\n                    stroke = deepExtend({}, stroke, hover.stroke);\n                }\n                if (value && isDefined(hover.fill)) {\n                    fill = hover.fill;\n                }\n                element.stroke(stroke.color, stroke.width, stroke.opacity);\n                element.fill(fill.color, fill.opacity);\n            }\n        }\n        start(p) {\n            this._sp = p;\n            this._cp = p;\n            this._lp = p;\n            this._manipulating = true;\n            this._internalChange = true;\n            this.shapeStates = [];\n            for (let i = 0; i < this.shapes.length; i++) {\n                const shape = this.shapes[i];\n                this.shapeStates.push(shape.bounds());\n            }\n        }\n        redraw() {\n            let i, handle;\n            const visibleHandles = this._resizable();\n            for (i = 0; i < this.map.length; i++) {\n                handle = this.map[i];\n                handle.visual.visible(visibleHandles);\n            }\n        }\n        angle(value) {\n            if (defined(value)) {\n                this._angle = value;\n            }\n            return this._angle;\n        }\n        rotate() {\n            const center = this._innerBounds.center();\n            let currentAngle = this.angle();\n            this._internalChange = true;\n            for (let i = 0; i < this.shapes.length; i++) {\n                const shape = this.shapes[i];\n                currentAngle = (currentAngle + this.initialRotates[i] - this._startAngle) % 360;\n                shape.rotate(currentAngle, center);\n            }\n            this.refresh();\n        }\n        move(handle, p) {\n            let delta, dragging, dtl = new Point(), dbr = new Point(), bounds, center, shape, i, angle, newBounds, changed = 0, staticPoint, scaleX, scaleY;\n            if (handle.y === -2 && handle.x === -1) {\n                center = this._innerBounds.center();\n                this._angle = this._truncateAngle(findAngle(center, p));\n                for (i = 0; i < this.shapes.length; i++) {\n                    shape = this.shapes[i];\n                    angle = (this._angle + this.initialRotates[i] - this._startAngle) % 360;\n                    shape.rotate(angle, center);\n                    if (Object.prototype.hasOwnProperty.call(shape, 'layout')) {\n                        shape.layout(shape);\n                    }\n                    this._rotating = true;\n                }\n                this.refresh();\n            }\n            else {\n                if (this.shouldSnap()) {\n                    const thr = this._truncateDistance(p.minus(this._lp));\n                    // threshold\n                    if (thr.x === 0 && thr.y === 0) {\n                        this._cp = p;\n                        return;\n                    }\n                    delta = thr;\n                    this._lp = new Point(this._lp.x + thr.x, this._lp.y + thr.y);\n                }\n                else {\n                    delta = p.minus(this._cp);\n                }\n                if (this.isDragHandle(handle)) {\n                    dbr = dtl = delta; // dragging\n                    dragging = true;\n                }\n                else {\n                    if (this._angle) { // adjust the delta so this resizers resize in the correct direction after rotation.\n                        delta.rotate(this._angle, new Point(0, 0));\n                    }\n                    if (handle.x === -1) {\n                        dtl.x = delta.x;\n                    }\n                    else if (handle.x === 1) {\n                        dbr.x = delta.x;\n                    }\n                    if (handle.y === -1) {\n                        dtl.y = delta.y;\n                    }\n                    else if (handle.y === 1) {\n                        dbr.y = delta.y;\n                    }\n                }\n                if (!dragging) {\n                    staticPoint = hitToOppositeSide(handle, this._innerBounds);\n                    scaleX = (this._innerBounds.width + delta.x * handle.x) / this._innerBounds.width;\n                    scaleY = (this._innerBounds.height + delta.y * handle.y) / this._innerBounds.height;\n                }\n                for (i = 0; i < this.shapes.length; i++) {\n                    shape = this.shapes[i];\n                    bounds = shape.bounds();\n                    if (dragging) {\n                        if (!canDrag(shape)) {\n                            continue;\n                        }\n                        newBounds = this._displaceBounds(bounds, dtl, dbr, dragging);\n                    }\n                    else {\n                        newBounds = bounds.clone();\n                        newBounds.scale(scaleX, scaleY, staticPoint, this._innerBounds.center(), shape.rotate().angle);\n                        const newCenter = newBounds.center(); // fixes the new rotation center.\n                        newCenter.rotate(-this._angle, bounds.center());\n                        newBounds = new Rect(newCenter.x - newBounds.width / 2, newCenter.y - newBounds.height / 2, newBounds.width, newBounds.height);\n                    }\n                    if (newBounds.width >= shape.options.minWidth && newBounds.height >= shape.options.minHeight) { // if we up-size very small shape\n                        const oldBounds = bounds;\n                        shape.bounds(newBounds);\n                        if (Object.prototype.hasOwnProperty.call(shape, 'layout')) {\n                            shape.layout(shape, oldBounds, newBounds);\n                        }\n                        if (oldBounds.width !== newBounds.width || oldBounds.height !== newBounds.height) {\n                            shape.rotate(shape.rotate().angle); // forces the rotation to update it's rotation center\n                        }\n                        changed += 1;\n                    }\n                }\n                if (changed) {\n                    if (changed === i) {\n                        newBounds = this._displaceBounds(this._innerBounds, dtl, dbr, dragging);\n                        this.bounds(newBounds);\n                    }\n                    else {\n                        this.refreshBounds();\n                    }\n                    this.refresh();\n                }\n                this._positions();\n            }\n            this._cp = p;\n        }\n        isDragHandle(handle) {\n            return handle.x === 0 && handle.y === 0;\n        }\n        cancel() {\n            const shapes = this.shapes;\n            const states = this.shapeStates;\n            for (let idx = 0; idx < shapes.length; idx++) {\n                shapes[idx].bounds(states[idx]);\n            }\n            this.refreshBounds();\n            this.refresh();\n            this._manipulating = undefined;\n            this._internalChange = undefined;\n            this._rotating = undefined;\n        }\n        _truncatePositionToGuides(bounds) {\n            if (this.diagram.ruler) {\n                return this.diagram.ruler.truncatePositionToGuides(bounds);\n            }\n            return bounds;\n        }\n        _truncateSizeToGuides(bounds) {\n            if (this.diagram.ruler) {\n                return this.diagram.ruler.truncateSizeToGuides(bounds);\n            }\n            return bounds;\n        }\n        _truncateAngle(a) {\n            const snap = this.snapOptions();\n            const snapAngle = Math.max(snap.angle || DEFAULT_SNAP_ANGLE, MIN_SNAP_ANGLE);\n            return snap ? Math.floor((a % 360) / snapAngle) * snapAngle : (a % 360);\n        }\n        _truncateDistance(d) {\n            if (d instanceof Point) {\n                return new Point(this._truncateDistance(d.x), this._truncateDistance(d.y));\n            }\n            else {\n                const snap = this.snapOptions() || {};\n                const snapSize = Math.max(snap.size || DEFAULT_SNAP_SIZE, MIN_SNAP_SIZE);\n                return snap ? Math.floor(d / snapSize) * snapSize : d;\n            }\n        }\n        snapOptions() {\n            const editable = this.diagram.options.editable;\n            const snap = ((editable || {}).drag || {}).snap || {};\n            return snap;\n        }\n        shouldSnap() {\n            const editable = this.diagram.options.editable;\n            const drag = (editable || {}).drag;\n            const snap = (drag || {}).snap;\n            return editable !== false && drag !== false && snap !== false;\n        }\n        _displaceBounds(bounds, dtl, dbr, dragging) {\n            const tl = bounds.topLeft().plus(dtl), br = bounds.bottomRight().plus(dbr);\n            let newBounds = Rect.fromPoints(tl, br), newCenter;\n            if (!dragging) {\n                newCenter = newBounds.center();\n                newCenter.rotate(-this._angle, bounds.center());\n                newBounds = new Rect(newCenter.x - newBounds.width / 2, newCenter.y - newBounds.height / 2, newBounds.width, newBounds.height);\n            }\n            return newBounds;\n        }\n        stop() {\n            var _a, _b;\n            let unit, i, shape, bounds;\n            if (this._cp !== this._sp) {\n                if (this._rotating) {\n                    unit = new RotateUnit(this, this.shapes, this.initialRotates);\n                    this._rotating = false;\n                }\n                else if (this._diffStates()) {\n                    if (this.diagram.ruler) {\n                        for (i = 0; i < this.shapes.length; i++) {\n                            shape = this.shapes[i];\n                            bounds = shape.bounds();\n                            bounds = this._truncateSizeToGuides(this._truncatePositionToGuides(bounds));\n                            shape.bounds(bounds);\n                            this.refreshBounds();\n                            this.refresh();\n                        }\n                    }\n                    for (i = 0; i < this.shapes.length; i++) {\n                        shape = this.shapes[i];\n                        bounds = shape.bounds();\n                        const strokeWidth = (((_b = (_a = shape.shapeVisual) === null || _a === void 0 ? void 0 : _a.options.stroke) === null || _b === void 0 ? void 0 : _b.width) || 0);\n                        if (shape._originalWidth + strokeWidth !== bounds.width) {\n                            shape._originalWidth = bounds.width - strokeWidth;\n                        }\n                        if (shape._originalHeight + strokeWidth !== bounds.height) {\n                            shape._originalHeight = bounds.height - strokeWidth;\n                        }\n                        shape.updateModel();\n                    }\n                    unit = new TransformUnit(this.shapes, this.shapeStates, this);\n                    this.diagram._syncShapeChanges();\n                }\n            }\n            this._manipulating = undefined;\n            this._internalChange = undefined;\n            this._rotating = undefined;\n            return unit;\n        }\n        _diffStates() {\n            const shapes = this.shapes;\n            const states = this.shapeStates;\n            for (let idx = 0; idx < shapes.length; idx++) {\n                if (!shapes[idx].bounds().equals(states[idx])) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        refreshBounds() {\n            const bounds = this.shapes.length === 1 ?\n                this.shapes[0].bounds().clone() :\n                this.diagram.boundingBox(this.shapes, true);\n            this.bounds(bounds);\n        }\n        refresh() {\n            let b, bounds;\n            if (this.shapes.length > 0) {\n                bounds = this.bounds();\n                this.visual.visible(true);\n                this.visual.position(bounds.topLeft());\n                this.map.forEach((m) => {\n                    b = this._getHandleBounds(new Point(m.x, m.y));\n                    m.visual.position(b.topLeft());\n                });\n                this.visual.position(bounds.topLeft());\n                const center = new Point(bounds.width / 2, bounds.height / 2);\n                this.visual.rotate(this._angle, center);\n                this.rect.redraw({ width: bounds.width, height: bounds.height });\n                if (this.rotationThumb) {\n                    const thumb = this.options.editable.rotate.thumb;\n                    this._rotationThumbBounds = new Rect(bounds.center().x, bounds.y + thumb.y, 0, 0).inflate(thumb.width);\n                    this.rotationThumb.redraw({ x: bounds.width / 2 - thumb.width / 2 });\n                }\n            }\n            else {\n                this.visual.visible(false);\n            }\n        }\n    }\n\n    const defaultOptions$2 = {\n        stroke: {\n            color: '#778899',\n            width: 1,\n            dashType: 'dash'\n        },\n        fill: {\n            color: TRANSPARENT\n        }\n    };\n    class Selector {\n        constructor(diagram) {\n            const selectable = diagram.options.selectable;\n            this.options = deepExtend({}, defaultOptions$2, selectable);\n            this.visual = new Rectangle(this.options);\n            this.diagram = diagram;\n        }\n        start(p) {\n            this._sp = this._ep = p;\n            this.refresh();\n            this.diagram._adorn(this, true);\n        }\n        end() {\n            this._sp = this._ep = undefined;\n            this.diagram._adorn(this, false);\n        }\n        bounds(value) {\n            if (value) {\n                this._bounds = value;\n            }\n            return this._bounds;\n        }\n        move(p) {\n            this._ep = p;\n            this.refresh();\n        }\n        refresh() {\n            if (this._sp) {\n                const visualBounds = Rect.fromPoints(this.diagram.modelToLayer(this._sp), this.diagram.modelToLayer(this._ep));\n                this.bounds(Rect.fromPoints(this._sp, this._ep));\n                this.visual.position(visualBounds.topLeft());\n                this.visual.redraw({ height: visualBounds.height + 1, width: visualBounds.width + 1 });\n            }\n        }\n    }\n\n    /**\n     * Base class for connection routers.\n     */\n    class ConnectionRouterBase {\n        constructor() { }\n    }\n\n    /**\n     * Base class for polyline and cascading routing.\n     */\n    class LinearConnectionRouter extends ConnectionRouterBase {\n        constructor(connection) {\n            super();\n            this.connection = connection;\n        }\n        /**\n         * Hit testing for polyline paths.\n         */\n        hitTest(p) {\n            const rec = this.getBounds().inflate(HIT_TEST_DISTANCE);\n            if (!rec.contains(p)) {\n                return false;\n            }\n            return Geometry.distanceToPolyline(p, this.connection.allPoints()) < HIT_TEST_DISTANCE;\n        }\n        /**\n         * Bounds of a polyline.\n         *\n         * @returns {kendo.dataviz.diagram.Rect}\n         */\n        getBounds() {\n            const points = this.connection.allPoints(), s = points[0], e = points[points.length - 1];\n            let right = Math.max(s.x, e.x), left = Math.min(s.x, e.x), top = Math.min(s.y, e.y), bottom = Math.max(s.y, e.y);\n            for (let i = 1; i < points.length - 1; ++i) {\n                right = Math.max(right, points[i].x);\n                left = Math.min(left, points[i].x);\n                top = Math.min(top, points[i].y);\n                bottom = Math.max(bottom, points[i].y);\n            }\n            return new Rect(left, top, right - left, bottom - top);\n        }\n    }\n\n    const topLeft = 'topLeft';\n    const bottomRight = 'bottomRight';\n    class CascadingRouter extends LinearConnectionRouter {\n        constructor(connection) {\n            super(connection);\n            this.SAME_SIDE_DISTANCE_RATIO = 5;\n            this._connectorSides = [{\n                    name: TOP,\n                    axis: Y,\n                    boundsPoint: topLeft,\n                    secondarySign: 1\n                }, {\n                    name: LEFT,\n                    axis: X,\n                    boundsPoint: topLeft,\n                    secondarySign: 1\n                }, {\n                    name: BOTTOM,\n                    axis: Y,\n                    boundsPoint: bottomRight,\n                    secondarySign: -1\n                }, {\n                    name: RIGHT,\n                    axis: X,\n                    boundsPoint: bottomRight,\n                    secondarySign: -1\n                }];\n            this.connection = connection;\n        }\n        routePoints(start, end, sourceConnector, targetConnector) {\n            let result;\n            if (sourceConnector && targetConnector) {\n                result = this._connectorPoints(start, end, sourceConnector, targetConnector);\n            }\n            else {\n                result = this._floatingPoints(start, end, sourceConnector);\n            }\n            return result;\n        }\n        route() {\n            const sourceConnector = this.connection._resolvedSourceConnector;\n            const targetConnector = this.connection._resolvedTargetConnector;\n            const start = this.connection.sourcePoint();\n            const end = this.connection.targetPoint();\n            const points = this.routePoints(start, end, sourceConnector, targetConnector);\n            this.connection.points(points);\n        }\n        _connectorSide(connector, targetPoint) {\n            const position = connector.position();\n            const shapeBounds = connector.shape.bounds(ROTATED);\n            const bounds = {\n                topLeft: shapeBounds.topLeft(),\n                bottomRight: shapeBounds.bottomRight()\n            };\n            const sides = this._connectorSides;\n            let min = Number.MAX_VALUE;\n            let sideDistance;\n            let minSide;\n            let axis;\n            let side;\n            for (let idx = 0; idx < sides.length; idx++) {\n                side = sides[idx];\n                axis = side.axis;\n                sideDistance = Math.round(Math.abs(position[axis] - bounds[side.boundsPoint][axis]));\n                if (sideDistance < min) {\n                    min = sideDistance;\n                    minSide = side;\n                }\n                else if (sideDistance === min &&\n                    (position[axis] - targetPoint[axis]) * side.secondarySign > (position[minSide.axis] - targetPoint[minSide.axis]) * minSide.secondarySign) {\n                    minSide = side;\n                }\n            }\n            return minSide.name;\n        }\n        _sameSideDistance(connector) {\n            const bounds = connector.shape.bounds(ROTATED);\n            return Math.min(bounds.width, bounds.height) / this.SAME_SIDE_DISTANCE_RATIO;\n        }\n        _connectorPoints(start, end, sourceConnector, targetConnector) {\n            const sourceConnectorSide = this._connectorSide(sourceConnector, end);\n            const targetConnectorSide = this._connectorSide(targetConnector, start);\n            const deltaX = end.x - start.x;\n            const deltaY = end.y - start.y;\n            const sameSideDistance = this._sameSideDistance(sourceConnector);\n            let result = [];\n            let pointX, pointY;\n            if (sourceConnectorSide === TOP || sourceConnectorSide === BOTTOM) {\n                if (targetConnectorSide === TOP || targetConnectorSide === BOTTOM) {\n                    if (sourceConnectorSide === targetConnectorSide) {\n                        if (sourceConnectorSide === TOP) {\n                            pointY = Math.min(start.y, end.y) - sameSideDistance;\n                        }\n                        else {\n                            pointY = Math.max(start.y, end.y) + sameSideDistance;\n                        }\n                        result = [new Point(start.x, pointY), new Point(end.x, pointY)];\n                    }\n                    else {\n                        result = [new Point(start.x, start.y + deltaY / 2), new Point(end.x, start.y + deltaY / 2)];\n                    }\n                }\n                else {\n                    result = [new Point(start.x, end.y)];\n                }\n            }\n            else {\n                if (targetConnectorSide === LEFT || targetConnectorSide === RIGHT) {\n                    if (sourceConnectorSide === targetConnectorSide) {\n                        if (sourceConnectorSide === LEFT) {\n                            pointX = Math.min(start.x, end.x) - sameSideDistance;\n                        }\n                        else {\n                            pointX = Math.max(start.x, end.x) + sameSideDistance;\n                        }\n                        result = [new Point(pointX, start.y), new Point(pointX, end.y)];\n                    }\n                    else {\n                        result = [new Point(start.x + deltaX / 2, start.y), new Point(start.x + deltaX / 2, start.y + deltaY)];\n                    }\n                }\n                else {\n                    result = [new Point(end.x, start.y)];\n                }\n            }\n            return result;\n        }\n        _floatingPoints(start, end, sourceConnector) {\n            const sourceConnectorSide = sourceConnector ? this._connectorSide(sourceConnector, end) : null;\n            const cascadeStartHorizontal = this._startHorizontal(start, end, sourceConnectorSide);\n            const points = [start, start, end, end];\n            const deltaX = end.x - start.x;\n            const deltaY = end.y - start.y;\n            const length = points.length;\n            let idx = 1;\n            let shiftX;\n            let shiftY;\n            // note that this is more generic than needed for only two intermediate points.\n            for (; idx < length - 1; ++idx) {\n                if (cascadeStartHorizontal) {\n                    if (idx % 2 !== 0) {\n                        shiftX = deltaX / (length / 2);\n                        shiftY = 0;\n                    }\n                    else {\n                        shiftX = 0;\n                        shiftY = deltaY / ((length - 1) / 2);\n                    }\n                }\n                else {\n                    if (idx % 2 !== 0) {\n                        shiftX = 0;\n                        shiftY = deltaY / (length / 2);\n                    }\n                    else {\n                        shiftX = deltaX / ((length - 1) / 2);\n                        shiftY = 0;\n                    }\n                }\n                points[idx] = new Point(points[idx - 1].x + shiftX, points[idx - 1].y + shiftY);\n            }\n            // need to fix the wrong 1.5 factor of the last intermediate point\n            idx--;\n            if ((cascadeStartHorizontal && (idx % 2 !== 0)) || (!cascadeStartHorizontal && (idx % 2 === 0))) {\n                points[length - 2] = new Point(points[length - 1].x, points[length - 2].y);\n            }\n            else {\n                points[length - 2] = new Point(points[length - 2].x, points[length - 1].y);\n            }\n            return [points[1], points[2]];\n        }\n        _startHorizontal(start, end, sourceSide) {\n            let horizontal;\n            if (sourceSide !== null && (sourceSide === RIGHT || sourceSide === LEFT)) {\n                horizontal = true;\n            }\n            else {\n                horizontal = Math.abs(start.x - end.x) > Math.abs(start.y - end.y);\n            }\n            return horizontal;\n        }\n    }\n\n    /**\n     * A simple poly-linear routing which does not alter the intermediate points.\n     * Does hold the underlying hit, bounds....logic.\n     *\n     * @type {*|Object|void|extend|Zepto.extend|b.extend}\n     */\n    class PolylineRouter extends LinearConnectionRouter {\n        constructor(connection) {\n            super(connection);\n            this.connection = connection;\n        }\n        route() {\n            // just keep the points as is\n        }\n    }\n\n    class ConnectionEditTool {\n        constructor(toolService) {\n            this.toolService = toolService;\n            this.type = 'ConnectionTool';\n        }\n        tryActivate(_p, meta) {\n            const toolService = this.toolService, diagram = toolService.diagram, selectable = diagram.options.selectable, item = toolService.hoveredItem, isActive = selectable !== false &&\n                item && item.path && !(item.isSelected && meta.ctrlKey);\n            if (isActive) {\n                this._c = item;\n            }\n            return isActive;\n        }\n        start(point, meta, nativeEvent) {\n            const toolService = this.toolService;\n            const connection = this._c;\n            toolService.selectSingle(connection, meta);\n            const adorner = connection.adorner;\n            let handle, name;\n            if (adorner) {\n                handle = adorner._hitTest(point);\n                name = HANDLE_NAMES[handle];\n            }\n            if (canDrag(connection) && adorner && !toolService.diagram.trigger(DRAG_START, { shapes: [], connections: [connection], connectionHandle: name, point, meta, nativeEvent })) {\n                this.handle = handle;\n                this.handleName = name;\n                adorner.start(point);\n            }\n            else {\n                toolService.startPoint = point;\n                toolService.end(point, meta, nativeEvent);\n            }\n        }\n        move(point, meta, nativeEvent) {\n            const adorner = this._c.adorner;\n            if (canDrag(this._c) && adorner) {\n                adorner.move(this.handle, point);\n                this.toolService.diagram.trigger(DRAG, { shapes: [], connections: [this._c], connectionHandle: this.handleName, point, meta, nativeEvent });\n                return true;\n            }\n        }\n        end(point, meta, nativeEvent) {\n            const connection = this._c;\n            const adorner = connection.adorner;\n            const toolService = this.toolService;\n            const diagram = toolService.diagram;\n            if (adorner) {\n                if (canDrag(connection)) {\n                    const unit = adorner.stop(point);\n                    if (!diagram.trigger(DRAG_END, { shapes: [], connections: [connection], connectionHandle: this.handleName, point, meta, nativeEvent })) {\n                        diagram.undoRedoService.add(unit, false);\n                        connection.updateModel();\n                        diagram._syncConnectionChanges();\n                    }\n                    else {\n                        unit.undo();\n                    }\n                }\n            }\n        }\n        getCursor() {\n            return Cursors.move;\n        }\n    }\n\n    class ConnectionTool {\n        constructor(toolService) {\n            this.toolService = toolService;\n            this.type = 'ConnectionTool';\n        }\n        tryActivate() {\n            return this.toolService._hoveredConnector;\n        }\n        start(point, meta, nativeEvent) {\n            const toolService = this.toolService, diagram = toolService.diagram, connector = toolService._hoveredConnector, connection = diagram._createConnection({}, connector._c, point);\n            if (canDrag(connection) && !diagram.trigger(DRAG_START, { shapes: [], connections: [connection], connectionHandle: TARGET, point, meta, nativeEvent }) && diagram._addConnection(connection)) {\n                toolService._connectionManipulation(connection, connector._c.shape, true);\n                toolService._removeHover();\n                toolService.selectSingle(toolService.activeConnection, meta);\n                if (meta.type === 'touchmove') {\n                    diagram._cachedTouchTarget = connector.visual;\n                }\n            }\n            else {\n                connection.source(null);\n                toolService.end(point, meta, nativeEvent);\n            }\n        }\n        move(point, meta, nativeEvent) {\n            const toolService = this.toolService;\n            const connection = toolService.activeConnection;\n            connection.target(point);\n            toolService.diagram.trigger(DRAG, { shapes: [], connections: [connection], connectionHandle: TARGET, point, meta, nativeEvent });\n            return true;\n        }\n        end(point, meta, nativeEvent) {\n            const toolService = this.toolService, diagram = toolService.diagram, connection = toolService.activeConnection, hoveredItem = toolService.hoveredItem, connector = toolService._hoveredConnector, cachedTouchTarget = diagram._cachedTouchTarget;\n            let target;\n            if (!connection) {\n                return;\n            }\n            if (connector && connector._c !== connection.sourceConnector) {\n                target = connector._c;\n            }\n            else if (hoveredItem && hoveredItem instanceof Shape) {\n                target = hoveredItem.getConnector(AUTO) || hoveredItem.getConnector(point);\n            }\n            else {\n                target = point;\n            }\n            connection.target(target);\n            if (!diagram.trigger(DRAG_END, { shapes: [], connections: [connection], connectionHandle: TARGET, point, meta, nativeEvent })) {\n                connection.updateModel();\n                diagram._syncConnectionChanges();\n            }\n            else {\n                diagram.remove(connection, false);\n                diagram.undoRedoService.pop();\n            }\n            toolService._connectionManipulation();\n            if (cachedTouchTarget) {\n                diagram._connectorsAdorner.visual.remove(cachedTouchTarget);\n                diagram._cachedTouchTarget = null;\n            }\n        }\n        getCursor() {\n            return Cursors.arrow;\n        }\n    }\n\n    class EmptyTool {\n        constructor(toolService) {\n            this.toolService = toolService;\n        }\n        start() {\n        }\n        move() {\n        }\n        end() {\n        }\n        tryActivate() {\n            return false;\n        }\n        getCursor() {\n            return Cursors.arrow;\n        }\n    }\n\n    function noMeta(meta) {\n        return meta.ctrlKey === false && meta.altKey === false && meta.shiftKey === false;\n    }\n\n    /**\n     * The tool handling the transformations via the adorner.\n     *\n     * @type {*}\n     */\n    class PointerTool {\n        constructor(toolService) {\n            this.toolService = toolService;\n        }\n        tryActivate() {\n            return true; // the pointer tool is last and handles all others requests.\n        }\n        start(point, meta, nativeEvent) {\n            const toolService = this.toolService, diagram = toolService.diagram, hoveredItem = toolService.hoveredItem;\n            if (hoveredItem) {\n                toolService.selectSingle(hoveredItem, meta);\n                if (hoveredItem.adorner) { // connection\n                    this.adorner = hoveredItem.adorner;\n                    this.handle = this.adorner._hitTest(point);\n                }\n            }\n            if (!this.handle) {\n                this.handle = diagram._resizingAdorner._hitTest(point);\n                if (this.handle) {\n                    this.adorner = diagram._resizingAdorner;\n                }\n            }\n            if (this.adorner) {\n                if (!this.adorner.isDragHandle(this.handle) || !diagram.trigger(DRAG_START, { shapes: this.adorner.shapes, connections: [], point, nativeEvent, meta })) {\n                    this.adorner.start(point);\n                }\n                else {\n                    toolService.startPoint = point;\n                    toolService.end(point, meta, nativeEvent);\n                }\n            }\n        }\n        move(point, meta, nativeEvent) {\n            if (this.adorner) {\n                this.adorner.move(this.handle, point);\n                if (this.adorner.isDragHandle(this.handle)) {\n                    this.toolService.diagram.trigger(DRAG, { shapes: this.adorner.shapes, connections: [], point, meta, nativeEvent });\n                }\n            }\n        }\n        end(point, meta, nativeEvent) {\n            const diagram = this.toolService.diagram, adorner = this.adorner;\n            let unit;\n            if (adorner) {\n                if (!adorner.isDragHandle(this.handle) || !diagram.trigger(DRAG_END, { shapes: adorner.shapes, connections: [], point, meta, nativeEvent })) {\n                    unit = adorner.stop();\n                    if (unit) {\n                        diagram.undoRedoService.add(unit, false);\n                    }\n                }\n                else {\n                    adorner.cancel();\n                }\n            }\n            this.adorner = undefined;\n            this.handle = undefined;\n        }\n        getCursor(p) {\n            return this.toolService.hoveredItem ? this.toolService.hoveredItem._getCursor(p) : Cursors.arrow;\n        }\n    }\n\n    const eventMap = {\n        down: 'pointerdown',\n        move: 'pointermove',\n        up: 'pointerup',\n        cancel: 'pointercancel pointerleave'\n    };\n    function queryEventMap(e) {\n        return eventMap[e] || e;\n    }\n    const applyEventMap = (events) => {\n        const eventRegEx = /([^ ]+)/g;\n        const appliedEvents = events.replace(eventRegEx, queryEventMap);\n        return appliedEvents;\n    };\n\n    const elementOffset$1 = kendo_drawing_cmn_chunk_js.x;\n    const translate = function (x, y, scale) {\n        return 'translate3d(' + x + 'px,' + y + 'px,0) scale(' + scale + ')';\n    };\n    class TapCapture extends Observable {\n        constructor(element, options) {\n            super();\n            const domElement = element[0] || element;\n            this.element = domElement;\n            this.capture = false;\n            this._pressHandler = this._press.bind(this);\n            this._releaseHandler = this._release.bind(this);\n            eventMap.down.split(' ').forEach((event) => {\n                domElement.addEventListener(event, this._pressHandler, true);\n            });\n            eventMap.up.split(' ').forEach((event) => {\n                domElement.addEventListener(event, this._releaseHandler, true);\n            });\n            this.bind([\n                'press',\n                'release'\n            ], options || {});\n        }\n        captureNext() {\n            this.capture = true;\n        }\n        cancelCapture() {\n            this.capture = false;\n        }\n        _press(e) {\n            this.trigger('press');\n            if (this.capture) {\n                e.preventDefault();\n            }\n        }\n        _release(e) {\n            this.trigger('release');\n            if (this.capture) {\n                e.preventDefault();\n                this.cancelCapture();\n            }\n        }\n        destroy() {\n            const domElement = this.element;\n            eventMap.down.split(' ').forEach((event) => {\n                domElement.removeEventListener(event, this._pressHandler, true);\n            });\n            eventMap.up.split(' ').forEach((event) => {\n                domElement.removeEventListener(event, this._releaseHandler, true);\n            });\n        }\n    }\n    class PaneDimension extends Observable {\n        constructor(options) {\n            super();\n            this.forcedEnabled = false;\n            extend$1(this, options);\n            this.scale = 1;\n            if (this.horizontal) {\n                this.measure = 'offsetWidth';\n                this.scrollSize = 'scrollWidth';\n                this.axis = 'x';\n            }\n            else {\n                this.measure = 'offsetHeight';\n                this.scrollSize = 'scrollHeight';\n                this.axis = 'y';\n            }\n        }\n        makeVirtual() {\n            extend$1(this, {\n                virtual: true,\n                forcedEnabled: true,\n                _virtualMin: 0,\n                _virtualMax: 0\n            });\n        }\n        virtualSize(min, max) {\n            if (this._virtualMin !== min || this._virtualMax !== max) {\n                this._virtualMin = min;\n                this._virtualMax = max;\n                this.update();\n            }\n        }\n        outOfBounds(offset) {\n            return offset > this.max || offset < this.min;\n        }\n        forceEnabled() {\n            this.forcedEnabled = true;\n        }\n        getSize() {\n            return this.container[this.measure];\n        }\n        getTotal() {\n            return this.element[this.scrollSize];\n        }\n        rescale(scale) {\n            this.scale = scale;\n        }\n        update(silent) {\n            const total = this.virtual ? this._virtualMax : this.getTotal(), scaledTotal = total * this.scale, size = this.getSize();\n            if (total === 0 && !this.forcedEnabled) {\n                return;\n            }\n            this.max = this.virtual ? -this._virtualMin : 0;\n            this.size = size;\n            this.total = scaledTotal;\n            this.min = Math.min(this.max, size - scaledTotal);\n            this.minScale = size / total;\n            this.centerOffset = (scaledTotal - size) / 2;\n            this.enabled = this.forcedEnabled || scaledTotal > size;\n            if (!silent) {\n                this.trigger(CHANGE$1, this);\n            }\n        }\n    }\n    class PaneDimensions extends Observable {\n        constructor(options) {\n            super();\n            this.x = new PaneDimension(extend$1({\n                horizontal: true\n            }, options));\n            this.y = new PaneDimension(extend$1({\n                horizontal: false\n            }, options));\n            this.container = options.container;\n            this.forcedMinScale = options.minScale;\n            this.maxScale = options.maxScale || 100;\n            this.bind(CHANGE$1, options);\n        }\n        rescale(newScale) {\n            this.x.rescale(newScale);\n            this.y.rescale(newScale);\n            this.refresh();\n        }\n        centerCoordinates() {\n            return {\n                x: Math.min(0, -this.x.centerOffset),\n                y: Math.min(0, -this.y.centerOffset)\n            };\n        }\n        refresh() {\n            this.x.update();\n            this.y.update();\n            this.enabled = this.x.enabled || this.y.enabled;\n            this.minScale = this.forcedMinScale || Math.min(this.x.minScale, this.y.minScale);\n            this.fitScale = Math.max(this.x.minScale, this.y.minScale);\n            this.trigger(CHANGE$1);\n        }\n    }\n    class PaneAxis extends Observable {\n        constructor(options) {\n            super();\n            extend$1(this, options);\n        }\n        outOfBounds() {\n            return this.dimension.outOfBounds(this.movable[this.axis]);\n        }\n        dragMove(delta) {\n            const dimension = this.dimension, axis = this.axis, movable = this.movable, position = movable[axis] + delta;\n            if (!dimension.enabled) {\n                return;\n            }\n            let dragDelta = delta;\n            if (position < dimension.min && delta < 0 || position > dimension.max && delta > 0) {\n                dragDelta *= this.resistance;\n            }\n            movable.translateAxis(axis, dragDelta);\n            this.trigger(CHANGE$1, this);\n        }\n    }\n    class Pane {\n        constructor(options) {\n            let x, y;\n            extend$1(this, {\n                elastic: true\n            }, options);\n            const resistance = this.elastic ? 0.5 : 0;\n            const movable = this.movable;\n            this.x = x = new PaneAxis({\n                axis: 'x',\n                dimension: this.dimensions.x,\n                resistance: resistance,\n                movable: movable\n            });\n            this.y = y = new PaneAxis({\n                axis: 'y',\n                dimension: this.dimensions.y,\n                resistance: resistance,\n                movable: movable\n            });\n            this.userEvents.bind([\n                'press',\n                'move',\n                'end',\n                'gesturestart',\n                'gesturechange'\n            ], {\n                gesturestart(e) {\n                    this.gesture = e;\n                    this.offset = elementOffset$1(this.dimensions.container);\n                },\n                press(e) {\n                    const closestAnchor = e.event.target.closest('a');\n                    if (closestAnchor && closestAnchor.matches('[data-navigate-on-press=true]')) {\n                        e.sender.cancel();\n                    }\n                },\n                gesturechange(e) {\n                    const previousGesture = this.gesture, previousCenter = previousGesture.center, center = e.center, minScale = this.dimensions.minScale, maxScale = this.dimensions.maxScale;\n                    let scaleDelta = e.distance / previousGesture.distance;\n                    if (movable.scale <= minScale && scaleDelta < 1) {\n                        scaleDelta += (1 - scaleDelta) * 0.8;\n                    }\n                    if (movable.scale * scaleDelta >= maxScale) {\n                        scaleDelta = maxScale / movable.scale;\n                    }\n                    const offsetX = movable.x + this.offset.left, offsetY = movable.y + this.offset.top;\n                    const coordinates = {\n                        x: (offsetX - previousCenter.x) * scaleDelta + center.x - offsetX,\n                        y: (offsetY - previousCenter.y) * scaleDelta + center.y - offsetY\n                    };\n                    movable.scaleWith(scaleDelta);\n                    x.dragMove(coordinates.x);\n                    y.dragMove(coordinates.y);\n                    this.dimensions.rescale(movable.scale);\n                    this.gesture = e;\n                    e.preventDefault();\n                },\n                move(e) {\n                    if (e.event.target.tagName.match(/textarea|input/i)) {\n                        return;\n                    }\n                    if (x.dimension.enabled || y.dimension.enabled) {\n                        x.dragMove(e.x.delta);\n                        y.dragMove(e.y.delta);\n                        e.preventDefault();\n                    }\n                    else {\n                        e.touch.skip();\n                    }\n                },\n                end(e) {\n                    e.preventDefault();\n                }\n            });\n        }\n    }\n    class Movable extends Observable {\n        constructor(element) {\n            super();\n            this.element = element;\n            this.element.style.transformOrigin = 'left top';\n            this.x = 0;\n            this.y = 0;\n            this.scale = 1;\n            const coordinates = translate(this.x, this.y, this.scale);\n            this.element.style.transform = coordinates;\n            this._saveCoordinates(coordinates);\n        }\n        translateAxis(axis, by) {\n            this[axis] += by;\n            this.refresh();\n        }\n        scaleTo(scale) {\n            this.scale = scale;\n            this.refresh();\n        }\n        scaleWith(scaleDelta) {\n            this.scale *= scaleDelta;\n            this.refresh();\n        }\n        translate(coordinates) {\n            this.x += coordinates.x;\n            this.y += coordinates.y;\n            this.refresh();\n        }\n        moveAxis(axis, value) {\n            this[axis] = value;\n            this.refresh();\n        }\n        moveTo(coordinates) {\n            extend$1(this, coordinates);\n            this.refresh();\n        }\n        refresh() {\n            let x = this.x, y = this.y;\n            if (this.round) {\n                x = Math.round(x);\n                y = Math.round(y);\n            }\n            const newCoordinates = translate(x, y, this.scale);\n            if (newCoordinates !== this.coordinates) {\n                this.element.style.transform = newCoordinates;\n                this._saveCoordinates(newCoordinates);\n                this.trigger(CHANGE$1);\n            }\n        }\n        _saveCoordinates(coordinates) {\n            this.coordinates = coordinates;\n        }\n    }\n\n    function animationFrame(callback) {\n        window.requestAnimationFrame(callback);\n    }\n    class Animation {\n        constructor() {\n            this._tickProxy = () => this._tick();\n            this._started = false;\n        }\n        tick() { }\n        done() { return false; }\n        onEnd() { }\n        onCancel() { }\n        start() {\n            if (!this.enabled()) {\n                return;\n            }\n            if (!this.done()) {\n                this._started = true;\n                animationFrame(this._tickProxy);\n            }\n            else {\n                this.onEnd();\n            }\n        }\n        enabled() {\n            return true;\n        }\n        cancel() {\n            this._started = false;\n            this.onCancel();\n        }\n        _tick() {\n            if (!this._started) {\n                return;\n            }\n            this.tick();\n            if (!this.done()) {\n                animationFrame(this._tickProxy);\n            }\n            else {\n                this._started = false;\n                this.onEnd();\n            }\n        }\n    }\n    class Transition extends Animation {\n        constructor(options) {\n            super();\n            extend$1(this, options);\n        }\n        done() {\n            return this.timePassed() >= this.duration;\n        }\n        timePassed() {\n            return Math.min(this.duration, now() - this.startDate);\n        }\n        moveTo(options) {\n            const movable = this.movable;\n            this.initial = movable[this.axis];\n            this.delta = options.location - this.initial;\n            this.duration = typeof options.duration === 'number' ? options.duration : 300;\n            this.tick = this._easeProxy(options.ease);\n            this.startDate = now();\n            this.start();\n        }\n        _easeProxy(ease) {\n            return function () {\n                this.movable.moveAxis(this.axis, ease(this.timePassed(), this.initial, this.delta, this.duration));\n            };\n        }\n        static easeOutExpo(t, b, c, d) {\n            return t === d ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;\n        }\n    }\n\n    function guid() {\n        let id = '';\n        let i;\n        let random;\n        for (i = 0; i < 32; i++) {\n            random = Math.floor(Math.random() * 16);\n            if (i === 8 || i === 12 || i === 16 || i === 20) {\n                id += '-';\n            }\n            id += (i === 12 ? 4 : (i === 16 ? ((random % 4) + 8) : random)).toString(16);\n        }\n        return id;\n    }\n\n    const elementEventHandlers = new WeakMap();\n    const ID = Symbol('id');\n    function on(element, events, filter, handler, useCapture) {\n        addEventListeners(element, events, filter, handler, useCapture);\n    }\n    function off(element, events, handler, useCapture) {\n        removeEventListeners(element, events, handler, useCapture);\n    }\n    function isString(value) {\n        return typeof (value) === 'string';\n    }\n    function addEventListeners(element, events, filter, handler, useCapture) {\n        const eventNames = Array.isArray(events) ? events : (events || '').split(' ');\n        eventNames.forEach(function (eventName) {\n            addEventListener(element, eventName, filter, handler, useCapture);\n        });\n    }\n    function addEventListener(element, event, filter, handler, useCapture) {\n        let eventHandler = handler;\n        let eventFilter;\n        if (filter && isFunction$1(filter) && !handler) {\n            eventHandler = filter;\n        }\n        else if (filter && isString(filter) && isFunction$1(eventHandler)) {\n            eventFilter = filter;\n        }\n        const attachedHandler = function (e) {\n            const closestMatchingTarget = e.target ? e.target.closest(eventFilter) : null;\n            if (!eventFilter ||\n                (eventFilter && e.target && closestMatchingTarget)) {\n                const currentTarget = eventFilter ? closestMatchingTarget : e.currentTarget;\n                // reassign the property as it is a getters only\n                Object.defineProperty(e, 'currentTarget', { value: currentTarget });\n                // keep a reference to the top-level target\n                Object.defineProperty(e, 'delegateTarget', { value: element });\n                eventHandler(e);\n            }\n        };\n        if (!eventHandler[ID]) {\n            eventHandler[ID] = guid();\n        }\n        let eventHandlers = elementEventHandlers.get(element);\n        if (!eventHandlers) {\n            eventHandlers = new Map();\n            elementEventHandlers.set(element, eventHandlers);\n        }\n        eventHandlers.set(event + eventHandler[ID], attachedHandler);\n        element.addEventListener(event, attachedHandler, Boolean(useCapture));\n    }\n    function removeEventListeners(element, events, handler, useCapture) {\n        const eventNames = Array.isArray(events) ? events : (events || '').split(' ');\n        eventNames.forEach(function (eventName) {\n            removeEventListener(element, eventName, handler, useCapture);\n        });\n    }\n    function removeEventListener(element, event, handler, useCapture) {\n        const eventHandlers = elementEventHandlers.get(element);\n        if (eventHandlers && handler && handler[ID]) {\n            const handlerId = event + handler[ID];\n            const attachedHandler = eventHandlers.get(handlerId);\n            eventHandlers.delete(handlerId);\n            if (attachedHandler) {\n                element.removeEventListener(event, attachedHandler, Boolean(useCapture));\n            }\n        }\n    }\n\n    function grep(array, callback) {\n        const length = array.length;\n        const result = [];\n        for (let idx = 0; idx < length; idx++) {\n            if (callback(array[idx])) {\n                result.push(array[idx]);\n            }\n        }\n        return result;\n    }\n\n    const preventDefault$1 = (e) => {\n        e.preventDefault();\n    };\n    const noop = () => { };\n    const CLICK_DELAY = 300, PRESS = 'press', HOLD = 'hold', SELECT = 'select', START = 'start', MOVE = 'move', END = 'end', CANCEL = 'cancel', TAP = 'tap', DOUBLETAP = 'doubleTap', RELEASE = 'release', GESTURESTART = 'gesturestart', GESTURECHANGE = 'gesturechange', GESTUREEND = 'gestureend', GESTURETAP = 'gesturetap';\n    const THRESHOLD = {\n        'api': 0,\n        'touch': 0,\n        'mouse': 9,\n        'pointer': 9\n    };\n    let DEFAULT_MIN_HOLD = 800, DEFAULT_THRESHOLD = 0;\n    function touchDelta(touch1, touch2) {\n        const x1 = touch1.x.location, y1 = touch1.y.location, x2 = touch2.x.location, y2 = touch2.y.location, dx = x1 - x2, dy = y1 - y2;\n        return {\n            center: {\n                x: (x1 + x2) / 2,\n                y: (y1 + y2) / 2\n            },\n            distance: Math.sqrt(dx * dx + dy * dy)\n        };\n    }\n    function getTouches(e) {\n        const touches = [], originalEvent = e.originalEvent || e, currentTarget = e.currentTarget;\n        if (e.api) {\n            touches.push({\n                id: 2, // hardcoded ID for API call\n                event: e,\n                target: e.target,\n                currentTarget: e.target,\n                location: e,\n                type: 'api'\n            });\n        }\n        else {\n            touches.push({\n                location: originalEvent,\n                event: e,\n                target: e.target,\n                currentTarget: currentTarget,\n                id: originalEvent.pointerId,\n                type: 'pointer'\n            });\n        }\n        return touches;\n    }\n    class TouchAxis {\n        constructor(axis, location) {\n            this.support = getSupportedFeatures();\n            this.invalidZeroEvents = this.support.mobileOS && this.support.mobileOS.android;\n            this.axis = axis;\n            this._updateLocationData(location);\n            this.startLocation = this.location;\n            this.velocity = this.delta = 0;\n            this.timeStamp = now();\n        }\n        move(location) {\n            const offset = location['page' + this.axis], timeStamp = now(), timeDelta = timeStamp - this.timeStamp || 1;\n            if (!offset && this.invalidZeroEvents) {\n                return;\n            }\n            this.delta = offset - this.location;\n            this._updateLocationData(location);\n            this.initialDelta = offset - this.startLocation;\n            this.velocity = this.delta / timeDelta;\n            this.timeStamp = timeStamp;\n        }\n        _updateLocationData(location) {\n            const axis = this.axis;\n            this.location = location['page' + axis];\n            this.client = location['client' + axis];\n            this.screen = location['screen' + axis];\n        }\n    }\n    class Touch {\n        constructor(userEvents, target, touchInfo) {\n            extend$1(this, {\n                x: new TouchAxis('X', touchInfo.location),\n                y: new TouchAxis('Y', touchInfo.location),\n                type: touchInfo.type,\n                threshold: userEvents.threshold || THRESHOLD[touchInfo.type],\n                userEvents: userEvents,\n                target: target,\n                currentTarget: touchInfo.currentTarget,\n                initialTouch: touchInfo.target,\n                id: touchInfo.id,\n                pressEvent: touchInfo,\n                _clicks: userEvents._clicks,\n                supportDoubleTap: userEvents.supportDoubleTap,\n                _moved: false,\n                _finished: false\n            });\n        }\n        press() {\n            this._holdTimeout = setTimeout(() => this._hold(), this.userEvents.minHold);\n            this._trigger(PRESS, this.pressEvent);\n        }\n        _tap(touchInfo) {\n            this.userEvents._clicks++;\n            if (this.userEvents._clicks === 1) {\n                this._clickTimeout = setTimeout(() => {\n                    if (this.userEvents._clicks === 1) {\n                        this._trigger(TAP, touchInfo);\n                    }\n                    else {\n                        this._trigger(DOUBLETAP, touchInfo);\n                    }\n                    this.userEvents._clicks = 0;\n                }, CLICK_DELAY);\n            }\n        }\n        _hold() {\n            this._trigger(HOLD, this.pressEvent);\n        }\n        move(touchInfo) {\n            const preventMove = touchInfo.type !== 'api' && this.userEvents._shouldNotMove;\n            if (this._finished || preventMove) {\n                return;\n            }\n            this.x.move(touchInfo.location);\n            this.y.move(touchInfo.location);\n            if (!this._moved) {\n                if (this._withinIgnoreThreshold()) {\n                    return;\n                }\n                if (!UserEvents.current || UserEvents.current === this.userEvents) {\n                    this._start(touchInfo);\n                }\n                else {\n                    return this.dispose();\n                }\n            }\n            if (!this._finished) {\n                this._trigger(MOVE, touchInfo);\n            }\n        }\n        end(touchInfo) {\n            this.endTime = now();\n            if (this._finished) {\n                return;\n            }\n            this._finished = true;\n            this._trigger(RELEASE, touchInfo);\n            if (this._moved) {\n                this._trigger(END, touchInfo);\n            }\n            else {\n                if (this.supportDoubleTap) {\n                    this._tap(touchInfo);\n                }\n                else {\n                    this._trigger(TAP, touchInfo);\n                }\n            }\n            clearTimeout(this._holdTimeout);\n            this.dispose();\n        }\n        dispose() {\n            const userEvents = this.userEvents, activeTouches = userEvents.touches || [];\n            this._finished = true;\n            this.pressEvent = null;\n            clearTimeout(this._holdTimeout);\n            // activeTouches.splice($.inArray(this, activeTouches), 1);\n            const activeTouchIndex = activeTouches.indexOf(this);\n            activeTouches.splice(activeTouchIndex, 1);\n        }\n        skip() {\n            this.dispose();\n        }\n        cancel() {\n            this.dispose();\n        }\n        isMoved() {\n            return this._moved;\n        }\n        _start(touchInfo) {\n            clearTimeout(this._holdTimeout);\n            this.startTime = now();\n            this._moved = true;\n            this._trigger(START, touchInfo);\n        }\n        _trigger(name, touchInfo) {\n            const e = touchInfo.event;\n            const data = {\n                touch: this,\n                x: this.x,\n                y: this.y,\n                target: this.target,\n                event: e\n            };\n            if (this.userEvents.notify(name, data)) {\n                e.preventDefault();\n            }\n        }\n        _withinIgnoreThreshold() {\n            const xDelta = this.x.initialDelta, yDelta = this.y.initialDelta;\n            return Math.sqrt(xDelta * xDelta + yDelta * yDelta) <= this.threshold;\n        }\n    }\n    function withEachUpEvent(callback) {\n        const downEvents = eventMap.up.split(' '), length = downEvents.length;\n        for (let idx = 0; idx < length; idx++) {\n            callback(downEvents[idx]);\n        }\n    }\n    class UserEvents extends Observable {\n        constructor(element, options) {\n            super();\n            const support = getSupportedFeatures();\n            this.support = support;\n            options = options || {};\n            this.options = options;\n            const filter = this.filter = options.filter;\n            this.threshold = options.threshold || DEFAULT_THRESHOLD;\n            this.minHold = options.minHold || DEFAULT_MIN_HOLD;\n            this.touches = [];\n            this._maxTouches = options.multiTouch ? 2 : 1;\n            this.allowSelection = options.allowSelection;\n            this.captureUpIfMoved = options.captureUpIfMoved;\n            this._clicks = 0;\n            this.supportDoubleTap = options.supportDoubleTap;\n            extend$1(this, {\n                element: element,\n                surface: options.surface || element,\n                stopPropagation: options.stopPropagation,\n                pressed: false\n            });\n            this._surfaceMoveHandler = this._move.bind(this);\n            on(this.surface, applyEventMap('move'), this._surfaceMoveHandler);\n            this._surfaceEndHandler = this._end.bind(this);\n            on(this.surface, applyEventMap('up cancel'), this._surfaceEndHandler);\n            this._elementStartHandler = this._start.bind(this);\n            on(element, applyEventMap('down'), filter, this._elementStartHandler);\n            element.style['touch-action'] = options.touchAction || 'none';\n            if (options.preventDragEvent) {\n                this._elementDragStartHandler = preventDefault$1;\n                on(element, applyEventMap('dragstart'), this._elementDragStartHandler);\n            }\n            // element.on(kendo.applyEventMap('mousedown'), filter, {\n            //     root: element\n            // } '_select');\n            // todo: use root\n            this._elementSelectHandler = this._select.bind(this);\n            on(element, applyEventMap('mousedown'), filter, this._elementSelectHandler);\n            if (this.captureUpIfMoved) {\n                const surfaceElement = this.surface;\n                this.preventIfMovingProxy = this.preventIfMoving.bind(this);\n                withEachUpEvent((eventName) => {\n                    surfaceElement.addEventListener(eventName, this.preventIfMovingProxy, true);\n                });\n            }\n            this.bind([\n                PRESS,\n                HOLD,\n                TAP,\n                DOUBLETAP,\n                START,\n                MOVE,\n                END,\n                RELEASE,\n                CANCEL,\n                GESTURESTART,\n                GESTURECHANGE,\n                GESTUREEND,\n                GESTURETAP,\n                SELECT\n            ], options);\n        }\n        preventIfMoving(e) {\n            if (this._isMoved()) {\n                e.preventDefault();\n            }\n        }\n        destroy() {\n            const options = this.options;\n            const element = this.element;\n            if (this._destroyed) {\n                return;\n            }\n            this._destroyed = true;\n            if (this.captureUpIfMoved) {\n                const surfaceElement = this.surface;\n                withEachUpEvent((eventName) => {\n                    surfaceElement.removeEventListener(eventName, this.preventIfMovingProxy, true);\n                });\n            }\n            off(this.surface, applyEventMap('move'), this._surfaceMoveHandler);\n            off(this.surface, applyEventMap('up cancel'), this._surfaceEndHandler);\n            off(element, applyEventMap('down'), this._elementStartHandler);\n            if (options.preventDragEvent) {\n                off(element, applyEventMap('dragstart'), this._elementDragStartHandler);\n            }\n            off(element, applyEventMap('mousedown'), this._elementSelectHandler);\n            this._disposeAll();\n            this.unbind();\n            delete this.surface;\n            delete this.element;\n            delete this.currentTarget;\n        }\n        capture() {\n            UserEvents.current = this;\n        }\n        cancel() {\n            this._disposeAll();\n            this.trigger(CANCEL);\n        }\n        notify(event, data) {\n            const touches = this.touches;\n            let eventName = event;\n            if (this._isMultiTouch()) {\n                switch (eventName) {\n                    case MOVE:\n                        eventName = GESTURECHANGE;\n                        break;\n                    case END:\n                        eventName = GESTUREEND;\n                        break;\n                    case TAP:\n                        eventName = GESTURETAP;\n                        break;\n                    default:\n                        break;\n                }\n                extend$1(data, {\n                    touches: touches\n                }, touchDelta(touches[0], touches[1]));\n            }\n            return this.trigger(eventName, extend$1(data, {\n                type: eventName\n            }));\n        }\n        press(x, y, target) {\n            this._apiCall('_start', x, y, target);\n        }\n        move(x, y) {\n            this._apiCall('_move', x, y);\n        }\n        end(x, y) {\n            this._apiCall('_end', x, y);\n        }\n        _isMultiTouch() {\n            return this.touches.length > 1;\n        }\n        _maxTouchesReached() {\n            return this.touches.length >= this._maxTouches;\n        }\n        _disposeAll() {\n            const touches = this.touches;\n            while (touches.length > 0) {\n                touches.pop().dispose();\n            }\n        }\n        _isMoved() {\n            return grep(this.touches, function (touch) {\n                return touch.isMoved();\n            }).length;\n        }\n        _select(e) {\n            if (!this.allowSelection || this.trigger(SELECT, { event: e })) {\n                e.preventDefault();\n            }\n        }\n        _start(e) {\n            if (e.which && e.which > 1 || this._maxTouchesReached()) {\n                return;\n            }\n            UserEvents.current = null;\n            this.currentTarget = e.currentTarget;\n            if (this.stopPropagation) {\n                e.stopPropagation();\n            }\n            let target;\n            const eventTouches = getTouches(e);\n            for (let idx = 0; idx < eventTouches.length; idx++) {\n                if (this._maxTouchesReached()) {\n                    break;\n                }\n                const eventTouch = eventTouches[idx];\n                if (this.filter) {\n                    target = eventTouch.currentTarget;\n                }\n                else {\n                    target = this.element;\n                }\n                if (target && target.length === 0) {\n                    continue;\n                }\n                const touch = new Touch(this, target, eventTouch);\n                this.touches.push(touch);\n                touch.press();\n                if (this._isMultiTouch()) {\n                    this.notify('gesturestart', {});\n                }\n            }\n        }\n        _move(e) {\n            this._eachTouch('move', e);\n        }\n        _end(e) {\n            this._eachTouch('end', e);\n        }\n        _eachTouch(methodName, e) {\n            const dict = {}, touches = getTouches(e), activeTouches = this.touches;\n            let idx, touch, touchInfo, matchingTouch;\n            for (idx = 0; idx < activeTouches.length; idx++) {\n                touch = activeTouches[idx];\n                dict[touch.id] = touch;\n            }\n            for (idx = 0; idx < touches.length; idx++) {\n                touchInfo = touches[idx];\n                matchingTouch = dict[touchInfo.id];\n                if (matchingTouch) {\n                    const shouldCapture = methodName === 'move' && touchInfo.type === 'pointer' && !this.surface.hasPointerCapture(touchInfo.id);\n                    if (shouldCapture) {\n                        this.surface.setPointerCapture(touchInfo.id);\n                    }\n                    matchingTouch[methodName](touchInfo);\n                }\n            }\n        }\n        _apiCall(type, x, y, target) {\n            this[type]({\n                api: true,\n                pageX: x,\n                pageY: y,\n                clientX: x,\n                clientY: y,\n                target: target || this.element,\n                stopPropagation: noop,\n                preventDefault: noop\n            });\n        }\n        static defaultThreshold(value) {\n            DEFAULT_THRESHOLD = value;\n        }\n        static minHold(value) {\n            DEFAULT_MIN_HOLD = value;\n        }\n    }\n\n    const extend = Object.assign, abs = Math.abs, SNAPBACK_DURATION = 500, SCROLLBAR_OPACITY = 0.7, FRICTION = 0.96, VELOCITY_MULTIPLIER = 10, MAX_VELOCITY = 55, OUT_OF_BOUNDS_FRICTION = 0.5, ANIMATED_SCROLLER_PRECISION = 5, \n    // SCROLLER_RELEASE_CLASS = 'km-scroller-release',\n    // SCROLLER_REFRESH_CLASS = 'km-scroller-refresh',\n    PULL = 'pull', CHANGE = 'change', RESIZE = 'resize', SCROLL = 'scroll', MOUSE_WHEEL_ID = 2;\n    class ZoomSnapBack extends Animation {\n        constructor(options) {\n            super();\n            extend(this, options);\n            this.userEvents.bind('gestureend', this.start.bind(this));\n            this.tapCapture.bind('press', this.cancel.bind(this));\n        }\n        enabled() {\n            return this.movable.scale < this.dimensions.minScale;\n        }\n        done() {\n            return this.dimensions.minScale - this.movable.scale < 0.01;\n        }\n        tick() {\n            const movable = this.movable;\n            movable.scaleWith(1.1);\n            this.dimensions.rescale(movable.scale);\n        }\n        onEnd() {\n            const movable = this.movable;\n            movable.scaleTo(this.dimensions.minScale);\n            this.dimensions.rescale(movable.scale);\n        }\n    }\n    class DragInertia extends Animation {\n        constructor(options) {\n            super();\n            extend(this, options, {\n                transition: new Transition({\n                    axis: options.axis,\n                    movable: options.movable,\n                    onEnd: () => {\n                        this._end();\n                    }\n                })\n            });\n            this.tapCapture.bind('press', () => {\n                this.cancel();\n            });\n            this.userEvents.bind('end', () => this.start());\n            this.userEvents.bind('gestureend', () => this.start());\n            this.userEvents.bind('tap', () => this.onEnd());\n        }\n        onCancel() {\n            this.transition.cancel();\n        }\n        freeze(location) {\n            this.cancel();\n            this._moveTo(location);\n        }\n        onEnd() {\n            if (this.paneAxis.outOfBounds()) {\n                this._snapBack();\n            }\n            else {\n                this._end();\n            }\n        }\n        done() {\n            return abs(this.velocity) < 1;\n        }\n        start(e) {\n            let velocity;\n            if (!this.dimension.enabled) {\n                return;\n            }\n            if (this.paneAxis.outOfBounds()) {\n                if (this.transition._started) {\n                    this.transition.cancel();\n                    this.velocity = Math.min(e.touch[this.axis].velocity * this.velocityMultiplier, MAX_VELOCITY);\n                    super.start();\n                }\n                else {\n                    this._snapBack();\n                }\n            }\n            else {\n                velocity = e ? (e.touch.id === MOUSE_WHEEL_ID ? 0 : e.touch[this.axis].velocity) : 0;\n                this.velocity = Math.max(Math.min(velocity * this.velocityMultiplier, MAX_VELOCITY), -MAX_VELOCITY);\n                this.tapCapture.captureNext();\n                super.start();\n            }\n        }\n        tick() {\n            const dimension = this.dimension, friction = this.paneAxis.outOfBounds() ? OUT_OF_BOUNDS_FRICTION : this.friction, delta = this.velocity *= friction;\n            let location = this.movable[this.axis] + delta;\n            if (!this.elastic && dimension.outOfBounds(location)) {\n                location = Math.max(Math.min(location, dimension.max), dimension.min);\n                this.velocity = 0;\n            }\n            this.movable.moveAxis(this.axis, location);\n        }\n        _end() {\n            this.tapCapture.cancelCapture();\n            this.end();\n        }\n        end() { }\n        _snapBack() {\n            const dimension = this.dimension, snapBack = this.movable[this.axis] > dimension.max ? dimension.max : dimension.min;\n            this._moveTo(snapBack);\n        }\n        _moveTo(location) {\n            this.transition.moveTo({\n                location: location,\n                duration: SNAPBACK_DURATION,\n                ease: (...args) => {\n                    Transition.easeOutExpo.apply(null, args);\n                }\n            });\n        }\n    }\n    class AnimatedScroller extends Animation {\n        constructor(options) {\n            super();\n            extend(this, options, {\n                origin: {},\n                destination: {},\n                offset: {}\n            });\n        }\n        moveTo(_to) { }\n        tick() {\n            this._updateCoordinates();\n            this.moveTo(this.origin);\n        }\n        done() {\n            return abs(this.offset.y) < ANIMATED_SCROLLER_PRECISION && abs(this.offset.x) < ANIMATED_SCROLLER_PRECISION;\n        }\n        onEnd() {\n            this.moveTo(this.destination);\n            if (this.callback) {\n                this.callback.call();\n            }\n        }\n        setCoordinates(from, to) {\n            this.offset = {};\n            this.origin = from;\n            this.destination = to;\n        }\n        setCallback(callback) {\n            if (callback && isFunction$1(callback)) {\n                this.callback = callback;\n            }\n            else {\n                callback = undefined;\n            }\n        }\n        _updateCoordinates() {\n            this.offset = {\n                x: (this.destination.x - this.origin.x) / 4,\n                y: (this.destination.y - this.origin.y) / 4\n            };\n            this.origin = {\n                y: this.origin.y + this.offset.y,\n                x: this.origin.x + this.offset.x\n            };\n        }\n    }\n    class ScrollBar {\n        constructor(options) {\n            const horizontal = options.axis === 'x';\n            const orientation = (horizontal ? 'horizontal' : 'vertical');\n            const element = convertToHtml('<div class=\"km-touch-scrollbar km-' + orientation + '-scrollbar\" />');\n            extend(this, options, {\n                element: element,\n                elementSize: 0,\n                movable: new Movable(element),\n                scrollMovable: options.movable,\n                alwaysVisible: options.alwaysVisible,\n                size: horizontal ? 'width' : 'height'\n            });\n            this.scrollMovable.bind(CHANGE, this.refresh.bind(this));\n            this.container.appendChild(element);\n            if (options.alwaysVisible) {\n                this.show();\n            }\n        }\n        refresh() {\n            const axis = this.axis, dimension = this.dimension, paneSize = dimension.size, scrollMovable = this.scrollMovable, sizeRatio = paneSize / dimension.total;\n            let size = Math.round(paneSize * sizeRatio), position = Math.round(-scrollMovable[axis] * sizeRatio);\n            if (sizeRatio >= 1) {\n                this.element.style.display = 'none';\n            }\n            else {\n                this.element.style.display = '';\n            }\n            if (position + size > paneSize) {\n                size = paneSize - position;\n            }\n            else if (position < 0) {\n                size += position;\n                position = 0;\n            }\n            if (this.elementSize !== size) {\n                this.element.style[this.size] = size + 'px';\n                this.elementSize = size;\n            }\n            this.movable.moveAxis(axis, position);\n        }\n        show() {\n            this.element.style.opacity = SCROLLBAR_OPACITY;\n            this.element.style.visibility = 'visible';\n        }\n        hide() {\n            if (!this.alwaysVisible) {\n                this.element.style.opacity = 0;\n            }\n        }\n    }\n    const defaultScrollerOptions = {\n        name: 'Scroller',\n        zoom: false,\n        pullOffset: 140,\n        visibleScrollHints: false,\n        elastic: true,\n        useNative: false,\n        mousewheelScrolling: true,\n        avoidScrolling: () => false,\n        pullToRefresh: false,\n        messages: {\n            pullTemplate: 'Pull to refresh',\n            releaseTemplate: 'Release to refresh',\n            refreshTemplate: 'Refreshing'\n        }\n    };\n    // export class Scroller extends Class {\n    class Scroller extends Observable {\n        constructor(element, options) {\n            super();\n            this.element = element = element[0] || element;\n            this._initOptions(options);\n            this.events.push(PULL, SCROLL, RESIZE);\n            const hasScrolling = hasNativeScrolling();\n            this._native = this.options.useNative && hasScrolling;\n            const scrollHeader = convertToHtml('<div class=\"km-scroll-header\"/>');\n            if (this._native) {\n                addClass(element, 'km-native-scroller');\n                prepend(scrollHeader, element);\n                extend(this, {\n                    scrollElement: element,\n                    fixedContainer: element.children[0]\n                });\n                return;\n            }\n            element.style.overflow = 'hidden';\n            addClass(element, 'km-scroll-wrapper');\n            const scrollContainer = convertToHtml('<div class=\"km-scroll-container\"/>');\n            wrapInner(element, scrollContainer);\n            prepend(scrollHeader, element);\n            const inner = element.children[1], tapCapture = new TapCapture(element), movable = new Movable(inner), dimensions = new PaneDimensions({\n                element: inner,\n                container: element,\n                forcedEnabled: this.options.zoom\n            }), avoidScrolling = this.options.avoidScrolling, userEvents = new UserEvents(element, {\n                touchAction: 'none',\n                allowSelection: true,\n                preventDragEvent: true,\n                captureUpIfMoved: true,\n                multiTouch: this.options.zoom,\n                supportDoubleTap: this.options.supportDoubleTap,\n                start: (e) => {\n                    dimensions.refresh();\n                    const velocityX = abs(e.x.velocity), velocityY = abs(e.y.velocity), horizontalSwipe = velocityX * 2 >= velocityY, originatedFromFixedContainer = this.fixedContainer.contains(e.event.target), verticalSwipe = velocityY * 2 >= velocityX;\n                    if (!originatedFromFixedContainer && !avoidScrolling(e) && this.enabled && (dimensions.x.enabled && horizontalSwipe || dimensions.y.enabled && verticalSwipe)) {\n                        userEvents.capture();\n                    }\n                    else {\n                        userEvents.cancel();\n                    }\n                }\n            }), pane = new Pane({\n                movable: movable,\n                dimensions: dimensions,\n                userEvents: userEvents,\n                elastic: this.options.elastic\n            }), zoomSnapBack = new ZoomSnapBack({\n                movable: movable,\n                dimensions: dimensions,\n                userEvents: userEvents,\n                tapCapture: tapCapture\n            }), animatedScroller = new AnimatedScroller({\n                moveTo: (coordinates) => {\n                    this.scrollTo(coordinates.x, coordinates.y);\n                }\n            });\n            movable.bind(CHANGE, () => {\n                this.scrollTop = -movable.y;\n                this.scrollLeft = -movable.x;\n                this.trigger(SCROLL, {\n                    scrollTop: this.scrollTop,\n                    scrollLeft: this.scrollLeft\n                });\n            });\n            if (this.options.mousewheelScrolling) {\n                this._wheelScrollHandler = this._wheelScroll.bind(this);\n                on(element, 'wheel', this._wheelScrollHandler);\n            }\n            extend(this, {\n                movable: movable,\n                dimensions: dimensions,\n                zoomSnapBack: zoomSnapBack,\n                animatedScroller: animatedScroller,\n                userEvents: userEvents,\n                pane: pane,\n                tapCapture: tapCapture,\n                pulled: false,\n                enabled: true,\n                scrollElement: inner,\n                scrollTop: 0,\n                scrollLeft: 0,\n                fixedContainer: element.children[0]\n            });\n            this._initAxis('x');\n            this._initAxis('y');\n            this._wheelEnd = () => {\n                this._wheel = false;\n                this.userEvents.end(0, this._wheelY);\n            };\n            dimensions.refresh();\n            if (this.options.pullToRefresh) {\n                this._initPullToRefresh();\n            }\n            this.bind(this.events, this.options);\n        }\n        _initOptions(options) {\n            this.options = deepExtend({}, this.options, defaultScrollerOptions, options);\n        }\n        _wheelScroll(e) {\n            if (e.ctrlKey) {\n                return;\n            }\n            if (!this._wheel) {\n                this._wheel = true;\n                this._wheelY = 0;\n                this.userEvents.press(0, this._wheelY);\n            }\n            clearTimeout(this._wheelTimeout);\n            this._wheelTimeout = setTimeout(() => this._wheelEnd(), 50);\n            const delta = wheelDeltaY(e);\n            if (delta) {\n                this._wheelY += delta;\n                this.userEvents.move(0, this._wheelY);\n            }\n            e.preventDefault();\n        }\n        makeVirtual() {\n            this.dimensions.y.makeVirtual();\n        }\n        virtualSize(min, max) {\n            this.dimensions.y.virtualSize(min, max);\n        }\n        height() {\n            return this.dimensions.y.size;\n        }\n        scrollHeight() {\n            return this.scrollElement.scrollHeight;\n        }\n        scrollWidth() {\n            return this.scrollElement.scrollWidth;\n        }\n        _resize() {\n            if (!this._native) {\n                this.contentResized();\n            }\n        }\n        setOptions(options) {\n            this._initOptions(options);\n            if (options.pullToRefresh) {\n                this._initPullToRefresh();\n            }\n        }\n        reset() {\n            if (this._native) {\n                this.scrollElement.scrollTop(0);\n            }\n            else {\n                this.movable.moveTo({\n                    x: 0,\n                    y: 0\n                });\n                this._scale(1);\n            }\n        }\n        contentResized() {\n            this.dimensions.refresh();\n            if (this.pane.x.outOfBounds()) {\n                this.movable.moveAxis('x', this.dimensions.x.min);\n            }\n            if (this.pane.y.outOfBounds()) {\n                this.movable.moveAxis('y', this.dimensions.y.min);\n            }\n        }\n        zoomOut() {\n            const dimensions = this.dimensions;\n            dimensions.refresh();\n            this._scale(dimensions.fitScale);\n            this.movable.moveTo(dimensions.centerCoordinates());\n        }\n        enable() {\n            this.enabled = true;\n        }\n        disable() {\n            this.enabled = false;\n        }\n        scrollTo(x, y) {\n            if (this._native) {\n                this.scrollElement.scrollLeft(abs(x));\n                this.scrollElement.scrollTop(abs(y));\n            }\n            else {\n                this.dimensions.refresh();\n                this.movable.moveTo({\n                    x: x,\n                    y: y\n                });\n            }\n        }\n        animatedScrollTo(x, y, callback) {\n            let from, to;\n            if (this._native) {\n                this.scrollTo(x, y);\n            }\n            else {\n                from = {\n                    x: this.movable.x,\n                    y: this.movable.y\n                };\n                to = {\n                    x: x,\n                    y: y\n                };\n                this.animatedScroller.setCoordinates(from, to);\n                this.animatedScroller.setCallback(callback);\n                this.animatedScroller.start();\n            }\n        }\n        // kept for API compatibility, not used\n        pullHandled() {\n            // let this = this;\n            // removeClass(this.refreshHint, SCROLLER_REFRESH_CLASS);\n            // this.hintContainer.innerHTML = this.pullTemplate({}));\n            // this.yinertia.onEnd();\n            // this.xinertia.onEnd();\n            // this.userEvents.cancel();\n        }\n        destroy() {\n            const element = this.element;\n            off(element, 'wheel', this._wheelScrollHandler);\n            if (this.userEvents) {\n                this.userEvents.destroy();\n            }\n            if (this.tapCapture) {\n                this.tapCapture.destroy();\n            }\n        }\n        _scale(scale) {\n            this.dimensions.rescale(scale);\n            this.movable.scaleTo(scale);\n        }\n        _initPullToRefresh() {\n        }\n        // kept for API compatibility, not used\n        _dragEnd() {\n            // let this = this;\n            // if (!this.pulled) {\n            //     return;\n            // }\n            // this.pulled = false;\n            // removeClass(this.refreshHint, SCROLLER_RELEASE_CLASS);\n            // addClass(this.refreshHint, SCROLLER_REFRESH_CLASS);\n            // this.hintContainer.innerHTML = this.refreshTemplate({});\n            // this.yinertia.freeze(this.options.pullOffset / 2);\n            // this.trigger('pull');\n        }\n        // kept for API compatibility, not used\n        _paneChange() {\n            // let this = this;\n            // if (this.movable.y / OUT_OF_BOUNDS_FRICTION > this.options.pullOffset) {\n            //     if (!this.pulled) {\n            //         this.pulled = true;\n            //         this.refreshHint.removeClass(SCROLLER_REFRESH_CLASS).addClass(SCROLLER_RELEASE_CLASS);\n            //         this.hintContainer.html(this.releaseTemplate({}));\n            //         this.hintContainer.html(this.releaseTemplate({}));\n            //     }\n            // } else if (this.pulled) {\n            //     this.pulled = false;\n            //     this.refreshHint.removeClass(SCROLLER_RELEASE_CLASS);\n            //     this.hintContainer.html(this.pullTemplate({}));\n            // }\n        }\n        _initAxis(axis) {\n            const movable = this.movable, dimension = this.dimensions[axis], tapCapture = this.tapCapture, paneAxis = this.pane[axis], scrollBar = new ScrollBar({\n                axis: axis,\n                movable: movable,\n                dimension: dimension,\n                container: this.element,\n                alwaysVisible: this.options.visibleScrollHints\n            });\n            dimension.bind(CHANGE, () => {\n                scrollBar.refresh();\n            });\n            paneAxis.bind(CHANGE, () => {\n                scrollBar.show();\n            });\n            this[axis + 'inertia'] = new DragInertia({\n                axis: axis,\n                paneAxis: paneAxis,\n                movable: movable,\n                tapCapture: tapCapture,\n                userEvents: this.userEvents,\n                dimension: dimension,\n                elastic: this.options.elastic,\n                friction: this.options.friction || FRICTION,\n                velocityMultiplier: this.options.velocityMultiplier || VELOCITY_MULTIPLIER,\n                end: () => {\n                    scrollBar.hide();\n                    this.trigger('scrollEnd', {\n                        axis: axis,\n                        scrollTop: this.scrollTop,\n                        scrollLeft: this.scrollLeft\n                    });\n                }\n            });\n        }\n    }\n\n    function macOS() {\n        var _a;\n        return /Macintosh|iPhone|iPad/i.test(((_a = window === null || window === void 0 ? void 0 : window.navigator) === null || _a === void 0 ? void 0 : _a.userAgent) || '');\n    }\n\n    class ScrollerTool extends EmptyTool {\n        constructor(toolService) {\n            super(toolService);\n            const diagram = this.toolService.diagram, canvas = diagram.canvas;\n            const friction = diagram._mobileOS() ? FRICTION_MOBILE : FRICTION$1;\n            const scroller = diagram.scroller = this.scroller = new Scroller(diagram.scrollable, {\n                friction: friction,\n                velocityMultiplier: VELOCITY_MULTIPLIER$1,\n                mousewheelScrolling: false,\n                zoom: false,\n                scroll: this._move.bind(this)\n            });\n            if (canvas.translate) {\n                this.movableCanvas = new Movable(canvas.element);\n            }\n            const virtualScroll = function (dimension, min, max) {\n                dimension.makeVirtual();\n                dimension.virtualSize(min || SCROLL_MIN, max || SCROLL_MAX);\n            };\n            virtualScroll(scroller.dimensions.x);\n            virtualScroll(scroller.dimensions.y);\n            scroller.disable();\n        }\n        tryActivate(_p, meta) {\n            const toolService = this.toolService;\n            const options = toolService.diagram.options.pannable;\n            const macCmd = meta.metaKey && macOS();\n            let enabled = meta.ctrlKey || macCmd;\n            if (defined(options.key)) {\n                if (!options.key || options.key === 'none') {\n                    enabled = noMeta(meta) && !defined(toolService.hoveredItem);\n                }\n                else {\n                    enabled = meta[options.key + 'Key'];\n                    enabled = enabled || (options.key === 'ctrl' && macCmd);\n                }\n            }\n            return options !== false && enabled && !defined(toolService.hoveredAdorner) && !defined(toolService._hoveredConnector);\n        }\n        start() {\n            this.scroller.enable();\n        }\n        move() {\n        } // the tool itself should not handle the scrolling. Let kendo scroller take care of this part. Check _move\n        _move(args) {\n            const diagram = this.toolService.diagram, canvas = diagram.canvas;\n            let scrollPos = new Point(args.scrollLeft, args.scrollTop);\n            if (canvas.translate) {\n                diagram._storePan(scrollPos.times(-1));\n                this.movableCanvas.moveTo(scrollPos);\n                canvas.translate(scrollPos.x, scrollPos.y);\n            }\n            else {\n                scrollPos = scrollPos.plus(diagram._pan.times(-1));\n            }\n            diagram.trigger(PAN, { pan: scrollPos });\n        }\n        end() {\n            this.scroller.disable();\n        }\n        getCursor() {\n            return Cursors.move;\n        }\n    }\n\n    class SelectionTool {\n        constructor(toolService) {\n            this.toolService = toolService;\n        }\n        tryActivate(_p, meta) {\n            const toolService = this.toolService;\n            const selectable = toolService.diagram.options.selectable;\n            let enabled = selectable && selectable.multiple !== false;\n            if (enabled) {\n                if (selectable.key && selectable.key !== 'none') {\n                    enabled = meta[selectable.key + 'Key'];\n                }\n                else {\n                    enabled = noMeta(meta);\n                }\n            }\n            return enabled && !defined(toolService.hoveredItem) && !defined(toolService.hoveredAdorner);\n        }\n        start(p) {\n            const diagram = this.toolService.diagram;\n            diagram.deselect();\n            diagram.selector.start(p);\n        }\n        move(p) {\n            const diagram = this.toolService.diagram;\n            diagram.selector.move(p);\n        }\n        end(_p, meta) {\n            const diagram = this.toolService.diagram, hoveredItem = this.toolService.hoveredItem;\n            const rect = diagram.selector.bounds();\n            if ((!hoveredItem || !hoveredItem.isSelected) && !meta.ctrlKey) {\n                diagram.deselect();\n            }\n            if (!rect.isEmpty()) {\n                diagram.selectArea(rect);\n            }\n            diagram.selector.end();\n        }\n        getCursor() {\n            return Cursors.arrow;\n        }\n    }\n\n    function testKey(key, str) {\n        return str.charCodeAt(0) === key || str.toUpperCase().charCodeAt(0) === key;\n    }\n\n    class ConnectionEditUnit {\n        constructor(item, redoSource, redoTarget) {\n            this.item = item;\n            this._redoSource = redoSource;\n            this._redoTarget = redoTarget;\n            if (defined(redoSource)) {\n                this._undoSource = item.source();\n            }\n            if (defined(redoTarget)) {\n                this._undoTarget = item.target();\n            }\n            this.title = ConnectionEditing;\n        }\n        undo() {\n            if (this._undoSource !== undefined) {\n                this.item._updateConnector(this._undoSource, SOURCE);\n            }\n            if (this._undoTarget !== undefined) {\n                this.item._updateConnector(this._undoTarget, TARGET);\n            }\n            this.item.updateModel();\n        }\n        redo() {\n            if (this._redoSource !== undefined) {\n                this.item._updateConnector(this._redoSource, SOURCE);\n            }\n            if (this._redoTarget !== undefined) {\n                this.item._updateConnector(this._redoTarget, TARGET);\n            }\n            this.item.updateModel();\n        }\n    }\n\n    const defaultOptions$1 = {\n        hover: {\n            stroke: {}\n        },\n        startCap: NONE,\n        endCap: NONE,\n        cornerRadius: 0,\n        points: [],\n        selectable: true,\n        fromConnector: AUTO,\n        toConnector: AUTO\n    };\n    const connectionTextOptions = (options) => {\n        return {\n            ...options,\n            padding: undefined,\n            textPadding: options.padding,\n            background: options.position === INLINE ? options.background || options.bgColor : options.background\n        };\n    };\n    /**\n     * The visual link between two Shapes through the intermediate of Connectors.\n     */\n    class Connection extends DiagramElement {\n        /**\n         * Creates a new Connection instance.\n         * @param from The source endpoint (Shape, Connector, or Point)\n         * @param to The target endpoint (Shape, Connector, or Point)\n         * @param options Configuration options for the connection\n         */\n        constructor(from, to, options) {\n            options = deepExtend({}, defaultOptions$1, options);\n            super(options);\n            /** @hidden */\n            this.name = 'Connection';\n            this.updateOptionsFromModel();\n            this._initRouter();\n            this.path = new Polyline(this.options);\n            this.path.fill(TRANSPARENT);\n            this.visual.append(this.path);\n            this._sourcePoint = this._targetPoint = new Point();\n            this._setSource(from);\n            this._setTarget(to);\n            this.content(this.options.content);\n            this.definers = [];\n            if (defined(options) && options.points) {\n                this.points(options.points);\n            }\n        }\n        /** @hidden */\n        _setOptionsFromModel(model) {\n            this.updateOptionsFromModel(model || this.dataItem);\n        }\n        /**\n         * Updates the connection options from the model data.\n         * @param model The model data to extract options from\n         */\n        updateOptionsFromModel(model) {\n            if (this.diagram && this.diagram._isEditable) {\n                const dataMap = this.diagram._dataMap;\n                const options = filterConnectionDataItem(model || this.dataItem);\n                if (model) {\n                    if (defined(options.from)) {\n                        let from = dataMap[options.from];\n                        if (from && defined(options.fromConnector)) {\n                            from = from.getConnector(options.fromConnector);\n                        }\n                        this.source(from);\n                    }\n                    else if (defined(options.fromX) && defined(options.fromY)) {\n                        this.source(new Point(options.fromX, options.fromY));\n                    }\n                    if (defined(options.to)) {\n                        let to = dataMap[options.to];\n                        if (to && defined(options.toConnector)) {\n                            to = to.getConnector(options.toConnector);\n                        }\n                        this.target(to);\n                    }\n                    else if (defined(options.toX) && defined(options.toY)) {\n                        this.target(new Point(options.toX, options.toY));\n                    }\n                    if (defined(options.type) && this.type() !== options.type) {\n                        this.points([]);\n                        this.type(options.type);\n                    }\n                    this.dataItem = model;\n                    this._template();\n                    this.redraw(this.options);\n                }\n                else {\n                    this.options = deepExtend({}, options, this.options);\n                }\n            }\n        }\n        /**\n         * Updates the connection's model data and optionally synchronizes changes.\n         * @param syncChanges Whether to synchronize changes immediately\n         */\n        updateModel(syncChanges) {\n            if (this.diagram && this.diagram._isEditable) {\n                this.diagram.updateConnectionModel(this, syncChanges);\n            }\n        }\n        /**\n         * Gets the Point where the source of the connection resides.\n         * If the endpoint is Auto-connector the location of the resolved connector will be returned.\n         * If the endpoint is floating the location of the endpoint is returned.\n         * @returns The source point of the connection\n         */\n        sourcePoint() {\n            return this._resolvedSourceConnector ? this._resolvedSourceConnector.position() : this._sourcePoint;\n        }\n        /** @hidden */\n        _setSource(source) {\n            const shapeSource = source instanceof Shape;\n            const defaultConnector = this.options.fromConnector || AUTO;\n            let dataItem;\n            if (shapeSource && !source.getConnector(defaultConnector)) {\n                return;\n            }\n            if (source !== undefined) {\n                this.from = source;\n            }\n            this._removeFromSourceConnector();\n            if (source === null) { // detach\n                if (this.sourceConnector) {\n                    this._sourcePoint = (this._resolvedSourceConnector || this.sourceConnector).position();\n                    this._clearSourceConnector();\n                    this._setFromOptions(null, this._sourcePoint);\n                }\n            }\n            else if (source instanceof Connector) {\n                dataItem = source.shape.dataItem;\n                if (dataItem) {\n                    this._setFromOptions(dataItem.id);\n                }\n                this.sourceConnector = source;\n                this.sourceConnector.connections.push(this);\n            }\n            else if (source instanceof Point) {\n                this._setFromOptions(null, source);\n                this._sourcePoint = source;\n                if (this.sourceConnector) {\n                    this._clearSourceConnector();\n                }\n            }\n            else if (shapeSource) {\n                dataItem = source.dataItem;\n                if (dataItem) {\n                    this._setFromOptions(dataItem.id);\n                }\n                this.sourceConnector = source.getConnector(defaultConnector);\n                this.sourceConnector.connections.push(this);\n            }\n        }\n        /**\n         * Gets or sets the source endpoint of the connection.\n         * @param source The source endpoint (Shape, Connector, or Point) to set. If not provided, returns the current source.\n         * @param undoable Whether this operation should be undoable\n         * @returns The current source when used as a getter\n         */\n        source(source, undoable) {\n            if (isDefined(source)) {\n                if (undoable && this.diagram) {\n                    this.diagram.undoRedoService.addCompositeItem(new ConnectionEditUnit(this, source));\n                }\n                this._setSource(source);\n                this.refresh();\n            }\n            return this.sourceConnector ? this.sourceConnector : this._sourcePoint;\n        }\n        /** @hidden */\n        _setFromOptions(from, fromPoint) {\n            this.options.from = from;\n            if (fromPoint) {\n                this.options.fromX = fromPoint.x;\n                this.options.fromY = fromPoint.y;\n            }\n            else {\n                this.options.fromX = null;\n                this.options.fromY = null;\n            }\n        }\n        /**\n         * Gets or sets the PathDefiner of the sourcePoint.\n         * The left part of this definer is always null since it defines the source tangent.\n         * @param value The PathDefiner to set. If not provided, returns the current source definer.\n         * @returns The source definer when used as a getter\n         */\n        sourceDefiner(value) {\n            if (value) {\n                if (value instanceof PathDefiner) {\n                    value.left = null;\n                    this._sourceDefiner = value;\n                    this.source(value.point); // refresh implicit here\n                }\n                else {\n                    throw new Error('The sourceDefiner needs to be a PathDefiner.');\n                }\n            }\n            else {\n                if (!this._sourceDefiner) {\n                    this._sourceDefiner = new PathDefiner(this.sourcePoint(), null, null);\n                }\n                return this._sourceDefiner;\n            }\n        }\n        /**\n         * Gets the Point where the target of the connection resides.\n         * @returns The target point of the connection\n         */\n        targetPoint() {\n            return this._resolvedTargetConnector ? this._resolvedTargetConnector.position() : this._targetPoint;\n        }\n        /** @hidden */\n        _setTarget(target) {\n            const shapeTarget = target instanceof Shape;\n            const defaultConnector = this.options.toConnector || AUTO;\n            let dataItem;\n            if (shapeTarget && !target.getConnector(defaultConnector)) {\n                return;\n            }\n            if (target !== undefined) {\n                this.to = target;\n            }\n            this._removeFromTargetConnector();\n            if (target === null) { // detach\n                if (this.targetConnector) {\n                    this._targetPoint = (this._resolvedTargetConnector || this.targetConnector).position();\n                    this._clearTargetConnector();\n                    this._setToOptions(null, this._targetPoint);\n                }\n            }\n            else if (target instanceof Connector) {\n                dataItem = target.shape.dataItem;\n                if (dataItem) {\n                    this._setToOptions(dataItem.id);\n                }\n                this.targetConnector = target;\n                this.targetConnector.connections.push(this);\n            }\n            else if (target instanceof Point) {\n                this._setToOptions(null, target);\n                this._targetPoint = target;\n                if (this.targetConnector) {\n                    this._clearTargetConnector();\n                }\n            }\n            else if (shapeTarget) {\n                dataItem = target.dataItem;\n                if (dataItem) {\n                    this._setToOptions(dataItem.id);\n                }\n                this.targetConnector = target.getConnector(defaultConnector);\n                this.targetConnector.connections.push(this);\n            }\n        }\n        /**\n         * Gets or sets the target endpoint of the connection.\n         * @param target The target endpoint (Shape, Connector, or Point) to set. If not provided, returns the current target.\n         * @param undoable Whether this operation should be undoable\n         * @returns The current target when used as a getter\n         */\n        target(target, undoable) {\n            if (isDefined(target)) {\n                if (undoable && this.diagram) {\n                    this.diagram.undoRedoService.addCompositeItem(new ConnectionEditUnit(this, undefined, target));\n                }\n                this._setTarget(target);\n                this.refresh();\n            }\n            return this.targetConnector ? this.targetConnector : this._targetPoint;\n        }\n        /** @hidden */\n        _setToOptions(to, toPoint) {\n            this.options.to = to;\n            if (toPoint) {\n                this.options.toX = toPoint.x;\n                this.options.toY = toPoint.y;\n            }\n            else {\n                this.options.toX = null;\n                this.options.toY = null;\n            }\n        }\n        /**\n         * Gets or sets the PathDefiner of the targetPoint.\n         * The right part of this definer is always null since it defines the target tangent.\n         * @param value The PathDefiner to set. If not provided, returns the current target definer.\n         * @returns The target definer when used as a getter\n         */\n        targetDefiner(value) {\n            if (value) {\n                if (value instanceof PathDefiner) {\n                    value.right = null;\n                    this._targetDefiner = value;\n                    this.target(value.point); // refresh implicit here\n                }\n                else {\n                    throw new Error('The sourceDefiner needs to be a PathDefiner.');\n                }\n            }\n            else {\n                if (!this._targetDefiner) {\n                    this._targetDefiner = new PathDefiner(this.targetPoint(), null, null);\n                }\n                return this._targetDefiner;\n            }\n        }\n        /** @hidden */\n        _updateConnectors() {\n            this._updateConnector(this.source(), SOURCE);\n            this._updateConnector(this.target(), TARGET);\n        }\n        /** @hidden */\n        _updateConnector(instance, name) {\n            const diagram = this.diagram;\n            if (instance instanceof Connector && !diagram.getShapeById(instance.shape.id)) {\n                const dataItem = instance.shape.dataItem;\n                const connectorName = instance.options.name;\n                const setNewTarget = () => {\n                    const shape = diagram._dataMap[dataItem.id];\n                    instance = shape.getConnector(connectorName);\n                    this[name](instance, false);\n                    this.updateModel();\n                };\n                if (diagram._dataMap[dataItem.id]) {\n                    setNewTarget();\n                }\n                else {\n                    const inactiveItem = diagram._inactiveShapeItems.getByUid(dataItem.uid);\n                    if (inactiveItem) {\n                        diagram._deferredConnectionUpdates.push(inactiveItem.onActivate(setNewTarget));\n                    }\n                }\n            }\n            else {\n                this[name](instance, false);\n            }\n        }\n        /**\n         * Gets or sets the content of the connection.\n         * @param content The content to set. If not provided, returns the current content.\n         * @returns The current content when used as a getter\n         */\n        content(content) {\n            const current = this.options.content.text;\n            const result = this._content(content);\n            if (defined(content)) {\n                if (current !== result) {\n                    this._contentVisual._measured = false;\n                }\n                this._alignContent();\n            }\n            return result;\n        }\n        /** @hidden */\n        _createContentVisual(options) {\n            let visual;\n            const hasVisual = options.visual;\n            const hasTemplate = options.template;\n            const templateOptions = extend$1({}, options, {\n                dataItem: this.dataItem || options.dataItem,\n            });\n            const template = getTemplate(templateOptions);\n            if (hasVisual) {\n                const visualResult = isFunction$1(template) ?\n                    template.call(this, templateOptions) :\n                    null;\n                visual = visualResult;\n            }\n            else if (hasTemplate) {\n                const templateResult = isFunction$1(template) ?\n                    template.call(this, templateOptions.dataItem) :\n                    null;\n                if (isFunction$1(templateResult)) {\n                    visual = templateResult;\n                }\n                else if (isString$1(templateResult)) {\n                    const textBlockOptions = {\n                        ...templateOptions,\n                        text: templateResult\n                    };\n                    visual = new (getTextElementType(textBlockOptions))(connectionTextOptions(textBlockOptions));\n                }\n            }\n            else if (options.text) {\n                visual = new (getTextElementType(options))(connectionTextOptions(options));\n            }\n            if (visual) {\n                this._contentVisual = visual;\n                visual._includeInBBox = false;\n                this.visual.append(visual);\n            }\n            return visual;\n        }\n        /** @hidden */\n        _updateContentVisual(options) {\n            if (isFunction$1(options.visual)) {\n                this.visual.remove(this._contentVisual);\n                this._createContentVisual(options);\n            }\n            else {\n                this._contentVisual.redraw(options);\n            }\n        }\n        /** @hidden */\n        _alignContent() {\n            if (this._contentVisual) {\n                const contentOptions = this.options.content || {};\n                const offset = contentOptions.offset !== undefined ? contentOptions.offset : CONNECTION_CONTENT_OFFSET;\n                const points = this.allPoints();\n                let endIdx = Math.floor(points.length / 2);\n                let startIdx = endIdx - 1;\n                while (startIdx > 0 && points[startIdx].equals(points[endIdx])) {\n                    startIdx--;\n                    endIdx++;\n                }\n                let endPoint = points[endIdx];\n                let startPoint = points[startIdx];\n                const boundingBox = this._contentVisual._measure();\n                let width = boundingBox.width;\n                let height = boundingBox.height;\n                let alignToPath = points.length % 2 === 0;\n                const distance = startPoint.distanceTo(endPoint);\n                // For inline labels with MultiLineTextBlock, use text-only size for centering\n                const position = contentOptions.position || {};\n                const verticalPosition = position.vertical || TOP.toLowerCase();\n                const horizontalPosition = position.horizontal || RIGHT.toLowerCase();\n                const isInline = position === INLINE;\n                let originOffsetX = 0;\n                let originOffsetY = 0;\n                if ((isInline || contentOptions.border) && this._contentVisual._textOnlyRect) {\n                    const textRect = this._contentVisual._textOnlyRect;\n                    width = textRect.size.width;\n                    height = textRect.size.height;\n                    originOffsetX = textRect.origin.x;\n                    originOffsetY = textRect.origin.y;\n                }\n                if (alignToPath && points.length > 2 && distance > 0 &&\n                    ((startPoint.y === endPoint.y && distance < width) || (startPoint.x === endPoint.x && distance < height))) {\n                    alignToPath = false;\n                }\n                const left = LEFT.toLowerCase();\n                const bottom = BOTTOM.toLowerCase();\n                let point;\n                if (alignToPath) {\n                    const angle = kendo_drawing_cmn_chunk_js.q(Math.atan2(endPoint.y - startPoint.y, endPoint.x - startPoint.x));\n                    point = new Point((endPoint.x - startPoint.x) / 2 + startPoint.x, (endPoint.y - startPoint.y) / 2 + startPoint.y);\n                    if (isInline) {\n                        // For inline, center the label on the connection\n                        // Compensate for text origin offset\n                        point.x -= (width / 2 + originOffsetX);\n                        point.y -= (height / 2 + originOffsetY);\n                    }\n                    else if (Math.abs(angle) === 90) {\n                        // Vertical connection - use horizontal position\n                        if (horizontalPosition === left) {\n                            point.x -= width + offset;\n                        }\n                        else {\n                            point.x += offset;\n                        }\n                        point.y -= height / 2;\n                    }\n                    else if (angle % 180 === 0) {\n                        // Horizontal connection - use vertical position\n                        point.x -= width / 2;\n                        if (verticalPosition === bottom) {\n                            point.y += offset;\n                        }\n                        else {\n                            point.y -= height + offset;\n                        }\n                    }\n                    else if (angle < -90 || (0 < angle && angle < 90)) {\n                        point.y -= height;\n                    }\n                    else if (angle < 0 || angle > 90) {\n                        point.x -= width;\n                        point.y -= height;\n                    }\n                }\n                else {\n                    const midIdx = Math.floor(points.length / 2);\n                    point = points[midIdx].clone();\n                    startPoint = points[midIdx - 1];\n                    endPoint = points[midIdx + 1];\n                    // Check if this is a vertical or horizontal segment\n                    const isVertical = startPoint.x === point.x && endPoint.x === point.x;\n                    const isHorizontal = startPoint.y === point.y && endPoint.y === point.y;\n                    let offsetX, offsetY;\n                    if (isInline) {\n                        // For inline, center the label on the connection\n                        // Compensate for text origin offset\n                        offsetX = -(width / 2 + originOffsetX);\n                        offsetY = -(height / 2 + originOffsetY);\n                    }\n                    else if (isVertical) {\n                        // Vertical segment - use horizontal position\n                        if (horizontalPosition === left) {\n                            offsetX = -boundingBox.width - offset;\n                        }\n                        else {\n                            offsetX = offset;\n                        }\n                        offsetY = -boundingBox.height / 2;\n                    }\n                    else if (isHorizontal) {\n                        // Horizontal segment - use vertical position\n                        offsetX = -boundingBox.width / 2;\n                        if (verticalPosition === bottom) {\n                            offsetY = offset;\n                        }\n                        else {\n                            offsetY = -boundingBox.height - offset;\n                        }\n                    }\n                    else {\n                        // Diagonal or other - keep original logic\n                        offsetX = startPoint.x <= point.x && endPoint.x <= point.x ? offset : -boundingBox.width - offset;\n                        offsetY = startPoint.y <= point.y && endPoint.y <= point.y ? offset : -boundingBox.height - offset;\n                    }\n                    point.x += offsetX;\n                    point.y += offsetY;\n                }\n                this._contentVisual.position(point);\n            }\n        }\n        /**\n         * Selects or deselects this connection.\n         * @param value True to select, false to deselect the connection\n         * @returns True if the selection state changed, false otherwise\n         */\n        select(value) {\n            const diagram = this.diagram;\n            let selected, deselected;\n            if (this._canSelect()) {\n                if (this.isSelected !== value) {\n                    this.isSelected = value;\n                    selected = [];\n                    deselected = [];\n                    if (this.isSelected) {\n                        this.adorner = new ConnectionEditAdorner(this, this.options.selection);\n                        diagram._adorn(this.adorner, true);\n                        diagram._selectedItems.push(this);\n                        selected.push(this);\n                    }\n                    else {\n                        if (this.adorner) {\n                            diagram._adorn(this.adorner, false);\n                            remove(diagram._selectedItems, this);\n                            this.adorner = undefined;\n                            deselected.push(this);\n                        }\n                    }\n                    if (this.adorner) {\n                        this.adorner.refresh();\n                    }\n                    if (!diagram._internalSelection) {\n                        diagram._selectionChanged(selected, deselected);\n                    }\n                    return true;\n                }\n            }\n        }\n        /**\n         * Gets or sets the bounds of this connection.\n         * @param value A Rect object to set as bounds. If not provided, returns the current bounds.\n         * @returns The bounds of the connection\n         * @remarks This is automatically set in the refresh() method.\n         */\n        bounds(value) {\n            if (value && !isString$1(value)) {\n                this._bounds = value;\n            }\n            else {\n                return this._bounds;\n            }\n        }\n        /**\n         * Gets or sets the connection type (see ConnectionType enumeration).\n         * @param value A ConnectionType value to set. If not provided, returns the current type.\n         * @returns The connection type\n         */\n        type(value) {\n            const options = this.options;\n            if (value) {\n                if (value !== options.type) {\n                    options.type = value;\n                    this._initRouter();\n                    this.refresh();\n                }\n            }\n            else {\n                return options.type;\n            }\n        }\n        /** @hidden */\n        _initRouter() {\n            const type = (this.options.type || '').toLowerCase();\n            if (type === CASCADING) {\n                this._router = new CascadingRouter(this);\n            }\n            else {\n                this._router = new PolylineRouter(this);\n            }\n        }\n        /**\n         * Gets or sets the collection of intermediate points.\n         * The 'allPoints()' property will return all the points.\n         * The 'definers' property returns the definers of the intermediate points.\n         * The 'sourceDefiner' and 'targetDefiner' return the definers of the endpoints.\n         * @param value Array of Points or point-like objects to set as intermediate points. If not provided, returns the current points.\n         * @returns Array of intermediate points when used as a getter\n         */\n        points(value) {\n            if (value) {\n                this.definers = [];\n                for (let i = 0; i < value.length; i++) {\n                    const definition = value[i];\n                    if (definition instanceof Point) {\n                        this.definers.push(new PathDefiner(definition));\n                    }\n                    else if (Object.prototype.hasOwnProperty.call(definition, 'x') && Object.prototype.hasOwnProperty.call(definition, 'y')) { // e.g. Clipboard does not preserve the Point definition and turned into an Object\n                        this.definers.push(new PathDefiner(new Point(definition.x, definition.y)));\n                    }\n                    else {\n                        throw new Error('A Connection point needs to be a Point or an object with x and y properties.');\n                    }\n                }\n            }\n            else {\n                const pts = [];\n                if (isDefined(this.definers)) {\n                    for (let k = 0; k < this.definers.length; k++) {\n                        pts.push(this.definers[k].point);\n                    }\n                }\n                return pts;\n            }\n        }\n        /**\n         * Gets all the points of this connection. This is the combination of the sourcePoint, the points and the targetPoint.\n         * @returns Array of all points including source, intermediate, and target points\n         */\n        allPoints() {\n            const pts = [this.sourcePoint()];\n            if (this.definers) {\n                for (let k = 0; k < this.definers.length; k++) {\n                    pts.push(this.definers[k].point);\n                }\n            }\n            pts.push(this.targetPoint());\n            return pts;\n        }\n        /**\n         * Refreshes the connection's visual representation.\n         * Resolves connectors, refreshes the path, aligns content, and updates adorners.\n         */\n        refresh() {\n            this._resolveConnectors();\n            this._refreshPath();\n            this._alignContent();\n            if (this.adorner) {\n                this.adorner.refresh();\n            }\n        }\n        /** @hidden */\n        _resolveConnectors() {\n            let sourcePoint, targetPoint, sourceConnectors, targetConnectors;\n            const source = this.source(), target = this.target();\n            if (source instanceof Point) {\n                sourcePoint = source;\n            }\n            else if (source instanceof Connector) {\n                if (isAutoConnector(source)) {\n                    sourceConnectors = source.shape.connectors;\n                }\n                else {\n                    sourceConnectors = [source];\n                }\n            }\n            if (target instanceof Point) {\n                targetPoint = target;\n            }\n            else if (target instanceof Connector) {\n                if (isAutoConnector(target)) {\n                    targetConnectors = target.shape.connectors;\n                }\n                else {\n                    targetConnectors = [target];\n                }\n            }\n            if (sourcePoint) {\n                if (targetConnectors) {\n                    this._resolvedTargetConnector = closestConnector(sourcePoint, targetConnectors);\n                }\n            }\n            else if (sourceConnectors) {\n                if (targetPoint) {\n                    this._resolvedSourceConnector = closestConnector(targetPoint, sourceConnectors);\n                }\n                else if (targetConnectors) {\n                    this._resolveAutoConnectors(sourceConnectors, targetConnectors);\n                }\n            }\n        }\n        /** @hidden */\n        _resolveAutoConnectors(sourceConnectors, targetConnectors) {\n            let minNonConflict = MAXINT;\n            let minDist = MAXINT;\n            let minNonConflictSource, minNonConflictTarget;\n            let sourcePoint, targetPoint;\n            let minSource, minTarget;\n            let sourceConnector, targetConnector;\n            let sourceIdx, targetIdx;\n            let dist;\n            for (sourceIdx = 0; sourceIdx < sourceConnectors.length; sourceIdx++) {\n                sourceConnector = sourceConnectors[sourceIdx];\n                if (!isAutoConnector(sourceConnector)) {\n                    sourcePoint = sourceConnector.position();\n                    for (targetIdx = 0; targetIdx < targetConnectors.length; targetIdx++) {\n                        targetConnector = targetConnectors[targetIdx];\n                        if (!isAutoConnector(targetConnector)) {\n                            targetPoint = targetConnector.position();\n                            dist = Math.round(sourcePoint.distanceTo(targetPoint));\n                            if (dist < minNonConflict && this.diagram && this._testRoutePoints(sourcePoint, targetPoint, sourceConnector, targetConnector)) {\n                                minNonConflict = dist;\n                                minNonConflictSource = sourceConnector;\n                                minNonConflictTarget = targetConnector;\n                            }\n                            if (dist < minDist) {\n                                minSource = sourceConnector;\n                                minTarget = targetConnector;\n                                minDist = dist;\n                            }\n                        }\n                    }\n                }\n            }\n            if (minNonConflictSource) {\n                minSource = minNonConflictSource;\n                minTarget = minNonConflictTarget;\n            }\n            this._resolvedSourceConnector = minSource;\n            this._resolvedTargetConnector = minTarget;\n        }\n        /** @hidden */\n        _testRoutePoints(sourcePoint, targetPoint, sourceConnector, targetConnector) {\n            const router = this._router;\n            let passRoute = true;\n            if (router instanceof CascadingRouter) {\n                const points = router.routePoints(sourcePoint, targetPoint, sourceConnector, targetConnector), exclude = this._getRouteExclude(sourcePoint, targetPoint, sourceConnector.shape, targetConnector.shape);\n                let start, end, rect;\n                points.unshift(sourcePoint);\n                points.push(targetPoint);\n                for (let idx = 1; idx < points.length; idx++) {\n                    start = points[idx - 1];\n                    end = points[idx];\n                    rect = new Rect(Math.min(start.x, end.x), Math.min(start.y, end.y), Math.abs(start.x - end.x), Math.abs(start.y - end.y));\n                    if (rect.width > 0) {\n                        rect.x++;\n                        rect.width -= 2;\n                    }\n                    if (rect.height > 0) {\n                        rect.y++;\n                        rect.height -= 2;\n                    }\n                    if (!rect.isEmpty() && this.diagram._shapesQuadTree.hitTestRect(rect, exclude)) {\n                        passRoute = false;\n                        break;\n                    }\n                }\n            }\n            return passRoute;\n        }\n        /** @hidden */\n        _getRouteExclude(sourcePoint, targetPoint, sourceShape, targetShape) {\n            const exclude = [];\n            if (this._isPointInsideShape(sourcePoint, sourceShape)) {\n                exclude.push(sourceShape);\n            }\n            if (this._isPointInsideShape(targetPoint, targetShape)) {\n                exclude.push(targetShape);\n            }\n            return exclude;\n        }\n        /** @hidden */\n        _isPointInsideShape(point, shape) {\n            const bounds = shape.bounds(), angle = shape.rotate().angle, boundsX = bounds.x, boundsY = bounds.y;\n            const rotatedPoint = point.clone().rotate(angle, bounds.center());\n            const pointX = rotatedPoint.x;\n            const pointY = rotatedPoint.y;\n            return pointX > boundsX && pointX < (boundsX + bounds.width) && pointY > boundsY && pointY < (boundsY + bounds.height);\n        }\n        /**\n         * Redraws the connection with new options.\n         * @param options The options to apply when redrawing the connection\n         */\n        redraw(options) {\n            if (options) {\n                this.options = deepExtend({}, this.options, options);\n                const points = this.options.points;\n                if (defined(points) && points.length > 0) {\n                    this.points(points);\n                    this._refreshPath();\n                }\n                if ((options && options.content) || options.text) {\n                    this.content(options.content);\n                }\n                this.path.redraw({\n                    fill: options.fill,\n                    stroke: options.stroke,\n                    startCap: options.startCap,\n                    endCap: options.endCap\n                });\n            }\n        }\n        /**\n         * Returns a clone of this connection.\n         * @returns A new Connection instance that is a copy of this connection\n         */\n        clone() {\n            const json = this.serialize();\n            if (this.diagram && this.diagram._isEditable && defined(this.dataItem)) {\n                json.options.dataItem = this.diagram.options.cloneDataItem(this.dataItem);\n            }\n            return new Connection(this.from, this.to, json.options);\n        }\n        /**\n         * Returns a serialized connection in JSON format. Consists of the options and the dataItem.\n         * @returns Serialized connection object containing options, endpoints, and data\n         */\n        serialize() {\n            const from = this.from.toJSON ? this.from.toJSON : this.from.toString(), to = this.to.toJSON ? this.to.toJSON : this.to.toString();\n            const json = deepExtend({}, {\n                options: this.options,\n                from: from,\n                to: to\n            });\n            if (defined(this.dataItem)) {\n                json.dataItem = this.dataItem.toString();\n            }\n            json.options.points = this.points();\n            return json;\n        }\n        /**\n         * @hidden\n         *\n         * Returns whether the given Point or Rect hits this connection.\n         *\n         * @param value\n         * @returns {Connection}\n         * @private\n         */\n        _hitTest(value) {\n            if (this.visible()) {\n                const p = new Point(value.x, value.y), from = this.sourcePoint(), to = this.targetPoint();\n                if (value.isEmpty && !value.isEmpty() && value.contains(from) && value.contains(to)) {\n                    return this;\n                }\n                if (this._router.hitTest(p)) {\n                    return this;\n                }\n            }\n        }\n        /** @hidden */\n        _hover(value) {\n            let color = (this.options.stroke || {}).color;\n            if (value && isDefined(this.options.hover.stroke.color)) {\n                color = this.options.hover.stroke.color;\n            }\n            this.path.redraw({\n                stroke: {\n                    color: color\n                }\n            });\n        }\n        /** @hidden */\n        _refreshPath() {\n            if (!defined(this.path)) {\n                return;\n            }\n            this._drawPath();\n            this.bounds(this._router.getBounds());\n        }\n        /** @hidden */\n        _drawPath() {\n            if (this._router) {\n                this._router.route(); // sets the intermediate points\n            }\n            const source = this.sourcePoint();\n            const target = this.targetPoint();\n            const points = this.points();\n            this.path.redraw({\n                points: [source].concat(points, [target])\n            });\n        }\n        /** @hidden */\n        _clearSourceConnector() {\n            this.sourceConnector = undefined;\n            this._resolvedSourceConnector = undefined;\n        }\n        /** @hidden */\n        _clearTargetConnector() {\n            this.targetConnector = undefined;\n            this._resolvedTargetConnector = undefined;\n        }\n        /** @hidden */\n        _removeFromSourceConnector() {\n            if (this.sourceConnector) {\n                remove(this.sourceConnector.connections, this);\n            }\n        }\n        /** @hidden */\n        _removeFromTargetConnector() {\n            if (this.targetConnector) {\n                remove(this.targetConnector.connections, this);\n            }\n        }\n        /**\n         * Converts the connection to a JSON representation for serialization.\n         * @returns Object containing the connection's endpoints information\n         */\n        toJSON() {\n            let from, to, point;\n            if (this.from && this.from.toJSON) {\n                from = this.from.toJSON();\n            }\n            else {\n                point = this._sourcePoint;\n                from = {\n                    x: point.x,\n                    y: point.y\n                };\n            }\n            if (this.to && this.to.toJSON) {\n                to = this.to.toJSON();\n            }\n            else {\n                point = this._targetPoint;\n                to = {\n                    x: point.x,\n                    y: point.y\n                };\n            }\n            return {\n                from: from,\n                to: to\n            };\n        }\n    }\n\n    const round = kendo_drawing_cmn_chunk_js.r;\n    function hitTestShapeConnectors(shape, point) {\n        let connector, position, rect;\n        for (let idx = 0; idx < shape.connectors.length; idx++) {\n            connector = shape.connectors[idx];\n            position = connector.position();\n            rect = new Rect(position.x, position.y);\n            rect.inflate(HIT_TEST_DISTANCE, HIT_TEST_DISTANCE);\n            if (rect.contains(point)) {\n                return connector;\n            }\n        }\n    }\n    /**\n     * The service managing the tools.\n     *\n     * @type {*}\n     */\n    class ToolService {\n        /**\n         * Creates a new ToolService instance.\n         * @param diagram The diagram instance that this tool service will manage\n         */\n        constructor(diagram) {\n            this.diagram = diagram;\n            this.tools = [\n                new ScrollerTool(this),\n                new ConnectionEditTool(this),\n                new ConnectionTool(this),\n                new SelectionTool(this),\n                new PointerTool(this)\n            ]; // the order matters.\n            this.activeTool = undefined;\n        }\n        /**\n         * Starts a tool interaction at the specified point.\n         * @param p The point where the interaction starts\n         * @param meta Metadata about the interaction (e.g., keyboard modifiers)\n         * @param nativeEvent The native DOM event that triggered this interaction\n         * @returns Always returns true to indicate the event was handled\n         */\n        start(p, meta, nativeEvent) {\n            meta = deepExtend({}, meta);\n            if (this.activeTool) {\n                this.activeTool.end(p, meta);\n            }\n            this._updateHoveredItem(p, meta, nativeEvent);\n            this._activateTool(p, meta);\n            this.activeTool.start(p, meta, nativeEvent);\n            this._updateCursor(p);\n            this.diagram.focus();\n            this.diagram.canvas.surface.suspendTracking();\n            this.startPoint = p;\n            return true;\n        }\n        /**\n         * Handles mouse movement during tool interaction.\n         * @param p The current mouse position\n         * @param meta Metadata about the interaction (e.g., keyboard modifiers)\n         * @param nativeEvent The native DOM event that triggered this movement\n         * @returns Always returns true to indicate the event was handled\n         */\n        move(p, meta, nativeEvent) {\n            meta = deepExtend({}, meta);\n            let updateHovered = true;\n            if (this.activeTool) {\n                updateHovered = this.activeTool.move(p, meta, nativeEvent);\n            }\n            if (updateHovered) {\n                this._updateHoveredItem(p, meta, nativeEvent);\n            }\n            this._updateCursor(p);\n            return true;\n        }\n        /**\n         * Ends the current tool interaction.\n         * @param point The point where the interaction ends\n         * @param meta Metadata about the interaction (e.g., keyboard modifiers)\n         * @param nativeEvent The native DOM event that triggered the end of interaction\n         * @returns Always returns true to indicate the event was handled\n         */\n        end(point, meta, nativeEvent) {\n            meta = deepExtend({}, meta);\n            if (this.activeTool) {\n                this.activeTool.end(point, meta, nativeEvent);\n            }\n            this.diagram.canvas.surface.resumeTracking();\n            this.activeTool = undefined;\n            this._updateCursor(point);\n            return true;\n        }\n        /**\n         * Handles keyboard input for diagram operations.\n         * Processes keyboard shortcuts for actions like select all, undo, redo, copy, paste, etc.\n         * @param key The key code of the pressed key\n         * @param meta Metadata about the key event (e.g., ctrl, shift, alt modifiers)\n         * @returns True if the key event was handled, undefined otherwise\n         */\n        keyDown(key, meta) {\n            const diagram = this.diagram;\n            meta = deepExtend({ ctrlKey: false, metaKey: false, altKey: false }, meta);\n            if ((meta.ctrlKey || meta.metaKey) && !meta.altKey) { // ctrl or option\n                if (testKey(key, 'a')) { // A: select all\n                    diagram.selectAll();\n                    diagram._destroyToolBar();\n                    return true;\n                }\n                else if (testKey(key, 'z')) { // Z: undo\n                    diagram.undo();\n                    diagram._destroyToolBar();\n                    return true;\n                }\n                else if (testKey(key, 'y')) { // y: redo\n                    diagram.redo();\n                    diagram._destroyToolBar();\n                    return true;\n                }\n                else if (testKey(key, 'c')) {\n                    diagram.copy();\n                    diagram._destroyToolBar();\n                }\n                else if (testKey(key, 'x')) {\n                    diagram.cut();\n                    diagram._destroyToolBar();\n                }\n                else if (testKey(key, 'v')) {\n                    diagram.paste();\n                    diagram._destroyToolBar();\n                }\n                else if (testKey(key, 'l')) {\n                    diagram.layout();\n                    diagram._destroyToolBar();\n                }\n                else if (testKey(key, 'd')) {\n                    diagram._destroyToolBar();\n                    diagram.copy();\n                    diagram.paste();\n                }\n            }\n            else if (key === 46 || key === 8) { // del: deletion\n                const toRemove = this.diagram._triggerRemove(diagram.select());\n                if (toRemove.length) {\n                    this.diagram.remove(toRemove, true);\n                    this.diagram._syncChanges();\n                    this.diagram._destroyToolBar();\n                }\n                return true;\n            }\n            else if (key === 27) { // ESC: stop any action\n                this._discardNewConnection();\n                diagram.deselect();\n                diagram._destroyToolBar();\n                return true;\n            }\n        }\n        /**\n         * Handles mouse wheel events for diagram zooming.\n         * @param p The point where the wheel event occurred\n         * @param meta Metadata about the wheel event including delta value\n         * @param nativeEvent The native wheel event\n         * @returns Always returns true to indicate the event was handled\n         */\n        wheel(p, meta, nativeEvent) {\n            const diagram = this.diagram;\n            let z = diagram.zoom();\n            const delta = meta.delta, options = diagram.options, zoomRate = options.zoomRate, zoomOptions = { point: p, meta: meta, zoom: z, nativeEvent };\n            if (diagram.trigger(ZOOM_START, zoomOptions)) {\n                return;\n            }\n            if (delta < 0) {\n                z += zoomRate;\n            }\n            else {\n                z -= zoomRate;\n            }\n            z = round(Math.max(options.zoomMin, Math.min(options.zoomMax, z)), 2);\n            zoomOptions.zoom = z;\n            diagram.zoom(z, zoomOptions);\n            diagram.trigger(ZOOM_END, zoomOptions);\n            return true;\n        }\n        /**\n         * Sets a tool at the specified index in the tools array.\n         * @param tool The tool instance to set\n         * @param index The index position where to place the tool\n         */\n        setTool(tool, index) {\n            tool.toolService = this;\n            this.tools[index] = tool;\n        }\n        /**\n         * Selects a single item in the diagram.\n         * Handles selection logic based on selectable options and keyboard modifiers.\n         * @param item The diagram item to select\n         * @param meta Metadata about the selection event (e.g., ctrl key for multi-selection)\n         */\n        selectSingle(item, meta) {\n            const diagram = this.diagram;\n            const selectable = diagram.options.selectable;\n            if (selectable && !item.isSelected && item.options.selectable !== false) {\n                const addToSelection = meta.ctrlKey && selectable.multiple !== false;\n                diagram.select(item, { addToSelection: addToSelection });\n            }\n        }\n        /** @hidden */\n        _discardNewConnection() {\n            if (this.newConnection) {\n                this.diagram.remove(this.newConnection);\n                this.newConnection = undefined;\n            }\n        }\n        /** @hidden */\n        _activateTool(p, meta) {\n            for (let i = 0; i < this.tools.length; i++) {\n                const tool = this.tools[i];\n                if (tool.tryActivate(p, meta)) {\n                    this.activeTool = tool;\n                    break; // activating the first available tool in the loop.\n                }\n            }\n        }\n        /** @hidden */\n        _updateCursor(p) {\n            const element = this.diagram.element;\n            const cursor = this.activeTool ? this.activeTool.getCursor(p) : (this.hoveredAdorner ? this.hoveredAdorner._getCursor(p) : (this.hoveredItem ? this.hoveredItem._getCursor(p) : Cursors.arrow));\n            element.style.cursor = cursor;\n        }\n        /** @hidden */\n        _connectionManipulation(connection, disabledShape, isNew) {\n            this.activeConnection = connection;\n            this.disabledShape = disabledShape;\n            if (isNew) {\n                this.newConnection = this.activeConnection;\n            }\n            else {\n                this.newConnection = undefined;\n            }\n        }\n        /** @hidden */\n        _updateHoveredItem(point, meta, nativeEvent) {\n            const hit = this._hitTest(point);\n            const diagram = this.diagram;\n            if (hit !== this.hoveredItem && (!this.disabledShape || hit !== this.disabledShape)) {\n                if (this.hoveredItem) {\n                    diagram.trigger(MOUSE_LEAVE, { item: this.hoveredItem, nativeEvent, point, meta });\n                    this.hoveredItem._hover(false);\n                }\n                if (hit && hit.options.enable) {\n                    diagram.trigger(MOUSE_ENTER, { item: hit, nativeEvent, point, meta });\n                    this.hoveredItem = hit; // Shape, connection or connector\n                    this.hoveredItem._hover(true);\n                }\n                else {\n                    this.hoveredItem = undefined;\n                }\n            }\n        }\n        /** @hidden */\n        _removeHover() {\n            if (this.hoveredItem) {\n                this.hoveredItem._hover(false);\n                this.hoveredItem = undefined;\n            }\n        }\n        /** @hidden */\n        _hitTest(point) {\n            const d = this.diagram;\n            let hit, item, i;\n            // connectors\n            if (this._hoveredConnector) {\n                this._hoveredConnector._hover(false);\n                this._hoveredConnector = undefined;\n            }\n            if (d._connectorsAdorner._visible) {\n                hit = d._connectorsAdorner._hitTest(point);\n                if (hit) {\n                    return hit;\n                }\n            }\n            hit = this.diagram._resizingAdorner._hitTest(point);\n            if (hit) {\n                this.hoveredAdorner = d._resizingAdorner;\n                if (hit.x !== 0 || hit.y !== 0) { // hit testing for resizers or rotator, otherwise if (0,0) than pass through.\n                    return;\n                }\n                hit = undefined;\n            }\n            else {\n                this.hoveredAdorner = undefined;\n            }\n            if (!this.activeTool || this.activeTool.type !== 'ConnectionTool') {\n                const selectedConnections = []; // only the connections should have higher presence because the connection edit point is on top of connector.\n                // TODO: This should be reworked. The connection adorner should be one for all selected connections and should be hit tested prior the connections and shapes itself.\n                for (i = 0; i < d._selectedItems.length; i++) {\n                    item = d._selectedItems[i];\n                    if (item instanceof Connection) {\n                        selectedConnections.push(item);\n                    }\n                }\n                hit = this._hitTestItems(selectedConnections, point);\n            }\n            return hit || this._hitTestElements(point);\n        }\n        /** @hidden */\n        _hitTestElements(point) {\n            const diagram = this.diagram;\n            const shapeHit = this._hitTestItems(diagram.shapes, point);\n            const connectionHit = this._hitTestItems(diagram.connections, point);\n            let hit;\n            if ((!this.activeTool || this.activeTool.type !== 'ConnectionTool') && shapeHit && connectionHit && !hitTestShapeConnectors(shapeHit, point)) {\n                const mainLayer = diagram.mainLayer;\n                const shapeIdx = inArray(shapeHit.visual, mainLayer.children);\n                const connectionIdx = inArray(connectionHit.visual, mainLayer.children);\n                hit = shapeIdx > connectionIdx ? shapeHit : connectionHit;\n            }\n            return hit || shapeHit || connectionHit;\n        }\n        /** @hidden */\n        _hitTestItems(array, point) {\n            let i, item, hit;\n            for (i = array.length - 1; i >= 0; i--) {\n                item = array[i];\n                hit = item._hitTest(point);\n                if (hit) {\n                    return hit;\n                }\n            }\n        }\n    }\n\n    class AddConnectionUnit {\n        constructor(connection, diagram) {\n            this.connection = connection;\n            this.diagram = diagram;\n            this.title = 'New connection';\n        }\n        undo() {\n            this.diagram.remove(this.connection, false);\n        }\n        redo() {\n            this.diagram._addConnection(this.connection, false);\n        }\n    }\n\n    class AddShapeUnit {\n        constructor(shape, diagram) {\n            this.shape = shape;\n            this.diagram = diagram;\n            this.title = 'New shape';\n        }\n        undo() {\n            this.diagram.deselect();\n            this.diagram.remove(this.shape, false);\n        }\n        redo() {\n            this.diagram._addShape(this.shape, false);\n        }\n    }\n\n    class CompositeUnit {\n        constructor(unit) {\n            this.units = [];\n            this.title = 'Composite unit';\n            if (unit !== undefined) {\n                this.units.push(unit);\n            }\n        }\n        add(undoUnit) {\n            this.units.push(undoUnit);\n        }\n        undo() {\n            for (let i = 0; i < this.units.length; i++) {\n                this.units[i].undo();\n            }\n        }\n        redo() {\n            for (let i = 0; i < this.units.length; i++) {\n                this.units[i].redo();\n            }\n        }\n    }\n\n    class DeleteConnectionUnit {\n        constructor(connection) {\n            this.connection = connection;\n            this.diagram = connection.diagram;\n            this.targetConnector = connection.targetConnector;\n            this.title = 'Delete connection';\n        }\n        undo() {\n            this.diagram._addConnection(this.connection, false);\n        }\n        redo() {\n            this.diagram.remove(this.connection, false);\n        }\n    }\n\n    class DeleteShapeUnit {\n        constructor(shape) {\n            this.shape = shape;\n            this.diagram = shape.diagram;\n            this.title = 'Deletion';\n        }\n        undo() {\n            this.diagram._addShape(this.shape, false);\n            this.shape.select(false);\n        }\n        redo() {\n            this.shape.select(false);\n            this.diagram.remove(this.shape, false);\n        }\n    }\n\n    class EditContentUnit {\n        constructor(shape, text) {\n            this.shape = shape;\n            this.nextText = text;\n            this.prevText = shape.content();\n            this.diagram = shape.diagram;\n            this.title = `Edit ${shape.name} Content`;\n        }\n        undo() {\n            this.shape.content({ text: this.prevText });\n        }\n        redo() {\n            this.shape.content({ text: this.nextText });\n        }\n    }\n\n    class PositionAdapter {\n        constructor(layoutState) {\n            this.layoutState = layoutState;\n            this.diagram = layoutState.diagram;\n        }\n        initState() {\n            this.froms = [];\n            this.tos = [];\n            this.subjects = [];\n            const pusher = (id, bounds) => {\n                const shape = this.diagram.getShapeById(id);\n                if (shape) {\n                    this.subjects.push(shape);\n                    this.froms.push(shape.bounds().topLeft());\n                    this.tos.push(bounds.topLeft());\n                }\n            };\n            this.layoutState.nodeMap.forEach(pusher, this);\n        }\n        update(tick) {\n            if (this.subjects.length <= 0) {\n                return;\n            }\n            for (let i = 0; i < this.subjects.length; i++) {\n                // todo: define a Lerp function instead\n                this.subjects[i].position(new Point(this.froms[i].x + (this.tos[i].x - this.froms[i].x) * tick, this.froms[i].y + (this.tos[i].y - this.froms[i].y) * tick));\n            }\n        }\n    }\n\n    class LayoutUndoUnit {\n        constructor(initialState, finalState, animate) {\n            if (isUndefined(animate)) {\n                this.animate = false;\n            }\n            else {\n                this.animate = Boolean(animate);\n            }\n            this._initialState = initialState;\n            this._finalState = finalState;\n            this.title = 'Diagram layout';\n        }\n        undo() {\n            this.setState(this._initialState);\n        }\n        redo() {\n            this.setState(this._finalState);\n        }\n        setState(state) {\n            const diagram = state.diagram;\n            if (this.animate) {\n                state.linkMap.forEach(function (id, points) {\n                    const conn = diagram.getShapeById(id);\n                    conn.visible(false);\n                    if (conn) {\n                        conn.points(points);\n                    }\n                });\n                const ticker = new Ticker();\n                ticker.addAdapter(new PositionAdapter(state));\n                ticker.onComplete(function () {\n                    state.linkMap.forEach(function (id) {\n                        const conn = diagram.getShapeById(id);\n                        conn.visible(true);\n                    });\n                });\n                ticker.play();\n            }\n            else {\n                state.nodeMap.forEach(function (id, bounds) {\n                    const shape = diagram.getShapeById(id);\n                    if (shape) {\n                        shape.position(bounds.topLeft());\n                    }\n                });\n                state.linkMap.forEach(function (id, points) {\n                    const conn = diagram.getShapeById(id);\n                    if (conn) {\n                        conn.points(points);\n                    }\n                });\n            }\n        }\n    }\n\n    class PanUndoUnit {\n        constructor(initialPosition, finalPosition, diagram) {\n            this.initial = initialPosition;\n            this.finalPos = finalPosition;\n            this.diagram = diagram;\n            this.title = 'Pan Unit';\n        }\n        undo() {\n            this.diagram.pan(this.initial);\n        }\n        redo() {\n            this.diagram.pan(this.finalPos);\n        }\n    }\n\n    class ToBackUnit {\n        constructor(diagram, items, initialIndices) {\n            this.diagram = diagram;\n            this.indices = initialIndices;\n            this.items = items;\n            this.title = 'Rotate Unit';\n        }\n        undo() {\n            this.diagram._toIndex(this.items, this.indices);\n        }\n        redo() {\n            this.diagram.toBack(this.items, false);\n        }\n    }\n\n    class ToFrontUnit {\n        constructor(diagram, items, initialIndices) {\n            this.diagram = diagram;\n            this.indices = initialIndices;\n            this.items = items;\n            this.title = 'Rotate Unit';\n        }\n        undo() {\n            this.diagram._toIndex(this.items, this.indices);\n        }\n        redo() {\n            this.diagram.toFront(this.items, false);\n        }\n    }\n\n    /**\n     * Undo-redo service.\n     */\n    class UndoRedoService extends Observable {\n        constructor(options = {}) {\n            super();\n            this.events = ['undone', 'redone'];\n            this.bind(this.events, options);\n            this.stack = [];\n            this.index = 0;\n            this.capacity = 100;\n        }\n        /**\n         * Starts the collection of units. Add those with\n         * the addCompositeItem method and call commit. Or cancel to forget about it.\n         */\n        begin() {\n            this.composite = new CompositeUnit();\n        }\n        /**\n         * Cancels the collection process of unit started with 'begin'.\n         */\n        cancel() {\n            this.composite = undefined;\n        }\n        /**\n         * Commits a batch of units.\n         */\n        commit(execute) {\n            if (this.composite.units.length > 0) {\n                this._restart(this.composite, execute);\n            }\n            this.composite = undefined;\n        }\n        /**\n         * Adds a unit as part of the begin-commit batch.\n         *\n         * @param undoUnit\n         */\n        addCompositeItem(undoUnit) {\n            if (this.composite) {\n                this.composite.add(undoUnit);\n            }\n            else {\n                this.add(undoUnit);\n            }\n        }\n        /**\n         * Standard addition of a unit. See also the batch version; begin-addCompositeUnit-commit methods.\n         *\n         * @param undoUnit The unit to be added.\n         * @param execute If false, the unit will be added but not executed.\n         */\n        add(undoUnit, execute) {\n            this._restart(undoUnit, execute);\n        }\n        /**\n         * Returns the number of undoable unit in the stack.\n         *\n         * @returns {Number}\n         */\n        pop() {\n            if (this.index > 0) {\n                this.stack.pop();\n                this.index--;\n            }\n        }\n        count() {\n            return this.stack.length;\n        }\n        /**\n         * Rollback of the unit on top of the stack.\n         */\n        undo() {\n            if (this.index > 0 && !this.trigger('undo', { unit: this.stack[this.index - 1] })) {\n                this.index--;\n                this.stack[this.index].undo();\n                this.trigger('undone');\n            }\n        }\n        /**\n         * Redo of the last undone action.\n         */\n        redo() {\n            if (this.stack.length > 0 && this.index < this.stack.length && !this.trigger('redo', { unit: this.stack[this.index] })) {\n                this.stack[this.index].redo();\n                this.index++;\n                this.trigger('redone');\n            }\n        }\n        _restart(composite, execute) {\n            // throw away anything beyond this point if this is a new branch\n            this.stack.splice(this.index, this.stack.length - this.index);\n            this.stack.push(composite);\n            if (execute !== false) {\n                this.redo();\n            }\n            else {\n                this.index++;\n            }\n            // check the capacity\n            if (this.stack.length > this.capacity) {\n                this.stack.splice(0, this.stack.length - this.capacity);\n                this.index = this.capacity; // points to the end of the stack\n            }\n        }\n        /**\n         * Clears the stack.\n         */\n        clear() {\n            this.stack = [];\n            this.index = 0;\n        }\n    }\n\n    class InactiveItem {\n        constructor(dataItem) {\n            this.dataItem = dataItem;\n            this.callbacks = [];\n        }\n        onActivate(callback) {\n            return new Promise((resolve) => {\n                this.callbacks.push({\n                    callback,\n                    resolve\n                });\n            });\n        }\n        activate() {\n            const callbacks = this.callbacks;\n            let item;\n            for (let idx = 0; idx < callbacks.length; idx++) {\n                item = this.callbacks[idx];\n                item.callback(this.dataItem);\n                item.resolve();\n            }\n            this.callbacks = [];\n        }\n    }\n    class InactiveItemsCollection {\n        constructor() {\n            this.items = {};\n        }\n        add(items) {\n            for (let idx = 0; idx < items.length; idx++) {\n                this.items[items[idx].uid] = new InactiveItem(items[idx]);\n            }\n        }\n        forEach(callback) {\n            for (const uid in this.items) {\n                if (Object.prototype.hasOwnProperty.call(this.items, uid)) {\n                    callback(this.items[uid]);\n                }\n            }\n        }\n        getByUid(uid) {\n            return this.items[uid];\n        }\n        remove(item) {\n            delete this.items[item.uid];\n        }\n        destroy() {\n            this.items = {};\n        }\n    }\n\n    class QuadRoot {\n        constructor() {\n            this.shapes = [];\n        }\n        _add(shape, bounds) {\n            this.shapes.push({\n                bounds: bounds,\n                shape: shape\n            });\n            shape._quadNode = this;\n        }\n        insert(shape, bounds) {\n            this._add(shape, bounds);\n        }\n        remove(shape) {\n            const shapes = this.shapes;\n            const length = shapes.length;\n            for (let idx = 0; idx < length; idx++) {\n                if (shapes[idx].shape === shape) {\n                    shapes.splice(idx, 1);\n                    break;\n                }\n            }\n        }\n        hitTestRect(rect, exclude) {\n            const shapes = this.shapes;\n            const length = shapes.length;\n            for (let i = 0; i < length; i++) {\n                if (this._testRect(shapes[i].shape, rect) && !contains(exclude, shapes[i].shape)) {\n                    return true;\n                }\n            }\n        }\n        _testRect(shape, rect) {\n            const angle = shape.rotate().angle;\n            const bounds = shape.bounds();\n            let hit;\n            if (!angle) {\n                hit = bounds.overlaps(rect);\n            }\n            else {\n                hit = Intersect.rects(rect, bounds, -angle);\n            }\n            return hit;\n        }\n    }\n\n    class QuadNode extends QuadRoot {\n        constructor(rect) {\n            super();\n            this.children = [];\n            this.rect = rect;\n        }\n        inBounds(rect) {\n            const nodeRect = this.rect;\n            const nodeBottomRight = nodeRect.bottomRight();\n            const bottomRight = rect.bottomRight();\n            const inBounds = nodeRect.x <= rect.x && nodeRect.y <= rect.y && bottomRight.x <= nodeBottomRight.x &&\n                bottomRight.y <= nodeBottomRight.y;\n            return inBounds;\n        }\n        overlapsBounds(rect) {\n            return this.rect.overlaps(rect);\n        }\n        insert(shape, bounds) {\n            let inserted = false;\n            const children = this.children;\n            const length = children.length;\n            if (this.inBounds(bounds)) {\n                if (!length && this.shapes.length < 4) {\n                    this._add(shape, bounds);\n                }\n                else {\n                    if (!length) {\n                        this._initChildren();\n                    }\n                    for (let idx = 0; idx < children.length; idx++) {\n                        if (children[idx].insert(shape, bounds)) {\n                            inserted = true;\n                            break;\n                        }\n                    }\n                    if (!inserted) {\n                        this._add(shape, bounds);\n                    }\n                }\n                inserted = true;\n            }\n            return inserted;\n        }\n        _initChildren() {\n            const rect = this.rect, children = this.children, shapes = this.shapes, center = rect.center(), halfWidth = rect.width / 2, halfHeight = rect.height / 2;\n            let childIdx, shapeIdx;\n            children.push(new QuadNode(new Rect(rect.x, rect.y, halfWidth, halfHeight)), new QuadNode(new Rect(center.x, rect.y, halfWidth, halfHeight)), new QuadNode(new Rect(rect.x, center.y, halfWidth, halfHeight)), new QuadNode(new Rect(center.x, center.y, halfWidth, halfHeight)));\n            for (shapeIdx = shapes.length - 1; shapeIdx >= 0; shapeIdx--) {\n                for (childIdx = 0; childIdx < children.length; childIdx++) {\n                    if (children[childIdx].insert(shapes[shapeIdx].shape, shapes[shapeIdx].bounds)) {\n                        shapes.splice(shapeIdx, 1);\n                        break;\n                    }\n                }\n            }\n        }\n        hitTestRect(rect, exclude) {\n            let idx;\n            const children = this.children;\n            const length = children.length;\n            let hit = false;\n            if (this.overlapsBounds(rect)) {\n                if (super.hitTestRect(rect, exclude)) {\n                    hit = true;\n                }\n                else {\n                    for (idx = 0; idx < length; idx++) {\n                        if (children[idx].hitTestRect(rect, exclude)) {\n                            hit = true;\n                            break;\n                        }\n                    }\n                }\n            }\n            return hit;\n        }\n    }\n\n    class ShapesQuadTree {\n        constructor(diagram) {\n            this.ROOT_SIZE = 1000;\n            const boundsChangeHandler = this._boundsChange.bind(this);\n            diagram.bind(ITEMBOUNDSCHANGE, boundsChangeHandler);\n            diagram.bind(ITEMROTATE, boundsChangeHandler);\n            this.initRoots();\n        }\n        initRoots() {\n            this.rootMap = {};\n            this.root = new QuadRoot();\n        }\n        clear() {\n            this.initRoots();\n        }\n        _boundsChange(e) {\n            if (e.item._quadNode) {\n                e.item._quadNode.remove(e.item);\n            }\n            this.insert(e.item);\n        }\n        insert(shape) {\n            const bounds = shape.bounds(ROTATED);\n            const rootSize = this.ROOT_SIZE;\n            const sectors = this.getSectors(bounds);\n            const x = sectors[0][0];\n            const y = sectors[1][0];\n            if (this.inRoot(sectors)) {\n                this.root.insert(shape, bounds);\n            }\n            else {\n                if (!this.rootMap[x]) {\n                    this.rootMap[x] = {};\n                }\n                if (!this.rootMap[x][y]) {\n                    this.rootMap[x][y] = new QuadNode(new Rect(x * rootSize, y * rootSize, rootSize, rootSize));\n                }\n                this.rootMap[x][y].insert(shape, bounds);\n            }\n        }\n        remove(shape) {\n            if (shape._quadNode) {\n                shape._quadNode.remove(shape);\n            }\n        }\n        inRoot(sectors) {\n            return sectors[0].length > 1 || sectors[1].length > 1;\n        }\n        getSectors(rect) {\n            const rootSize = this.ROOT_SIZE;\n            const bottomRight = rect.bottomRight();\n            const bottomX = Math.floor(bottomRight.x / rootSize);\n            const bottomY = Math.floor(bottomRight.y / rootSize);\n            const sectors = [[], []];\n            for (let x = Math.floor(rect.x / rootSize); x <= bottomX; x++) {\n                sectors[0].push(x);\n            }\n            for (let y = Math.floor(rect.y / rootSize); y <= bottomY; y++) {\n                sectors[1].push(y);\n            }\n            return sectors;\n        }\n        hitTestRect(rect, exclude) {\n            const sectors = this.getSectors(rect);\n            let xIdx, yIdx, x, y;\n            let root;\n            if (this.root.hitTestRect(rect, exclude)) {\n                return true;\n            }\n            for (xIdx = 0; xIdx < sectors[0].length; xIdx++) {\n                x = sectors[0][xIdx];\n                for (yIdx = 0; yIdx < sectors[1].length; yIdx++) {\n                    y = sectors[1][yIdx];\n                    root = (this.rootMap[x] || {})[y];\n                    if (root && root.hitTestRect(rect, exclude)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n    }\n\n    function copyDefaultOptions(mainOptions, elementOptions, fields) {\n        let field;\n        for (let idx = 0; idx < fields.length; idx++) {\n            field = fields[idx];\n            if (elementOptions && !defined(elementOptions[field])) {\n                elementOptions[field] = mainOptions[field];\n            }\n        }\n    }\n    const defaultOptions = {\n        name: 'Diagram',\n        theme: 'sass',\n        layout: '',\n        zoomRate: 0.1,\n        zoom: 1,\n        zoomMin: 0,\n        zoomMax: 2,\n        dataSource: {},\n        draggable: true,\n        template: '',\n        autoBind: true,\n        editable: {\n            rotate: {},\n            resize: {},\n            text: true,\n            tools: [],\n            drag: {\n                snap: {\n                    size: 10,\n                    angle: 10\n                }\n            },\n            remove: true\n        },\n        pannable: {},\n        selectable: {\n            key: 'none'\n        },\n        tooltip: {\n            delay: 200,\n            // Inherited from JQuery Diagram, not in use here.\n            enabled: true, format: '{0}'\n        },\n        copy: {\n            enabled: true,\n            offsetX: 20,\n            offsetY: 20\n        },\n        shapeDefaults: shapeDefaults({ undoable: true, connectors: undefined }),\n        connectionDefaults: {\n            editable: {\n                tools: []\n            },\n            tooltip: {\n                visible: true\n            },\n            type: CASCADING\n        },\n        shapes: [],\n        connections: []\n    };\n    const domEvents = ['contextmenu', 'dblclick', 'pointerdown', 'pointermove', 'pointerup', 'pointercancel', 'pointerleave', 'touchstart', 'touchmove', 'touchend', 'touchcancel'];\n    const events = [\n        ZOOM_END,\n        ZOOM_START,\n        PAN, SELECT$1,\n        ITEMROTATE,\n        ITEMBOUNDSCHANGE,\n        CHANGE$1,\n        CLICK,\n        MOUSE_ENTER,\n        MOUSE_LEAVE,\n        TOOLTIP_SHOW,\n        TOOLTIP_HIDE,\n        'toolBarClick',\n        'save',\n        'cancel',\n        'edit',\n        'remove',\n        'undo',\n        'redo',\n        'add',\n        'dataBound',\n        ...domEvents,\n        DRAG_START,\n        DRAG,\n        DRAG_END\n    ];\n    function splitDiagramElements(elements) {\n        const connections = [];\n        const shapes = [];\n        let element, idx;\n        for (idx = 0; idx < elements.length; idx++) {\n            element = elements[idx];\n            if (element instanceof Shape) {\n                shapes.push(element);\n            }\n            else {\n                connections.push(element);\n            }\n        }\n        return {\n            shapes: shapes,\n            connections: connections\n        };\n    }\n    function preventDefault(e) {\n        e.preventDefault();\n    }\n    function elementOffset(element) {\n        const rect = element.getBoundingClientRect();\n        const doc = element.ownerDocument;\n        const scrollLeft = doc.defaultView.scrollX || doc.documentElement.scrollLeft || 0;\n        const scrollTop = doc.defaultView.scrollY || doc.documentElement.scrollTop || 0;\n        return {\n            top: rect.top + scrollTop,\n            left: rect.left + scrollLeft\n        };\n    }\n    function outerWidth(element, includeMargins = false) {\n        let widthValue = element.offsetWidth; // Width of the element with padding and border\n        if (includeMargins) {\n            const style = getComputedStyle(element);\n            const marginLeft = parseFloat(style.marginLeft);\n            const marginRight = parseFloat(style.marginRight);\n            widthValue += marginLeft + marginRight;\n        }\n        return widthValue;\n    }\n    function outerHeight(element, includeMargins = false) {\n        let heightValue = element.offsetHeight;\n        if (includeMargins) {\n            const style = getComputedStyle(element);\n            const marginTop = parseFloat(style.marginTop);\n            const marginBottom = parseFloat(style.marginBottom);\n            heightValue += marginTop + marginBottom;\n        }\n        return heightValue;\n    }\n    function elementWidth(element) {\n        const style = getComputedStyle(element);\n        const widthValue = element.clientWidth; // Includes content + padding\n        const paddingLeft = parseFloat(style.paddingLeft);\n        const paddingRight = parseFloat(style.paddingRight);\n        return widthValue - paddingLeft - paddingRight; // Only content\n    }\n    function elementHeight(element) {\n        const style = getComputedStyle(element);\n        const heightValue = element.clientHeight;\n        const paddingTop = parseFloat(style.paddingTop);\n        const paddingBottom = parseFloat(style.paddingBottom);\n        return heightValue - paddingTop - paddingBottom;\n    }\n\n    class Diagram extends Observable {\n        /**\n         * Creates a new Diagram instance.\n         * @param element The HTML element that will contain the diagram\n         * @param userOptions Configuration options for the diagram\n         * @param themeOptions Theme-specific options\n         */\n        constructor(element, userOptions, themeOptions) {\n            super();\n            /** @hidden */\n            this._clipboard = [];\n            /** @hidden */\n            this._connectionsDataMap = {};\n            /** @hidden */\n            this._dataMap = {};\n            /** @hidden */\n            this._inactiveShapeItems = new InactiveItemsCollection();\n            /** @hidden */\n            this._selectedItems = [];\n            /** Array of all shapes in the diagram. */\n            this.shapes = [];\n            /** Array of all connections in the diagram. */\n            this.connections = [];\n            /** @hidden */\n            this._deferredConnectionUpdates = [];\n            /** @hidden */\n            this._domEvent = (nativeEvent) => {\n                const meta = this._meta(nativeEvent);\n                const point = this._eventPositions(nativeEvent);\n                const item = this.toolService._hitTest(point);\n                this.trigger(nativeEvent.type, { nativeEvent, item, point, meta });\n            };\n            this.element = element;\n            this.options = deepExtend({ createToolBar: noop$1, destroyToolBar: noop$1 }, defaultOptions, userOptions);\n            this.events = events;\n            this._initTheme(themeOptions);\n            this._initElements();\n            this._extendLayoutOptions(this.options);\n            this._initDefaults(userOptions);\n            this._interactionDefaults();\n            this._initCanvas();\n            this.mainLayer = new Group({\n                id: 'main-layer'\n            });\n            this.canvas.append(this.mainLayer);\n            this._shapesQuadTree = new ShapesQuadTree(this);\n            this._pan = new Point();\n            this._adorners = [];\n            this.adornerLayer = new Group({\n                id: 'adorner-layer'\n            });\n            this.canvas.append(this.adornerLayer);\n            this._createHandlers();\n            this._initialize();\n            this._resizingAdorner = new ResizingAdorner(this, { editable: this.options.editable });\n            this._connectorsAdorner = new ConnectorsAdorner(this);\n            this._adorn(this._resizingAdorner, true);\n            this._adorn(this._connectorsAdorner, true);\n            this.selector = new Selector(this);\n            // TODO: We may consider using real Clipboard API once is supported by the standard.\n            this._clipboard.length = 0;\n            this.pauseMouseHandlers = false;\n        }\n        /** @hidden */\n        _createShape(dataItem, options) {\n            options = deepExtend({}, this.options.shapeDefaults, options);\n            options.dataItem = dataItem;\n            const shape = new Shape(options, this);\n            return shape;\n        }\n        /** @hidden */\n        _createConnection(dataItem, source, target) {\n            const options = deepExtend({}, this.options.connectionDefaults);\n            options.dataItem = dataItem;\n            const connection = new Connection(source || new Point(), target || new Point(), options);\n            return connection;\n        }\n        /** @hidden */\n        _initElements() {\n            this.element.innerHTML = '';\n            this.element.style.position = 'relative';\n            this.element.setAttribute('tabindex', '0');\n            this.element.classList.add('k-diagram');\n            this.scrollable = document.createElement('div');\n            this.element.appendChild(this.scrollable);\n            this.wrapper = this.element;\n        }\n        /** @hidden */\n        _initDefaults(userOptions) {\n            const options = this.options;\n            const editable = options.editable;\n            const shapeDefaults = options.shapeDefaults;\n            const connectionDefaults = options.connectionDefaults;\n            const userShapeDefaults = (userOptions || {}).shapeDefaults;\n            if (editable === false) {\n                shapeDefaults.editable = false;\n                connectionDefaults.editable = false;\n            }\n            else {\n                copyDefaultOptions(editable, shapeDefaults.editable, ['drag', 'remove', 'connect']);\n                copyDefaultOptions(editable, connectionDefaults.editable, ['drag', 'remove']);\n            }\n            if (userShapeDefaults && userShapeDefaults.connectors) {\n                options.shapeDefaults.connectors = userShapeDefaults.connectors;\n            }\n        }\n        /** @hidden */\n        _interactionDefaults() {\n            const options = this.options;\n            const selectable = options.selectable;\n            const pannable = options.pannable;\n            const mobile = this._mobileOS();\n            if (selectable && !defined(selectable.multiple)) {\n                options.selectable = deepExtend({\n                    multiple: mobile ? false : true\n                }, options.selectable);\n            }\n            if (pannable && !defined(pannable.key)) {\n                options.pannable = deepExtend({\n                    key: mobile ? 'none' : 'ctrl'\n                }, options.pannable);\n            }\n        }\n        /** @hidden */\n        _initCanvas() {\n            const canvasContainer = document.createElement('div');\n            canvasContainer.classList.add('k-layer');\n            this.scrollable.appendChild(canvasContainer);\n            const viewPort = this.viewport();\n            this.canvas = new (this.options.Canvas || Canvas$1)(canvasContainer, {\n                width: viewPort.width || DEFAULT_CANVAS_WIDTH,\n                height: viewPort.height || DEFAULT_CANVAS_HEIGHT\n            });\n        }\n        /** @hidden */\n        _createHandlers() {\n            const element = this.element;\n            this._wheelHandler = this._wheelHandler || this._wheel.bind(this);\n            this._keydownHandler = this._keydownHandler || this._keydown.bind(this);\n            if (this._mobileOS() && this._mobileOS().browser.mobilesafari) {\n                element.addEventListener('mousewheel', this._wheelHandler);\n            }\n            else {\n                element.addEventListener('wheel', this._wheelHandler);\n            }\n            element.addEventListener('keydown', this._keydownHandler);\n            this._userEvents = new UserEvents(this.scrollable, {\n                multiTouch: true,\n                fastTap: true,\n                tap: this._tap.bind(this),\n                start: this._dragStart.bind(this),\n                move: this._drag.bind(this),\n                end: this._dragEnd.bind(this),\n                gesturestart: this._gestureStart.bind(this),\n                gesturechange: this._gestureChange.bind(this),\n                gestureend: this._gestureEnd.bind(this),\n                doubleTap: this._doubleTap.bind(this),\n                supportDoubleTap: true\n            });\n            this.toolService = new ToolService(this);\n            this._mouseoverHandler = this._mouseoverHandler || this._mouseover.bind(this);\n            this._mouseoutHandler = this._mouseoutHandler || this._mouseout.bind(this);\n            this._mouseMoveHandler = this._mouseMoveHandler || this._mouseMove.bind(this);\n            this._mouseDownHandler = this._mouseDownHandler || this._mouseDown.bind(this);\n            this._mouseUpHandler = this._mouseUpHandler || this._mouseUp.bind(this);\n            this.scrollable.addEventListener('mouseover', this._mouseoverHandler);\n            this.scrollable.addEventListener('mouseout', this._mouseoutHandler);\n            this.scrollable.addEventListener('mousemove', this._mouseMoveHandler);\n            this.scrollable.addEventListener('mousedown', this._mouseDownHandler);\n            this.scrollable.addEventListener('mouseup', this._mouseUpHandler);\n            domEvents.forEach(event => {\n                this.scrollable.addEventListener(event, this._domEvent);\n            });\n            this._initResizeObserver();\n            this.bind(ZOOM_START, this._destroyToolBar.bind(this));\n            this.bind(PAN, this._destroyToolBar.bind(this));\n            this.bind(MOUSE_ENTER, this._onMouseEnter.bind(this));\n            this.bind(MOUSE_LEAVE, this._onMouseLeave.bind(this));\n        }\n        _onMouseEnter(event) {\n            const { delay } = this.options.tooltip;\n            this._tooltipTimeOut = setTimeout(() => {\n                this.trigger(TOOLTIP_SHOW, event);\n                this._tooltipTimeOut = null;\n            }, delay);\n        }\n        _onMouseLeave(event) {\n            clearTimeout(this._tooltipTimeOut);\n            this.trigger(TOOLTIP_HIDE, event);\n        }\n        /** @hidden */\n        _initResizeObserver() {\n            const observer = new ResizeObserver((entries) => {\n                entries.forEach(entry => {\n                    const { width, height } = entry.contentRect;\n                    if (entry.target !== this.element ||\n                        (this.size && this.size.width === width && this.size.height === height)) {\n                        return;\n                    }\n                    this.size = { width, height };\n                    this._resize();\n                    this.trigger('resize', this.size);\n                });\n            });\n            this._resizeObserver = observer;\n            observer.observe(this.element);\n        }\n        /** @hidden */\n        _destroyResizeObserver() {\n            if (this._resizeObserver) {\n                this._resizeObserver.disconnect();\n                this._resizeObserver = null;\n            }\n        }\n        /** @hidden */\n        _dragStart(e) {\n            this._pauseMouseHandlers = true;\n            const point = this._eventPositions(e, true);\n            if (this.toolService.start(point, this._meta(e), e.event)) {\n                this._destroyToolBar();\n                e.preventDefault();\n            }\n        }\n        /** @hidden */\n        _drag(e) {\n            const p = this._eventPositions(e);\n            if (this.toolService.move(p, this._meta(e), e.event)) {\n                e.preventDefault();\n            }\n        }\n        /** @hidden */\n        _dragEnd(e) {\n            this._pauseMouseHandlers = false;\n            const p = this._eventPositions(e);\n            if (this.toolService.end(p, this._meta(e), e.event)) {\n                this.options.createToolBar();\n                e.preventDefault();\n            }\n        }\n        /** @hidden */\n        _mouseMove(e) {\n            if (!this._pauseMouseHandlers) {\n                const p = this._eventPositions(e);\n                this.toolService._updateHoveredItem(p, this._meta(e), e);\n                this.toolService._updateCursor(p);\n            }\n        }\n        /** @hidden */\n        _mouseDown() {\n            this._pauseMouseHandlers = true;\n        }\n        /** @hidden */\n        _mouseUp() {\n            this._pauseMouseHandlers = false;\n        }\n        /** @hidden */\n        _tap(e) {\n            const toolService = this.toolService;\n            const selectable = this.options.selectable;\n            const point = this._eventPositions(e);\n            const focused = this.focus();\n            const meta = this._meta(e);\n            toolService._updateHoveredItem(point, meta, e.event);\n            if (toolService.hoveredItem) {\n                const item = toolService.hoveredItem;\n                this.trigger('click', {\n                    nativeEvent: e.event,\n                    item: item,\n                    point: point,\n                    meta: meta\n                });\n                if (selectable && item.options.selectable !== false) {\n                    const multiple = selectable.multiple !== false;\n                    const ctrlPressed = kendo_common_cmn_chunk_js.m || meta.ctrlKey || (meta.metaKey && macOS());\n                    if (item.isSelected) {\n                        if (ctrlPressed) {\n                            this._destroyToolBar();\n                            item.select(false);\n                        }\n                        else {\n                            this.options.createToolBar(focused);\n                        }\n                    }\n                    else {\n                        this._destroyToolBar();\n                        this.select(item, {\n                            addToSelection: multiple && ctrlPressed\n                        });\n                        this.options.createToolBar(focused);\n                    }\n                }\n            }\n            else if (selectable) {\n                this._destroyToolBar();\n                this.deselect();\n            }\n        }\n        /** @hidden */\n        _keydown(e) {\n            if (this.toolService.keyDown(e.keyCode, this._meta(e))) {\n                e.preventDefault();\n            }\n        }\n        /** @hidden */\n        _wheel(e) {\n            const delta = mwDelta(e), p = this._eventPositions(e), meta = deepExtend(this._meta(e), { delta: delta });\n            if (this.toolService.wheel(p, meta, e)) {\n                e.preventDefault();\n            }\n        }\n        /** @hidden */\n        _meta(e) {\n            e = e.event || e;\n            return { ctrlKey: e.ctrlKey, metaKey: e.metaKey, altKey: e.altKey, shiftKey: e.shiftKey, type: e.type };\n        }\n        /** @hidden */\n        _eventPositions(e, start) {\n            let point;\n            if (e.touch) {\n                const field = start ? 'startLocation' : 'location';\n                point = new Point(e.x[field], e.y[field]);\n            }\n            else {\n                point = new Point(e.pageX, e.pageY);\n            }\n            return this.documentToModel(point);\n        }\n        /** @hidden */\n        _gestureStart(e) {\n            this._destroyToolBar();\n            this.scroller.disable();\n            const initialCenter = this.documentToModel(new Point(e.center.x, e.center.y));\n            const eventArgs = {\n                point: initialCenter,\n                zoom: this.zoom()\n            };\n            if (this.trigger(ZOOM_START, eventArgs)) {\n                return;\n            }\n            this._gesture = e;\n            this._initialCenter = initialCenter;\n        }\n        /** @hidden */\n        _gestureChange(e) {\n            const previousGesture = this._gesture;\n            const initialCenter = this._initialCenter;\n            const center = this.documentToView(new Point(e.center.x, e.center.y));\n            const scaleDelta = e.distance / previousGesture.distance;\n            let zoom = this._zoom;\n            let updateZoom = false;\n            if (Math.abs(scaleDelta - 1) >= MOBILE_ZOOM_RATE) {\n                this._zoom = zoom = this._getValidZoom(zoom * scaleDelta);\n                this.options.zoom = zoom;\n                this._gesture = e;\n                updateZoom = true;\n            }\n            const zoomedPoint = initialCenter.times(zoom);\n            const pan = center.minus(zoomedPoint);\n            if (updateZoom || this._pan.distanceTo(pan) >= MOBILE_PAN_DISTANCE) {\n                this._panTransform(pan);\n                this._updateAdorners();\n            }\n            e.preventDefault();\n        }\n        /** @hidden */\n        _doubleTap(e) {\n            const mobile = this._mobileOS();\n            if (!mobile) {\n                return;\n            }\n            const pointPosition = this._eventPositions(e);\n            const options = this.options;\n            const zoomRate = options.zoomRate;\n            let zoom = this.zoom() + zoomRate;\n            const meta = this._meta(e);\n            const zoomOptions = { point: pointPosition, meta: meta, zoom: zoom };\n            if (this.trigger(ZOOM_START, zoomOptions)) {\n                return;\n            }\n            zoom = kendo_drawing_cmn_chunk_js.r(Math.max(options.zoomMin, Math.min(options.zoomMax, zoom)), 2);\n            zoomOptions.zoom = zoom;\n            this.zoom(zoom, zoomOptions);\n            this.trigger(ZOOM_END, zoomOptions);\n        }\n        /** @hidden */\n        _gestureEnd() {\n            if (this.options.pannable !== false) {\n                this.scroller.enable();\n            }\n            this.trigger(ZOOM_END, {\n                point: this._initialCenter,\n                zoom: this.zoom()\n            });\n        }\n        /** @hidden */\n        _resize() {\n            const viewport = this.viewport();\n            if (this.canvas) {\n                this.canvas.size(viewport);\n            }\n            if (this.scrollable && this.toolBar) {\n                this.scrollable.style.height = viewport.height + 'px';\n            }\n        }\n        /** @hidden */\n        _mouseover(e) {\n            const node = e.target._kendoNode;\n            if (node && node.srcElement._hover) {\n                node.srcElement._hover(true, node.srcElement);\n            }\n        }\n        /** @hidden */\n        _mouseout(e) {\n            const node = e.target._kendoNode;\n            if (node && node.srcElement._hover) {\n                node.srcElement._hover(false, node.srcElement);\n            }\n        }\n        /** @hidden */\n        _initTheme(themeOptions) {\n            this.options = deepExtend({}, themeOptions, this.options);\n            if (this.options.editable === true) {\n                this.options.editable = (themeOptions || {}).editable;\n            }\n        }\n        /** @hidden */\n        _createOptionElements() {\n            const options = this.options;\n            const shapesLength = options.shapes.length;\n            if (shapesLength) {\n                this._createShapes();\n            }\n            if (options.connections.length) {\n                this._createConnections();\n            }\n            if (shapesLength && options.layout) {\n                this.layout(options.layout);\n            }\n        }\n        /** @hidden */\n        _createShapes() {\n            const options = this.options, shapes = options.shapes;\n            let shape, i;\n            for (i = 0; i < shapes.length; i++) {\n                shape = shapes[i];\n                this.addShape(shape);\n            }\n        }\n        /** @hidden */\n        _createConnections() {\n            const options = this.options, defaults = options.connectionDefaults, connections = options.connections;\n            let conn, source, target, i;\n            for (i = 0; i < connections.length; i++) {\n                conn = connections[i];\n                source = this._findConnectionTarget(conn.from);\n                target = this._findConnectionTarget(conn.to);\n                if (this.options.connect) {\n                    this.options.connect(source, target, deepExtend({}, defaults, conn));\n                }\n                else {\n                    this.connect(source, target, deepExtend({}, defaults, conn));\n                }\n            }\n        }\n        /** @hidden */\n        _findConnectionTarget(options) {\n            options = options || {};\n            const shapeId = isString$1(options) ? options : options.shapeId || options.id;\n            let target;\n            if (shapeId) {\n                target = this.getShapeById(shapeId);\n                if (options.connector) {\n                    target = target.getConnector(options.connector);\n                }\n            }\n            else {\n                target = new Point(options.x || 0, options.y || 0);\n            }\n            return target;\n        }\n        /**\n         * Destroys the diagram and cleans up all resources.\n         * Removes event listeners, destroys components, and clears all elements.\n         */\n        destroy() {\n            super.destroy();\n            this._destroyResizeObserver();\n            if (this._userEvents) {\n                this._userEvents.destroy();\n            }\n            this.clear();\n            this.element.removeEventListener('mousewheel', this._wheelHandler);\n            this.element.removeEventListener('wheel', this._wheelHandler);\n            this.element.removeEventListener('keydown', this._keydownHandler);\n            this.scrollable.removeEventListener('mouseover', this._mouseoverHandler);\n            this.scrollable.removeEventListener('mouseout', this._mouseoutHandler);\n            this.scrollable.removeEventListener('mousemove', this._mouseMoveHandler);\n            this.scrollable.removeEventListener('mousedown', this._mouseDownHandler);\n            this.scrollable.removeEventListener('mouseup', this._mouseUpHandler);\n            domEvents.forEach(event => {\n                this.scrollable.removeEventListener(event, this._domEvent);\n            });\n            this.canvas.destroy(true);\n            this.canvas = undefined;\n            this.destroyScroller();\n            this._destroyGlobalToolBar();\n            this._destroyToolBar();\n            this._inactiveShapeItems.destroy();\n        }\n        /**\n         * Destroys the scroller component and removes its element.\n         */\n        destroyScroller() {\n            const scroller = this.scroller;\n            if (!scroller) {\n                return;\n            }\n            scroller.destroy();\n            scroller.element.remove();\n            this.scroller = null;\n        }\n        /**\n         * Serializes the diagram to a JSON object containing shapes and connections.\n         * @returns Object with shapes and connections arrays\n         */\n        save() {\n            const json = {\n                shapes: [],\n                connections: []\n            };\n            let i, connection, shape;\n            for (i = 0; i < this.shapes.length; i++) {\n                shape = this.shapes[i];\n                if (shape.options.serializable) {\n                    const shapeOptions = deepExtend({}, shape.options);\n                    // Restore original dimensions if they were explicitly provided to prevent size inflation\n                    if (shape._originalWidth !== undefined) {\n                        shapeOptions.width = shape._originalWidth;\n                    }\n                    if (shape._originalHeight !== undefined) {\n                        shapeOptions.height = shape._originalHeight;\n                    }\n                    json.shapes.push(shapeOptions);\n                }\n            }\n            for (i = 0; i < this.connections.length; i++) {\n                connection = this.connections[i];\n                json.connections.push(deepExtend({}, connection.options, connection.toJSON()));\n            }\n            return json;\n        }\n        /**\n         * Sets focus to the diagram element.\n         * @returns True if focus was set, undefined otherwise\n         */\n        focus() {\n            if (this.element !== this.element.ownerDocument.activeElement) {\n                const element = this.element, containers = [], offsets = [], documentElement = element.ownerDocument.documentElement;\n                let scrollContainer = element, i;\n                do {\n                    scrollContainer = scrollContainer.parentNode;\n                    if (scrollContainer.scrollHeight > scrollContainer.clientHeight) {\n                        containers.push(scrollContainer);\n                        offsets.push(scrollContainer.scrollTop);\n                    }\n                } while (scrollContainer !== documentElement);\n                element.focus({ preventScroll: true });\n                for (i = 0; i < containers.length; i++) {\n                    containers[i].scrollTop = offsets[i];\n                }\n                return true;\n            }\n        }\n        /**\n         * Loads diagram data and recreates shapes and connections.\n         * @param options The diagram options containing shapes and connections data\n         */\n        load(options) {\n            this.clear();\n            this.setOptions(options);\n            this._createShapes();\n            this._createConnections();\n        }\n        /**\n         * Sets options for the diagram by deep extending the current options.\n         * @param options The options to merge with current diagram options\n         */\n        setOptions(options) {\n            deepExtend(this.options, options);\n        }\n        /**\n         * Clears the diagram by removing all selections and elements, then reinitializes.\n         */\n        clear() {\n            this.select(false);\n            this.mainLayer.clear();\n            this._shapesQuadTree.clear();\n            this._initialize();\n        }\n        /**\n         * Determines whether the the two items are connected.\n         *\n         * @param source Shape, Connector, Point.\n         * @param target Shape, Connector, Point.\n         * @returns true if the two items are connected.\n         */\n        connected(source, target) {\n            for (let i = 0; i < this.connections.length; i++) {\n                const c = this.connections[i];\n                if (c.from === source && c.to === target) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        /**\n         * Adds connection to the diagram.\n         *\n         * @param connection Connection.\n         * @param undoable Boolean.\n         * @returns The newly created connection.\n         */\n        addConnection(connection, undoable) {\n            if (undoable !== false) {\n                this.undoRedoService.add(new AddConnectionUnit(connection, this), false);\n            }\n            connection.diagram = this;\n            connection._setOptionsFromModel();\n            connection.refresh();\n            this.mainLayer.append(connection.visual);\n            this.connections.push(connection);\n            this.trigger(CHANGE$1, {\n                added: [connection],\n                removed: []\n            });\n            return connection;\n        }\n        /**\n         * Adds shape to the diagram.\n         *\n         * @param item Shape, Point. If point is passed it will be created new Shape and positioned at that point.\n         * @param options. The options to be passed to the newly created Shape.\n         * @returns The newly created shape.\n         */\n        addShape(item, undoable) {\n            let shape, shapeDefaults = this.options.shapeDefaults;\n            if (item instanceof Shape) {\n                shape = item;\n                this._parseBounds(shape.bounds());\n            }\n            else if (!(item.prototype)) {\n                shapeDefaults = deepExtend({}, shapeDefaults, item || {});\n                shape = new Shape(shapeDefaults, this);\n                this._parseBounds(shape.bounds());\n            }\n            else {\n                return;\n            }\n            if (undoable !== false) {\n                this.undoRedoService.add(new AddShapeUnit(shape, this), false);\n            }\n            this.shapes.push(shape);\n            if (shape.diagram !== this) {\n                this._shapesQuadTree.insert(shape);\n                shape.diagram = this;\n            }\n            this.mainLayer.append(shape.visual);\n            this.trigger(CHANGE$1, {\n                added: [shape],\n                removed: []\n            });\n            return shape;\n        }\n        /**\n         * Removes items (or single item) from the diagram.\n         *\n         * @param items DiagramElement, Array of Items.\n         * @param undoable.\n         */\n        remove(items, undoable) {\n            items = Array.isArray(items) ? items.slice(0) : [items];\n            const elements = splitDiagramElements(items);\n            const shapes = elements.shapes;\n            const connections = elements.connections;\n            let i;\n            if (!defined(undoable)) {\n                undoable = true;\n            }\n            if (undoable) {\n                this.undoRedoService.begin();\n            }\n            this._suspendModelRefresh();\n            for (i = shapes.length - 1; i >= 0; i--) {\n                this._removeItem(shapes[i], undoable, connections);\n            }\n            for (i = connections.length - 1; i >= 0; i--) {\n                this._removeItem(connections[i], undoable);\n            }\n            this._resumeModelRefresh();\n            if (undoable) {\n                this.undoRedoService.commit(false);\n            }\n            this.trigger(CHANGE$1, {\n                added: [],\n                removed: items\n            });\n        }\n        /** @hidden */\n        _addConnection(connection, undoable) {\n            if (this.options._addConnection) {\n                return this.options._addConnection(connection, undoable);\n            }\n            else if (!this.trigger('add', { connection: connection })) {\n                this.addConnection(connection, undoable);\n                connection._updateConnectors();\n                return connection;\n            }\n        }\n        /** @hidden */\n        _addShape(shape, undoable) {\n            if (this.options._addShape) {\n                return this.options._addShape(shape, undoable);\n            }\n            else if (!this.trigger('add', { shape: shape })) {\n                return this.addShape(shape, undoable);\n            }\n        }\n        /** @hidden */\n        _parseBounds(bounds) {\n            bounds.x = typeof (bounds.x) == 'string' ? parseFloat(bounds.x) : bounds.x;\n            bounds.y = typeof (bounds.y) == 'string' ? parseFloat(bounds.y) : bounds.y;\n        }\n        /** @hidden */\n        _shouldRefresh() {\n            return !this._suspended;\n        }\n        /** @hidden */\n        _suspendModelRefresh() {\n            this._suspended = (this._suspended || 0) + 1;\n        }\n        /** @hidden */\n        _resumeModelRefresh() {\n            this._suspended = Math.max((this._suspended || 0) - 1, 0);\n        }\n        /** @hidden */\n        _triggerRemove(items) {\n            const toRemove = [];\n            let item, args, editable;\n            for (let idx = 0; idx < items.length; idx++) {\n                item = items[idx];\n                editable = item.options.editable;\n                if (item instanceof Shape) {\n                    args = { shape: item };\n                }\n                else {\n                    args = { connection: item };\n                }\n                if (editable && editable.remove !== false && !this.trigger('remove', args)) {\n                    toRemove.push(item);\n                }\n            }\n            return toRemove;\n        }\n        /** @hidden */\n        _addConnections(connections, undoable) {\n            const length = connections.length;\n            for (let i = 0; i < length; i++) {\n                const dataItem = connections[i];\n                this._addConnectionDataItem(dataItem, undoable);\n            }\n        }\n        /** @hidden */\n        _addConnectionDataItem(dataItem, undoable) {\n            if (!this._connectionsDataMap[dataItem.uid]) {\n                let from = this._validateConnector(dataItem.from);\n                if (!defined(from) || from === null) {\n                    from = new Point(dataItem.fromX, dataItem.fromY);\n                }\n                let to = this._validateConnector(dataItem.to);\n                if (!defined(to) || to === null) {\n                    to = new Point(dataItem.toX, dataItem.toY);\n                }\n                if (defined(from) && defined(to)) {\n                    const options = deepExtend({}, this.options.connectionDefaults);\n                    options.dataItem = dataItem;\n                    const connection = new Connection(from, to, options);\n                    this._connectionsDataMap[dataItem.uid] = connection;\n                    this.addConnection(connection, undoable);\n                }\n            }\n        }\n        /** @hidden */\n        _validateConnector(value) {\n            let connector;\n            if (defined(value) && value !== null) {\n                connector = this._dataMap[value];\n            }\n            return connector;\n        }\n        /** @hidden */\n        _addDataItems(items, parent) {\n            let item, idx, shape, parentShape;\n            for (idx = 0; idx < items.length; idx++) {\n                item = items[idx];\n                shape = this._addDataItemByUid(item);\n                parentShape = this._addDataItemByUid(parent);\n                if (parentShape && !this.connected(parentShape, shape)) { // check if connected to not duplicate connections.\n                    this.connect(parentShape, shape);\n                }\n            }\n        }\n        /**\n         * Creates a connection between two endpoints (shapes, connectors, or points).\n         * @param source The source endpoint\n         * @param target The target endpoint\n         * @param options Optional connection configuration\n         * @returns The newly created connection\n         */\n        connect(source, target, options) {\n            const resolvedOptions = deepExtend({}, this.options.connectionDefaults, options);\n            const connection = new Connection(source, target, resolvedOptions);\n            return this.addConnection(connection);\n        }\n        /**\n         * Executes the next undoable action on top of the undo stack if any.\n         */\n        undo() {\n            this.undoRedoService.undo();\n        }\n        /**\n         * Executes the previous undoable action on top of the redo stack if any.\n         */\n        redo() {\n            this.undoRedoService.redo();\n        }\n        /**\n         * Selects items on the basis of the given input or returns the current selection if none.\n         *\n         * @param itemsOrRect DiagramElement, Array of elements, \"All\", false or Rect. A value 'false' will deselect everything.\n         * @param options\n         * @returns {Array} The currently selected items.\n         */\n        select(item, options) {\n            if (isDefined(item)) {\n                options = deepExtend({ addToSelection: false }, options);\n                const addToSelection = options.addToSelection, selected = [];\n                let items = [], i, element;\n                if (!addToSelection) {\n                    this.deselect();\n                }\n                this._internalSelection = true;\n                if (item instanceof Array) {\n                    items = item;\n                }\n                else if (item instanceof DiagramElement) {\n                    items = [item];\n                }\n                for (i = 0; i < items.length; i++) {\n                    element = items[i];\n                    if (element.select(true)) {\n                        selected.push(element);\n                    }\n                }\n                this._selectionChanged(selected, []);\n                this._internalSelection = false;\n            }\n            else {\n                return this._selectedItems;\n            }\n        }\n        /**\n         * Selects all shapes and connections in the diagram.\n         */\n        selectAll() {\n            this.select(this.shapes.concat(this.connections));\n        }\n        /**\n         * Selects shapes and connections within a rectangular area.\n         * @param rect The rectangular area to select items within\n         */\n        selectArea(rect) {\n            let i, items, item;\n            this._internalSelection = true;\n            const selected = [];\n            if (rect instanceof Rect) {\n                items = this.shapes.concat(this.connections);\n                for (i = 0; i < items.length; i++) {\n                    item = items[i];\n                    if ((!rect || item._hitTest(rect)) && item.options.enable) {\n                        if (item.select(true)) {\n                            selected.push(item);\n                        }\n                    }\n                }\n            }\n            this._selectionChanged(selected, []);\n            this._internalSelection = false;\n        }\n        /**\n         * Deselects items from the current selection.\n         * @param item The item(s) to deselect. If not provided, deselects all items.\n         */\n        deselect(item) {\n            this._internalSelection = true;\n            const deselected = [];\n            let items = [], element, i;\n            if (item instanceof Array) {\n                items = item;\n            }\n            else if (item instanceof DiagramElement) {\n                items.push(item);\n            }\n            else if (!isDefined(item)) {\n                items = this._selectedItems.slice(0);\n            }\n            for (i = 0; i < items.length; i++) {\n                element = items[i];\n                if (element.select(false)) {\n                    deselected.push(element);\n                }\n            }\n            this._selectionChanged([], deselected);\n            this._internalSelection = false;\n        }\n        /**\n         * Brings to front the passed items.\n         *\n         * @param items DiagramElement, Array of Items.\n         * @param undoable. By default the action is undoable.\n         */\n        toFront(items, undoable) {\n            if (!items) {\n                items = this._selectedItems.slice();\n            }\n            const result = this._getDiagramItems(items);\n            let indices;\n            if (!defined(undoable) || undoable) {\n                indices = indicesOfItems(this.mainLayer, result.visuals);\n                const unit = new ToFrontUnit(this, items, indices);\n                this.undoRedoService.add(unit);\n            }\n            else {\n                this.mainLayer.toFront(result.visuals);\n                this._fixOrdering(result, true);\n            }\n        }\n        /**\n         * Sends to back the passed items.\n         *\n         * @param items DiagramElement, Array of Items.\n         * @param undoable. By default the action is undoable.\n         */\n        toBack(items, undoable) {\n            if (!items) {\n                items = this._selectedItems.slice();\n            }\n            const result = this._getDiagramItems(items);\n            let indices;\n            if (!defined(undoable) || undoable) {\n                indices = indicesOfItems(this.mainLayer, result.visuals);\n                const unit = new ToBackUnit(this, items, indices);\n                this.undoRedoService.add(unit);\n            }\n            else {\n                this.mainLayer.toBack(result.visuals);\n                this._fixOrdering(result, false);\n            }\n        }\n        /**\n         * Bring into view the passed item(s) or rectangle.\n         *\n         * @param items DiagramElement, Array of Items, Rect.\n         * @param options. align - controls the position of the calculated rectangle relative to the viewport.\n         * \"Center middle\" will position the items in the center. animate - controls if the pan should be animated.\n         */\n        bringIntoView(item, options) {\n            const viewport = this.viewport();\n            const aligner = new RectAlign(viewport);\n            let rect;\n            if (viewport.width === 0 || viewport.height === 0) {\n                return;\n            }\n            options = deepExtend({ animate: false, align: 'center middle' }, options);\n            if (options.align === 'none') {\n                options.align = 'center middle';\n            }\n            if (item instanceof DiagramElement) {\n                rect = item.bounds(TRANSFORMED);\n            }\n            else if (Array.isArray(item)) {\n                rect = this.boundingBox(item);\n            }\n            else if (item instanceof Rect) {\n                rect = item.clone();\n            }\n            const original = rect.clone();\n            rect.zoom(this._zoom);\n            if (rect.width > viewport.width || rect.height > viewport.height) {\n                this._zoom = this._getValidZoom(Math.min(viewport.width / original.width, viewport.height / original.height));\n                rect = original.clone().zoom(this._zoom);\n            }\n            this._zoomMainLayer();\n            const current = rect.clone();\n            aligner.align(rect, options.align);\n            const newPan = rect.topLeft().minus(current.topLeft());\n            this.pan(newPan.times(-1), options.animate);\n        }\n        /**\n         * Aligns shapes in the specified direction.\n         * @param direction The alignment direction ('left', 'right', 'top', 'bottom')\n         */\n        alignShapes(direction) {\n            if (isUndefined(direction)) {\n                direction = 'Left';\n            }\n            let val, item, i;\n            const items = this.select();\n            if (items.length === 0) {\n                return;\n            }\n            switch (direction.toLowerCase()) {\n                case 'left':\n                case 'top':\n                    val = MAX_VALUE;\n                    break;\n                case 'right':\n                case 'bottom':\n                    val = MIN_VALUE;\n                    break;\n                default:\n                    break;\n            }\n            for (i = 0; i < items.length; i++) {\n                item = items[i];\n                if (item instanceof Shape) {\n                    switch (direction.toLowerCase()) {\n                        case 'left':\n                            val = Math.min(val, item.options.x);\n                            break;\n                        case 'top':\n                            val = Math.min(val, item.options.y);\n                            break;\n                        case 'right':\n                            val = Math.max(val, item.options.x);\n                            break;\n                        case 'bottom':\n                            val = Math.max(val, item.options.y);\n                            break;\n                        default:\n                            break;\n                    }\n                }\n            }\n            const undoStates = [];\n            const shapes = [];\n            for (i = 0; i < items.length; i++) {\n                item = items[i];\n                if (item instanceof Shape) {\n                    shapes.push(item);\n                    undoStates.push(item.bounds());\n                    switch (direction.toLowerCase()) {\n                        case 'left':\n                        case 'right':\n                            item.position(new Point(val, item.options.y));\n                            break;\n                        case 'top':\n                        case 'bottom':\n                            item.position(new Point(item.options.x, val));\n                            break;\n                        default:\n                            break;\n                    }\n                }\n            }\n            const unit = new TransformUnit(shapes, undoStates);\n            this.undoRedoService.add(unit, false);\n        }\n        /**\n         * Gets or sets the zoom level of the diagram.\n         * @param zoom The zoom level to set (1.0 = 100%). If not provided, returns the current zoom.\n         * @param options Options including the zoom point and metadata\n         * @returns The current zoom level when used as a getter\n         */\n        zoom(zoom, options) {\n            if (zoom) {\n                let staticPoint = options ? options.point : new Point(0, 0);\n                // var meta = options ? options.meta : 0;\n                zoom = this._zoom = this._getValidZoom(zoom);\n                if (!isUndefined(staticPoint)) { // Viewpoint vector is constant\n                    staticPoint = new Point(Math.round(staticPoint.x), Math.round(staticPoint.y));\n                    const zoomedPoint = staticPoint.times(zoom);\n                    const viewportVector = this.modelToView(staticPoint);\n                    const raw = viewportVector.minus(zoomedPoint); // pan + zoomed point = viewpoint vector\n                    this._storePan(new Point(Math.round(raw.x), Math.round(raw.y)));\n                }\n                if (options) {\n                    options.zoom = zoom;\n                }\n                this._panTransform();\n                if (this.canvas.surface.hideTooltip) {\n                    this.canvas.surface.hideTooltip();\n                }\n                this._updateAdorners();\n            }\n            return this._zoom;\n        }\n        /** @hidden */\n        _getPan(pan) {\n            const canvas = this.canvas;\n            if (!canvas.translate) {\n                pan = pan.plus(this._pan);\n            }\n            return pan;\n        }\n        /**\n         * Gets or sets the pan offset of the diagram.\n         * @param pan The pan offset as a Point. If not provided, returns the current pan.\n         * @param animate Whether to animate the pan operation\n         * @returns The current pan offset when used as a getter\n         */\n        pan(pan, animate) {\n            if (pan instanceof Point) {\n                const scroller = this.scroller;\n                pan = this._getPan(pan);\n                pan = pan.times(-1);\n                if (animate) {\n                    scroller.animatedScrollTo(pan.x, pan.y, () => {\n                        this._updateAdorners();\n                    });\n                }\n                else {\n                    scroller.scrollTo(pan.x, pan.y);\n                    this._updateAdorners();\n                }\n            }\n            else {\n                return this._pan.times(-1);\n            }\n        }\n        /**\n         * Gets the viewport rectangle of the diagram.\n         * @returns A Rect representing the current viewport\n         */\n        viewport() {\n            const element = this.element;\n            const width = elementWidth(element);\n            let height = elementHeight(element);\n            if (this.toolBar) {\n                height -= outerHeight(this.toolBar.element);\n            }\n            return new Rect(0, 0, width, height);\n        }\n        /**\n         * Copies the currently selected items to the clipboard.\n         */\n        copy() {\n            if (this.options.copy.enabled) {\n                this._clipboard.length = 0;\n                this._copyOffset = 1;\n                for (let i = 0; i < this._selectedItems.length; i++) {\n                    const item = this._selectedItems[i];\n                    this._clipboard.push(item);\n                }\n            }\n        }\n        /**\n         * Cuts the currently selected items to the clipboard and removes them from the diagram.\n         */\n        cut() {\n            if (this.options.copy.enabled) {\n                this._clipboard.length = 0;\n                this._copyOffset = 0;\n                for (let i = 0; i < this._selectedItems.length; i++) {\n                    const item = this._selectedItems[i];\n                    this._clipboard.push(item);\n                }\n                this.remove(this._clipboard, true);\n            }\n        }\n        /**\n         * Pastes items from the clipboard into the diagram.\n         */\n        paste() {\n            if (this._clipboard.length > 0) {\n                let item, copied, i;\n                const mapping = {};\n                const elements = splitDiagramElements(this._clipboard);\n                const connections = elements.connections;\n                const shapes = elements.shapes;\n                const offset = {\n                    x: this._copyOffset * this.options.copy.offsetX,\n                    y: this._copyOffset * this.options.copy.offsetY\n                };\n                this.deselect();\n                // first the shapes\n                for (i = 0; i < shapes.length; i++) {\n                    item = shapes[i];\n                    copied = item.clone();\n                    mapping[item.id] = copied;\n                    copied.position(new Point(item.options.x + offset.x, item.options.y + offset.y));\n                    copied.diagram = this;\n                    copied = this._addShape(copied);\n                    if (copied) {\n                        copied.select();\n                    }\n                }\n                // then the connections\n                for (i = 0; i < connections.length; i++) {\n                    item = connections[i];\n                    copied = this._addConnection(item.clone());\n                    if (copied) {\n                        this._updateCopiedConnection(copied, item, 'source', mapping, offset);\n                        this._updateCopiedConnection(copied, item, 'target', mapping, offset);\n                        copied.select(true);\n                        copied.updateModel();\n                    }\n                }\n                this._syncChanges();\n                this._copyOffset += 1;\n            }\n        }\n        /** @hidden */\n        _syncChanges() {\n            if (this.options._syncChanges) {\n                this.options._syncChanges();\n            }\n        }\n        /** @hidden */\n        _syncConnectionChanges() {\n            if (this.options._syncConnectionChanges) {\n                this.options._syncConnectionChanges();\n            }\n        }\n        /** @hidden */\n        _syncShapeChanges() {\n            if (this.options._syncShapeChanges) {\n                this.options._syncShapeChanges();\n            }\n        }\n        /** @hidden */\n        _updateCopiedConnection(connection, sourceConnection, connectorName, mapping, offset) {\n            let onActivate, inactiveItem, targetShape;\n            const target = sourceConnection[connectorName]();\n            if (target instanceof Connector && mapping[target.shape.id]) {\n                targetShape = mapping[target.shape.id];\n                if (this.getShapeById(targetShape.id)) {\n                    connection[connectorName](targetShape.getConnector(target.options.name));\n                }\n                else {\n                    inactiveItem = this._inactiveShapeItems.getByUid(targetShape.dataItem.uid);\n                    if (inactiveItem) {\n                        onActivate = (item) => {\n                            targetShape = this._dataMap[item.id];\n                            connection[connectorName](targetShape.getConnector(target.options.name));\n                            connection.updateModel();\n                        };\n                        this._deferredConnectionUpdates.push(inactiveItem.onActivate(onActivate));\n                    }\n                }\n            }\n            else {\n                connection[connectorName](new Point(sourceConnection[connectorName + 'Point']().x + offset.x, sourceConnection[connectorName + 'Point']().y + offset.y));\n            }\n        }\n        /**\n         * Gets the bounding rectangle of the given items.\n         *\n         * @param items DiagramElement, Array of elements.\n         * @param origin Boolean. Pass 'true' if you need to get the bounding box of the shapes without their rotation offset.\n         * @returns {Rect} The bounding rectangle of the items.\n         */\n        boundingBox(items, origin) {\n            let rect = Rect.empty(), temp;\n            const di = isDefined(items) ? this._getDiagramItems(items) : { shapes: this.shapes };\n            if (di.shapes.length > 0) {\n                let item = di.shapes[0];\n                rect = item.bounds(ROTATED);\n                for (let i = 1; i < di.shapes.length; i++) {\n                    item = di.shapes[i];\n                    temp = item.bounds(ROTATED);\n                    if (origin === true) {\n                        temp.x -= item._rotationOffset.x;\n                        temp.y -= item._rotationOffset.y;\n                    }\n                    rect = rect.union(temp);\n                }\n            }\n            return rect;\n        }\n        /** @hidden */\n        _containerOffset() {\n            const containerOffset = elementOffset(this.element);\n            if (this.toolBar) {\n                containerOffset.top += outerHeight(this.toolBar.element);\n            }\n            return containerOffset;\n        }\n        /**\n         * Converts a point from document coordinates to view coordinates.\n         * @param point The point in document coordinates\n         * @returns The point in view coordinates\n         */\n        documentToView(point) {\n            const containerOffset = this._containerOffset();\n            return new Point(point.x - containerOffset.left, point.y - containerOffset.top);\n        }\n        /**\n         * Converts a point from view coordinates to document coordinates.\n         * @param point The point in view coordinates\n         * @returns The point in document coordinates\n         */\n        viewToDocument(point) {\n            const containerOffset = this._containerOffset();\n            return new Point(point.x + containerOffset.left, point.y + containerOffset.top);\n        }\n        /**\n         * Converts a point from view coordinates to model coordinates.\n         * @param point The point in view coordinates\n         * @returns The point in model coordinates\n         */\n        viewToModel(point) {\n            return this._transformWithMatrix(point, this._matrixInvert);\n        }\n        /**\n         * Converts a point from model coordinates to view coordinates.\n         * @param point The point in model coordinates\n         * @returns The point in view coordinates\n         */\n        modelToView(point) {\n            return this._transformWithMatrix(point, this._matrix);\n        }\n        /**\n         * Converts a point from model coordinates to layer coordinates.\n         * @param point The point in model coordinates\n         * @returns The point in layer coordinates\n         */\n        modelToLayer(point) {\n            return this._transformWithMatrix(point, this._layerMatrix);\n        }\n        /**\n         * Converts a point from layer coordinates to model coordinates.\n         * @param point The point in layer coordinates\n         * @returns The point in model coordinates\n         */\n        layerToModel(point) {\n            return this._transformWithMatrix(point, this._layerMatrixInvert);\n        }\n        /**\n         * Converts a point from document coordinates to model coordinates.\n         * @param point The point in document coordinates\n         * @returns The point in model coordinates\n         */\n        documentToModel(point) {\n            const viewPoint = this.documentToView(point);\n            if (!this.canvas.translate) {\n                viewPoint.x = viewPoint.x + this.scroller.scrollLeft;\n                viewPoint.y = viewPoint.y + this.scroller.scrollTop;\n            }\n            return this.viewToModel(viewPoint);\n        }\n        /**\n         * Converts a point from model coordinates to document coordinates.\n         * @param point The point in model coordinates\n         * @returns The point in document coordinates\n         */\n        modelToDocument(point) {\n            return this.viewToDocument(this.modelToView(point));\n        }\n        /** @hidden */\n        _transformWithMatrix(point, matrix) {\n            let result = point;\n            if (point instanceof Point) {\n                if (matrix) {\n                    result = matrix.apply(point);\n                }\n            }\n            else {\n                const tl = this._transformWithMatrix(point.topLeft(), matrix), br = this._transformWithMatrix(point.bottomRight(), matrix);\n                result = Rect.fromPoints(tl, br);\n            }\n            return result;\n        }\n        /**\n         * Performs a diagram layout of the given type.\n         *\n         * @param layoutType The layout algorithm to be applied (TreeLayout, LayeredLayout, SpringLayout).\n         * @param options Layout-specific options.\n         */\n        layout(options) {\n            this._layouting = true;\n            // TODO: raise layout event?\n            let type;\n            if (isUndefined(options)) {\n                options = this.options.layout;\n            }\n            if (isUndefined(options) || isUndefined(options.type)) {\n                type = 'Tree';\n            }\n            else {\n                type = options.type;\n            }\n            let l;\n            switch (type.toLowerCase()) {\n                case 'tree':\n                    l = new TreeLayout(this);\n                    break;\n                case 'layered':\n                    l = new LayeredLayout(this);\n                    break;\n                case 'forcedirected':\n                case 'force':\n                case 'spring':\n                case 'springembedder':\n                    l = new SpringLayout(this);\n                    break;\n                default:\n                    throw new Error('Layout algorithm \\'' + type + '\\' is not supported.');\n            }\n            const initialState = new LayoutState(this);\n            const finalState = l.layout(options);\n            if (finalState) {\n                const unit = new LayoutUndoUnit(initialState, finalState, options ? options.animate : null);\n                this.undoRedoService.add(unit);\n            }\n            this._layouting = false;\n            this._redrawConnections();\n        }\n        /**\n         * Gets a shape by its unique identifier.\n         * @param {string} id The unique identifier of the shape\n         * @returns {Shape} The shape with the specified ID, or undefined if not found\n         */\n        getShapeById(id) {\n            let found;\n            found = first(this.shapes, function (s) {\n                return s.visual.id === id;\n            });\n            if (found) {\n                return found;\n            }\n            found = first(this.connections, function (c) {\n                return c.visual.id === id;\n            });\n            return found;\n        }\n        /**\n         * Gets a shape by its model ID.\n         * @param id The model ID of the shape\n         * @returns The shape with the specified model ID, or undefined if not found\n         */\n        getShapeByModelId(id) {\n            let shapeResult;\n            if (this._isEditable) {\n                shapeResult = this._dataMap[id];\n            }\n            else {\n                shapeResult = first(this.shapes, function (shape) {\n                    return (shape.dataItem || {}).id === id;\n                });\n            }\n            return shapeResult;\n        }\n        /**\n         * Gets a shape by its model UID.\n         * @param uid The model UID of the shape\n         * @returns The shape with the specified model UID, or undefined if not found\n         */\n        getShapeByModelUid(uid) {\n            let shapeResult;\n            if (this._isEditable) {\n                shapeResult = first(this.shapes, function (shape) {\n                    return (shape.dataItem || {}).uid === uid;\n                });\n            }\n            else {\n                shapeResult = this._dataMap[uid];\n            }\n            return shapeResult;\n        }\n        /** @hidden */\n        _extendLayoutOptions(options) {\n            if (options.layout) {\n                options.layout = deepExtend({}, LayoutDefaultOptions, options.layout);\n            }\n        }\n        /** @hidden */\n        _selectionChanged(selected, deselected) {\n            if (selected.length || deselected.length) {\n                this.trigger(SELECT$1, { selected: selected, deselected: deselected });\n            }\n        }\n        /** @hidden */\n        _getValidZoom(zoom) {\n            return Math.min(Math.max(zoom, this.options.zoomMin), this.options.zoomMax);\n        }\n        /** @hidden */\n        _panTransform(pos) {\n            const pan = pos || this._pan;\n            if (this.canvas.translate) {\n                this.scroller.scrollTo(pan.x, pan.y);\n                this._zoomMainLayer();\n            }\n            else {\n                this._storePan(pan);\n                this._transformMainLayer();\n            }\n        }\n        /** @hidden */\n        _finishPan() {\n            this.trigger(PAN, { total: this._pan, delta: Number.NaN });\n        }\n        /** @hidden */\n        _storePan(pan) {\n            this._pan = pan;\n            this._storeViewMatrix();\n        }\n        /** @hidden */\n        _zoomMainLayer() {\n            const zoom = this._zoom;\n            const transform = new CompositeTransform(0, 0, zoom, zoom);\n            transform.render(this.mainLayer);\n            this._storeLayerMatrix(transform);\n            this._storeViewMatrix();\n        }\n        /** @hidden */\n        _transformMainLayer() {\n            const pan = this._pan, zoom = this._zoom;\n            const transform = new CompositeTransform(pan.x, pan.y, zoom, zoom);\n            transform.render(this.mainLayer);\n            this._storeLayerMatrix(transform);\n            this._storeViewMatrix();\n        }\n        /** @hidden */\n        _storeLayerMatrix(canvasTransform) {\n            this._layerMatrix = canvasTransform.toMatrix();\n            this._layerMatrixInvert = canvasTransform.invert().toMatrix();\n        }\n        /** @hidden */\n        _storeViewMatrix() {\n            const pan = this._pan, zoom = this._zoom;\n            const transform = new CompositeTransform(pan.x, pan.y, zoom, zoom);\n            this._matrix = transform.toMatrix();\n            this._matrixInvert = transform.invert().toMatrix();\n        }\n        /** @hidden */\n        _toIndex(items, indices) {\n            const result = this._getDiagramItems(items);\n            this.mainLayer.toIndex(result.visuals, indices);\n            this._fixOrdering(result, false);\n        }\n        /** @hidden */\n        _fixOrdering(result, toFront) {\n            const shapePos = toFront ? this.shapes.length - 1 : 0, conPos = toFront ? this.connections.length - 1 : 0;\n            let i, item;\n            for (i = 0; i < result.shapes.length; i++) {\n                item = result.shapes[i];\n                remove(this.shapes, item);\n                insert(this.shapes, item, shapePos);\n            }\n            for (i = 0; i < result.cons.length; i++) {\n                item = result.cons[i];\n                remove(this.connections, item);\n                insert(this.connections, item, conPos);\n            }\n        }\n        /** @hidden */\n        _getDiagramItems(items) {\n            let i, args = items;\n            const result = {};\n            result.visuals = [];\n            result.shapes = [];\n            result.cons = [];\n            if (!items) {\n                args = this._selectedItems.slice();\n            }\n            else if (!Array.isArray(items)) {\n                args = [items];\n            }\n            for (i = 0; i < args.length; i++) {\n                const item = args[i];\n                if (item instanceof Shape) {\n                    result.shapes.push(item);\n                    result.visuals.push(item.visual);\n                }\n                else if (item instanceof Connection) {\n                    result.cons.push(item);\n                    result.visuals.push(item.visual);\n                }\n            }\n            return result;\n        }\n        /** @hidden */\n        _addDataItemByUid(dataItem) {\n            if (!defined(dataItem)) {\n                return;\n            }\n            let shape = this._dataMap[dataItem.uid];\n            if (shape) {\n                return shape;\n            }\n            const options = deepExtend({}, this.options.shapeDefaults);\n            options.dataItem = dataItem;\n            shape = new Shape(options, this);\n            this.addShape(shape);\n            this._dataMap[dataItem.uid] = shape;\n            return shape;\n        }\n        /** @hidden */\n        _addItem(item) {\n            if (item instanceof Shape) {\n                this.addShape(item);\n            }\n            else if (item instanceof Connection) {\n                this.addConnection(item);\n            }\n        }\n        /** @hidden */\n        _toolBarClick(e) {\n            this.trigger('toolBarClick', e);\n            this._destroyToolBar();\n        }\n        /** @hidden */\n        _normalizePointZoom(point) {\n            return point.times(1 / this.zoom());\n        }\n        /** @hidden */\n        _initialize() {\n            this.shapes.length = 0;\n            this.connections.length = 0;\n            this._selectedItems.length = 0;\n            Object.keys(this._dataMap).forEach((key) => {\n                delete this._dataMap[key];\n            });\n            Object.keys(this._connectionsDataMap).forEach((key) => {\n                delete this._connectionsDataMap[key];\n            });\n            this._deferredConnectionUpdates.length = 0;\n            this.undoRedoService = new UndoRedoService({\n                undone: this._syncChanges.bind(this),\n                redone: this._syncChanges.bind(this)\n            });\n            this.undoRedoService.bind('undo', (args) => {\n                this.trigger('undo', args);\n            });\n            this.undoRedoService.bind('redo', (args) => {\n                this.trigger('redo', args);\n            });\n            this.id = randomId();\n        }\n        /** @hidden */\n        _redrawConnections() {\n            const connections = this.connections;\n            for (let idx = 0; idx < connections.length; idx++) {\n                connections[idx].refresh();\n            }\n        }\n        /** @hidden */\n        _adorn(adorner, isActive) {\n            if (isActive !== undefined && adorner) {\n                if (isActive) {\n                    this._adorners.push(adorner);\n                    this.adornerLayer.append(adorner.visual);\n                }\n                else {\n                    remove(this._adorners, adorner);\n                    this.adornerLayer.remove(adorner.visual);\n                }\n            }\n        }\n        /** @hidden */\n        _showConnectors(shape, value) {\n            if (value) {\n                this._connectorsAdorner.show(shape);\n            }\n            else {\n                this._connectorsAdorner.destroy();\n            }\n        }\n        /** @hidden */\n        _updateAdorners() {\n            const adorners = this._adorners;\n            for (let i = 0; i < adorners.length; i++) {\n                const adorner = adorners[i];\n                if (adorner.refreshBounds) {\n                    adorner.refreshBounds();\n                }\n                adorner.refresh();\n            }\n        }\n        /** @hidden */\n        _refresh() {\n            for (let i = 0; i < this.connections.length; i++) {\n                this.connections[i].refresh();\n            }\n        }\n        /** @hidden */\n        _removeItem(item, undoable, removedConnections) {\n            item.select(false);\n            if (item instanceof Shape) {\n                this._removeShapeDataItem(item);\n                this._removeShape(item, undoable, removedConnections);\n            }\n            else if (item instanceof Connection) {\n                this._removeConnectionDataItem(item);\n                this._removeConnection(item, undoable);\n            }\n            this.mainLayer.remove(item.visual);\n        }\n        /** @hidden */\n        _removeConnectionDataItem(item) {\n            if (this._isEditable) {\n                this.options._removeConnectionDataItem(item.dataItem);\n                delete this._connectionsDataMap[item.dataItem.uid];\n            }\n        }\n        /** @hidden */\n        _removeShapeDataItem(item) {\n            if (this._isEditable) {\n                this.options._removeShapeDataItem(item.dataItem);\n                delete this._dataMap[item.dataItem.id];\n            }\n        }\n        /** @hidden */\n        _removeShape(shape, undoable, removedConnections) {\n            let i, connection, connector;\n            const sources = [], targets = [];\n            this.toolService._removeHover();\n            if (undoable) {\n                this.undoRedoService.addCompositeItem(new DeleteShapeUnit(shape));\n            }\n            remove(this.shapes, shape);\n            this._shapesQuadTree.remove(shape);\n            for (i = 0; i < shape.connectors.length; i++) {\n                connector = shape.connectors[i];\n                for (let j = 0; j < connector.connections.length; j++) {\n                    connection = connector.connections[j];\n                    if (!removedConnections || !contains(removedConnections, connection)) {\n                        if (connection.sourceConnector === connector) {\n                            sources.push(connection);\n                        }\n                        else if (connection.targetConnector === connector) {\n                            targets.push(connection);\n                        }\n                    }\n                }\n            }\n            for (i = 0; i < sources.length; i++) {\n                sources[i].source(null, undoable);\n                sources[i].updateModel();\n            }\n            for (i = 0; i < targets.length; i++) {\n                targets[i].target(null, undoable);\n                targets[i].updateModel();\n            }\n        }\n        /** @hidden */\n        _removeConnection(connection, undoable) {\n            if (connection.sourceConnector) {\n                remove(connection.sourceConnector.connections, connection);\n            }\n            if (connection.targetConnector) {\n                remove(connection.targetConnector.connections, connection);\n            }\n            if (undoable) {\n                this.undoRedoService.addCompositeItem(new DeleteConnectionUnit(connection));\n            }\n            remove(this.connections, connection);\n        }\n        /** @hidden */\n        _removeShapeConnections(shape) {\n            const connections = shape.connections();\n            let idx;\n            if (connections) {\n                for (idx = 0; idx < connections.length; idx++) {\n                    this._removeItem(connections[idx], false);\n                }\n            }\n        }\n        /** @hidden */\n        _destroyToolBar() {\n            this.options.destroyToolBar();\n        }\n        /** @hidden */\n        _destroyGlobalToolBar() {\n            if (this.toolBar) {\n                this.toolBar = null;\n            }\n        }\n        /** @hidden */\n        _mobileOS() {\n            return kendo_common_cmn_chunk_js.m;\n        }\n        /**\n         * Exports the diagram's DOM visual representation for rendering or export purposes.\n         * Creates a clipped group containing the canvas content with proper transformations.\n         * @returns A drawing Group element containing the exported DOM visual\n         */\n        exportDOMVisual() {\n            const viewBox = this.canvas._viewBox;\n            const scrollOffset = kendo_drawing_cmn_chunk_js.t()\n                .translate(-viewBox.x, -viewBox.y);\n            const viewRect = new kendo_drawing_cmn_chunk_js.R([0, 0], [viewBox.width, viewBox.height]);\n            const clipPath = kendo_drawing_cmn_chunk_js.a.fromRect(viewRect);\n            const wrap = new kendo_drawing_cmn_chunk_js.G({ transform: scrollOffset });\n            const clipWrap = new kendo_drawing_cmn_chunk_js.G({ clip: clipPath });\n            const root = this.canvas.drawingElement.children[0];\n            clipWrap.append(wrap);\n            // Don't reparent the root\n            wrap.children.push(root);\n            return clipWrap;\n        }\n        /**\n         * Exports the diagram's visual representation with proper scaling based on zoom level.\n         * Creates a scaled group containing the main layer content.\n         * @returns A drawing Group element containing the exported visual with inverse zoom scaling\n         */\n        exportVisual() {\n            const scaleX = 1 / this._zoom;\n            const scale = kendo_drawing_cmn_chunk_js.t().scale(scaleX, scaleX);\n            const wrap = new kendo_drawing_cmn_chunk_js.G({\n                transform: scale\n            });\n            const root = this.mainLayer.drawingElement;\n            wrap.children.push(root);\n            return wrap;\n        }\n        /**\n         * Updates the connection's underlying data model.\n         * Calls the configured updateConnectionModel function if available.\n         * @param connection The connection whose model should be updated\n         * @param syncChanges Whether to synchronize changes immediately\n         * @returns The result of the update operation, if any\n         */\n        updateConnectionModel(connection, syncChanges) {\n            if (this.options.updateConnectionModel) {\n                return this.options.updateConnectionModel(connection, syncChanges);\n            }\n        }\n        /**\n         * Updates the shape's underlying data model.\n         * Calls the configured updateShapeModel function if available.\n         * @param shape The shape whose model should be updated\n         * @param syncChanges Whether to synchronize changes immediately\n         * @returns The result of the update operation, if any\n         */\n        updateShapeModel(shape, syncChanges) {\n            if (this.options.updateShapeModel) {\n                return this.options.updateShapeModel(shape, syncChanges);\n            }\n        }\n    }\n\n    const elementStyles = (element) => element.ownerDocument.defaultView.getComputedStyle(element);\n    const cache = {};\n    const toColor = (colorMix, element) => {\n        if (cache[colorMix]) {\n            return cache[colorMix];\n        }\n        const curColor = element.style.color;\n        element.style.color = colorMix;\n        const color = elementStyles(element).color;\n        element.style.color = curColor;\n        cache[colorMix] = color;\n        return color;\n    };\n    const getProp = (element, prop) => {\n        let value = elementStyles(element).getPropertyValue(prop);\n        if (/^color-mix/i.test(value)) {\n            value = toColor(value, element);\n        }\n        return value;\n    };\n    const loadTheme = (element) => {\n        const primaryBg = getProp(element, '--kendo-chart-primary-bg');\n        const primaryContrast = getProp(element, '--kendo-chart-primary-contrast');\n        const normalTextColor = getProp(element, '--kendo-chart-text');\n        const normalBackground = getProp(element, '--kendo-color-surface');\n        return {\n            shapeDefaults: {\n                fill: {\n                    color: primaryBg\n                },\n                content: {\n                    color: primaryContrast\n                },\n                connectorDefaults: {\n                    fill: {\n                        color: normalTextColor\n                    },\n                    stroke: {\n                        color: primaryContrast\n                    },\n                    hover: {\n                        fill: {\n                            color: primaryContrast\n                        },\n                        stroke: {\n                            color: normalTextColor\n                        }\n                    }\n                }\n            },\n            editable: {\n                resize: {\n                    handles: {\n                        stroke: {\n                            color: normalTextColor\n                        },\n                        fill: {\n                            color: normalBackground\n                        },\n                        hover: {\n                            stroke: {\n                                color: normalTextColor\n                            },\n                            fill: {\n                                color: normalTextColor\n                            }\n                        }\n                    }\n                }\n            },\n            selectable: {\n                stroke: {\n                    color: normalTextColor\n                }\n            },\n            connectionDefaults: {\n                stroke: {\n                    color: normalTextColor\n                },\n                content: {\n                    color: normalTextColor,\n                    bgColor: primaryContrast\n                },\n                selection: {\n                    handles: {\n                        fill: {\n                            color: primaryContrast\n                        },\n                        stroke: {\n                            color: normalTextColor\n                        },\n                        width: 8,\n                        height: 8\n                    },\n                    stroke: {\n                        color: normalTextColor\n                    }\n                }\n            }\n        };\n    };\n\n    function getByPath(obj, path) {\n        if (!path)\n            return undefined;\n        return path.split('.').reduce((acc, k) => (isUndefined(acc) ? acc : acc[k]), obj);\n    }\n    function pick(src, pathOrFn) {\n        if (typeof pathOrFn === 'function') {\n            return pathOrFn(src);\n        }\n        return getByPath(src, pathOrFn);\n    }\n    const applyMapping = (src, mapping) => {\n        return src.map((row) => {\n            const item = {};\n            Object.keys(mapping).forEach((key) => {\n                const mappingKey = key;\n                const value = pick(row, mapping[mappingKey]);\n                if (value !== undefined) {\n                    item[mappingKey] = value;\n                }\n            });\n            return item;\n        });\n    };\n    /**\n     * Converts input data to diagram model format using the provided mapping configuration.\n     *\n     * This function takes raw input data and transforms it into a structured diagram model\n     * containing shapes and connections arrays. It uses the mapping configuration to\n     * extract data from the input and apply field mappings to create properly formatted\n     * ShapeOptions and ConnectionOptions objects.\n     *\n     * @param input - The raw input data object containing source data for shapes and connections\n     * @param mapping - Configuration object defining how to extract and map data from input\n     * @param mapping.shapes - Shape mapping configuration with source path and field mappings\n     * @param mapping.connections - Connection mapping configuration with source path and field mappings\n     * @returns An object containing arrays of mapped shapes and connections ready for diagram rendering\n     *\n     * @example\n     * ```typescript\n     * const input = {\n     *   items: [{ id: '1', name: 'Node 1', x: 100, y: 100 }],\n     *   links: [{ from: '1', to: '2' }]\n     * };\n     *\n     * const mapping = {\n     *   shapes: {\n     *     source: 'items',\n     *     map: { id: 'id', content: 'name', x: 'x', y: 'y' }\n     *   },\n     *   connections: {\n     *     source: 'links',\n     *     map: { from: 'from', to: 'to' }\n     *   }\n     * };\n     *\n     * const result = convertToDiagramModel(input, mapping);\n     * // Returns: { shapes: [...], connections: [...] }\n     * ```\n     *\n     */\n    const convertToDiagramModel = (input, mapping) => {\n        const { source: shapesSourceCollection, map: shapesMapping } = mapping.shapes;\n        const shapesData = pick(input, shapesSourceCollection) || [];\n        const shapes = applyMapping(shapesData, shapesMapping);\n        const { source: connectionsSourceCollection, map: connectionsMapping } = mapping.connections;\n        const connectionsData = pick(input, connectionsSourceCollection) || [];\n        const connections = applyMapping(connectionsData, connectionsMapping);\n        return { shapes, connections };\n    };\n\n    function documentToView(p, diagramRect, zoom, pan) {\n        return {\n            x: diagramRect.left + p.x * zoom - pan.x,\n            y: diagramRect.top + p.y * zoom - pan.y\n        };\n    }\n    function documentRectToView(r, diagramRect, zoom, pan) {\n        const tl = documentToView({ x: r.x, y: r.y }, diagramRect, zoom, pan);\n        return new Rect(tl.x, tl.y, r.width * zoom, r.height * zoom);\n    }\n    function nearestPointOnPolyline(poly, p) {\n        let best = { point: poly[0], segIdx: 0, t: 0, dist2: Number.POSITIVE_INFINITY };\n        for (let i = 0; i < poly.length - 1; i++) {\n            const a = poly[i], b = poly[i + 1];\n            const ab = { x: b.x - a.x, y: b.y - a.y };\n            const ap = { x: p.x - a.x, y: p.y - a.y };\n            const ab2 = ab.x * ab.x + ab.y * ab.y || 1e-9;\n            const t = Math.max(0, Math.min(1, (ap.x * ab.x + ap.y * ab.y) / ab2));\n            const proj = { x: a.x + ab.x * t, y: a.y + ab.y * t };\n            const dx = p.x - proj.x, dy = p.y - proj.y, d2 = dx * dx + dy * dy;\n            if (d2 < best.dist2)\n                best = { point: proj, segIdx: i, t, dist2: d2 };\n        }\n        return best;\n    }\n    const GAP = 10;\n    const MARGIN = 8;\n    function candidateRect(pos, anchor, tipW, tipH) {\n        switch (pos) {\n            case 'right':\n                return new Rect(anchor.x + GAP, anchor.y - tipH / 2, tipW, tipH);\n            case 'left':\n                return new Rect(anchor.x - GAP - tipW, anchor.y - tipH / 2, tipW, tipH);\n            case 'bottom':\n                return new Rect(anchor.x - tipW / 2, anchor.y + GAP, tipW, tipH);\n            case 'top':\n                return new Rect(anchor.x - tipW / 2, anchor.y - GAP - tipH, tipW, tipH);\n        }\n    }\n    function overflowScore(r, bounds) {\n        const leftOv = Math.max(0, bounds.left - r.x + MARGIN);\n        const topOv = Math.max(0, bounds.top - r.y + MARGIN);\n        const rightOv = Math.max(0, r.x + r.width - (bounds.right - MARGIN));\n        const bottomOv = Math.max(0, r.y + r.height - (bounds.bottom - MARGIN));\n        return leftOv + topOv + rightOv + bottomOv;\n    }\n    function segmentBufferRect(a, b, strokeHit) {\n        const minX = Math.min(a.x, b.x), maxX = Math.max(a.x, b.x);\n        const minY = Math.min(a.y, b.y), maxY = Math.max(a.y, b.y);\n        return new Rect(minX - strokeHit / 2, minY - strokeHit / 2, maxX - minX + strokeHit, maxY - minY + strokeHit);\n    }\n    const positionsPriority = ['right', 'left', 'bottom', 'top'];\n    /**\n     * Calculates the optimal position for a tooltip relative to a diagram shape or connection.\n     *\n     * This function handles coordinate transformations between document space (diagram model coordinates)\n     * and view space (browser viewport coordinates), accounting for zoom and pan transformations.\n     * It also performs collision detection and viewport boundary clamping.\n     *\n     * @param options - Configuration options for tooltip placement\n     * @param options.hovered - The diagram shape or connection being hovered\n     * @param options.mouse - Mouse position in document coordinates (diagram model space)\n     * @param options.shapes - Array of shape bounds in document coordinates\n     * @param options.connections - Array of connection polylines in document coordinates\n     * @param options.diagramRect - The diagram's bounding rectangle in view space\n     * @param options.zoom - Current zoom level of the diagram\n     * @param options.pan - Current pan offset of the diagram (as returned by diagram.pan())\n     * @param options.tooltipSize - Width and height of the tooltip element\n     * @param options.viewportBounds - Browser viewport bounds for clamping\n     * @returns Position object with left, top coordinates in view space and the chosen position side\n     */\n    function placeTooltip(options) {\n        const { hovered, shapes, connections, diagramRect, zoom, pan, tooltipSize, viewportBounds, mouse } = options;\n        const boundsForFit = viewportBounds;\n        let anchorView;\n        let shapeAnchors;\n        if (hovered.name === 'Shape') {\n            const rDocument = hovered.bounds();\n            const rView = documentRectToView(rDocument, diagramRect, zoom, pan);\n            const anchors = {\n                right: { x: rView.x + rView.width, y: rView.y + rView.height / 2 },\n                left: { x: rView.x, y: rView.y + rView.height / 2 },\n                bottom: { x: rView.x + rView.width / 2, y: rView.y + rView.height },\n                top: { x: rView.x + rView.width / 2, y: rView.y }\n            };\n            shapeAnchors = anchors;\n        }\n        else {\n            const poly = hovered.allPoints();\n            const near = nearestPointOnPolyline(poly, mouse);\n            anchorView = documentToView(near.point, diagramRect, zoom, pan);\n        }\n        const shapeRectsView = shapes.map((r) => documentRectToView(r, diagramRect, zoom, pan));\n        const strokeHit = 10; // px\n        const segRectsView = [];\n        for (const poly of connections) {\n            for (let i = 0; i < poly.length - 1; i++) {\n                const aView = documentToView(poly[i], diagramRect, zoom, pan);\n                const bView = documentToView(poly[i + 1], diagramRect, zoom, pan);\n                segRectsView.push(segmentBufferRect(aView, bView, strokeHit));\n            }\n        }\n        const candidates = [];\n        for (const pos of positionsPriority) {\n            const anchor = hovered.name === 'Shape' ? shapeAnchors[pos] : anchorView;\n            const rect = candidateRect(pos, anchor, tooltipSize.width, tooltipSize.height);\n            const ov = overflowScore(rect, boundsForFit);\n            let hits = 0;\n            for (const r of shapeRectsView)\n                if (rect.overlaps(r)) {\n                    hits++;\n                    break;\n                }\n            for (const r of segRectsView)\n                if (rect.overlaps(r)) {\n                    hits++;\n                    break;\n                }\n            candidates.push({ pos, rect, ov, hits });\n        }\n        candidates.sort((a, b) => a.ov - b.ov || a.hits - b.hits || positionsPriority.indexOf(a.pos) - positionsPriority.indexOf(b.pos));\n        const best = candidates[0];\n        const finalRect = best.ov === 0 ? best.rect : clampRect(best.rect, boundsForFit);\n        return { left: finalRect.x, top: finalRect.y, position: best.pos };\n    }\n    function clampRect(r, bounds) {\n        let x = r.x, y = r.y;\n        if (x < bounds.left + MARGIN)\n            x = bounds.left + MARGIN;\n        if (y < bounds.top + MARGIN)\n            y = bounds.top + MARGIN;\n        if (x + r.width > bounds.right - MARGIN)\n            x = bounds.right - MARGIN - r.width;\n        if (y + r.height > bounds.bottom - MARGIN)\n            y = bounds.bottom - MARGIN - r.height;\n        return new Rect(x, y, r.width, r.height);\n    }\n\n    exports.$ = MarkerBase;\n    exports.A = Document;\n    exports.B = PredefinedProcess;\n    exports.C = Canvas$1;\n    exports.D = Dictionary;\n    exports.E = Extract;\n    exports.F = Decision;\n    exports.G = Graph;\n    exports.H = HashTable;\n    exports.I = Intersect;\n    exports.J = Process;\n    exports.K = Terminator;\n    exports.L = Link;\n    exports.M = MatrixVector;\n    exports.N = Node;\n    exports.O = OffPageConnector;\n    exports.P = PathDefiner;\n    exports.Q = Queue;\n    exports.R = Range;\n    exports.S = Set;\n    exports.T = Ticker;\n    exports.U = Utils$1;\n    exports.V = VisualBase;\n    exports.W = TextBlock;\n    exports.X = CompositeTransform;\n    exports.Y = Polyline;\n    exports.Z = CircleMarker;\n    exports._ = ArrowMarker;\n    exports.__meta__ = __meta__;\n    exports.a = Matrix;\n    exports.a0 = Line;\n    exports.a1 = Layout;\n    exports.a2 = Path;\n    exports.a3 = Rectangle;\n    exports.a4 = Group;\n    exports.a5 = Circle;\n    exports.a6 = Rotation;\n    exports.a7 = Translation;\n    exports.a8 = Scale;\n    exports.a9 = Element;\n    exports.aA = AddShapeUnit;\n    exports.aB = PanUndoUnit;\n    exports.aC = TransformUnit;\n    exports.aD = CompositeUnit;\n    exports.aE = LayoutState;\n    exports.aF = LayoutBase;\n    exports.aG = LayeredLayout;\n    exports.aH = DiagramToHyperTreeAdapter;\n    exports.aI = TreeLayout;\n    exports.aJ = SpringLayout;\n    exports.aK = TemplateService;\n    exports.aL = DefaultConnectors;\n    exports.aM = shapeDefaults;\n    exports.aN = defined;\n    exports.aO = Shape;\n    exports.aP = events;\n    exports.aQ = Connection;\n    exports.aR = first;\n    exports.aS = defaultOptions;\n    exports.aT = Diagram;\n    exports.aU = ShapesQuadTree;\n    exports.aV = QuadRoot;\n    exports.aW = QuadNode;\n    exports.aX = Connector;\n    exports.aa = Markers;\n    exports.ab = diffNumericOptions;\n    exports.ac = Cursors;\n    exports.ad = RotateUnit;\n    exports.ae = ConnectionEditTool;\n    exports.af = PointerTool;\n    exports.ag = ScrollerTool;\n    exports.ah = SelectionTool;\n    exports.ai = CascadingRouter;\n    exports.aj = PolylineRouter;\n    exports.ak = ConnectionRouterBase;\n    exports.al = ToBackUnit;\n    exports.am = ToFrontUnit;\n    exports.an = ConnectionEditUnit;\n    exports.ao = LayoutUndoUnit;\n    exports.ap = ConnectorsAdorner;\n    exports.aq = ToolService;\n    exports.ar = Selector;\n    exports.as = ResizingAdorner;\n    exports.at = UndoRedoService;\n    exports.au = ConnectorVisual;\n    exports.av = ConnectionTool;\n    exports.aw = ConnectionEditAdorner;\n    exports.ax = DeleteConnectionUnit;\n    exports.ay = DeleteShapeUnit;\n    exports.az = AddConnectionUnit;\n    exports.b = RectAlign;\n    exports.c = Size;\n    exports.d = Rect;\n    exports.e = Geometry;\n    exports.f = Point;\n    exports.g = Image;\n    exports.h = MultipleDocuments;\n    exports.i = Collate;\n    exports.j = Sort;\n    exports.k = Delay;\n    exports.l = DataStorage;\n    exports.m = Merge;\n    exports.n = normalVariable;\n    exports.o = LogicalOr;\n    exports.p = SummingJunction;\n    exports.q = DataInputOutput;\n    exports.r = randomId;\n    exports.s = OnPageConnector;\n    exports.t = Database;\n    exports.u = DirectAccessStorage;\n    exports.v = Display;\n    exports.w = InternalStorage;\n    exports.x = ManualOperation;\n    exports.y = Preparation;\n    exports.z = ManualInputOutput;\n\n}));\n"]}